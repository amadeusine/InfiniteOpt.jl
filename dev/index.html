<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · InfiniteOpt.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>InfiniteOpt.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Quick-Start-1">Quick Start</a></li><li><a class="toctext" href="#Acknowledgements-1">Acknowledgements</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="InfiniteOpt.jl-1" href="#InfiniteOpt.jl-1">InfiniteOpt.jl</a></h1><p>&lt;img src=&quot;../../logo.png&quot; width=&quot;300&quot;/&gt;</p><p>A JuMP extension for expressing and solving infinite dimensional optimization problems.</p><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>InfiniteOpt.jl provides a mathematical interface to express and solve optimization problems that entail an infinite dimensional decision space. Such problems stem from areas such as dynamic programming, state-space models, and stochastic programming. InfiniteOpt.jl is meant to facilitate intuitive model definition, automatic transcription into solvable models, permit a wide range of user-defined extensions/behavior, and more. Currently, its capabilities include:</p><ul><li>JuMP-like macro based parameter and variable definition</li><li>JuMP-like macro based objective and constraint definition</li><li>Extensions to all JuMP modification methods (e.g., delete)</li><li>Measure abstractions and definition</li><li>Automatic model transcription and solution</li><li>Much more.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Currently, InfiniteOpt only accepts linear and quadratic expressions. Development is underway to allow for general nonlinear constraints.  </p></div></div><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p><code>InfiniteOpt.jl</code> is still in its early stages of development but can be installed by entering the following in the package manager.</p><pre><code class="language-julia">(v1.1) pkg&gt; add https://github.com/pulsipher/InfiniteOpt.jl</code></pre><h2><a class="nav-anchor" id="Quick-Start-1" href="#Quick-Start-1">Quick Start</a></h2><p>Below is a brief example of the high-level API.</p><pre><code class="language-julia">using Revise, InfiniteOpt, JuMP, Clp, Distributions

# Set the problem information
θ_nom, covar = [0.; 60.; 10.], [80. 0 0; 0 80. 0; 0 0 120.]
n_z, n_θ, n_d = 3, 3, 3
c = ones(n_d) / sqrt(n_d)
num_samples = 100

# Initialize the model
m = InfiniteModel(with_optimizer(Clp.Optimizer))

# Set the uncertainty parameters
dist = MvNormal(θ_nom, covar)
θs = rand(dist, num_samples)
@infinite_parameter(m, θ[i = 1:n_θ] in dist, supports = θs[i, :])
@infinite_parameter(m, 0 &lt;= t &lt;= 10, supports = Vector(0:10))

# Initialize the variables
@infinite_variable(m, z[1:n_z](θ, t))
@infinite_variable(m, 0 &lt;= y(θ) &lt;= 100)
@global_variable(m, d[1:n_d] &gt;= 0)

# Set objective function
expect_data = DiscreteMeasureData(θ, ones(num_samples) / num_samples,
                                  supports(θ), name = &quot;expect&quot;)
@objective(m, Min, measure(1 - y, expect_data))

# Set first stage constraints
@constraint(m, max_cost, sum(c[i] * d[i] for i = 1:n_d) &lt;= 5)

# Set the second stage constraints
@constraint(m, f1, -z[1] - 35 - d[1] + y &lt;= 0)
@constraint(m, f2, z[1] - 35 - d[1] + y &lt;= 0)
@constraint(m, f3, -z[2] - 50 - d[2] + y &lt;= 0)
@constraint(m, f4, z[1] - 50 - d[2] + y &lt;= 0)
@constraint(m, h1, z[1] - θ[1] == 0)
@constraint(m, h2, -z[1] -z[2] + z[3] - θ[2] == 0)
@constraint(m, h3, z[2] - θ[3] == 0)

# Solve and and obtain results
optimize!(m)
if has_values(m)
    opt_y = value(y)
    opt_d = value.(d)
    opt_obj = objective_value(m)
end</code></pre><h2><a class="nav-anchor" id="Acknowledgements-1" href="#Acknowledgements-1">Acknowledgements</a></h2><p>We acknowledge our support from the Department of Energy under grant DE-SC0014114.</p><ul><li><a href="#InfiniteOpt.AbstractInfiniteSet"><code>InfiniteOpt.AbstractInfiniteSet</code></a></li><li><a href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a></li><li><a href="#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a></li><li><a href="#InfiniteOpt.BoundedScalarConstraint"><code>InfiniteOpt.BoundedScalarConstraint</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s43,N} where N where #s43&lt;:ParameterRef,Array{#s42,1} where #s42&lt;:Number,Array{#s41,1} where #s41&lt;:AbstractArray}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s46,1} where #s46&lt;:Number,Array{#s45,1} where #s45&lt;:Number}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DistributionSet"><code>InfiniteOpt.DistributionSet</code></a></li><li><a href="#InfiniteOpt.FiniteConstraintRef"><code>InfiniteOpt.FiniteConstraintRef</code></a></li><li><a href="#InfiniteOpt.FiniteVariableRef"><code>InfiniteOpt.FiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.GeneralConstraintRef"><code>InfiniteOpt.GeneralConstraintRef</code></a></li><li><a href="#InfiniteOpt.GeneralVariableRef"><code>InfiniteOpt.GeneralVariableRef</code></a></li><li><a href="#InfiniteOpt.GlobalVariable"><code>InfiniteOpt.GlobalVariable</code></a></li><li><a href="#InfiniteOpt.GlobalVariableRef"><code>InfiniteOpt.GlobalVariableRef</code></a></li><li><a href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a></li><li><a href="#InfiniteOpt.InfOptVariable"><code>InfiniteOpt.InfOptVariable</code></a></li><li><a href="#InfiniteOpt.InfiniteConstraintRef"><code>InfiniteOpt.InfiniteConstraintRef</code></a></li><li><a href="#InfiniteOpt.InfiniteModel"><code>InfiniteOpt.InfiniteModel</code></a></li><li><a href="#InfiniteOpt.InfiniteModel-Tuple{JuMP.OptimizerFactory}"><code>InfiniteOpt.InfiniteModel</code></a></li><li><a href="#InfiniteOpt.InfiniteModel-Tuple{}"><code>InfiniteOpt.InfiniteModel</code></a></li><li><a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a></li><li><a href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.IntervalSet-Tuple{Number,Number}"><code>InfiniteOpt.IntervalSet</code></a></li><li><a href="#InfiniteOpt.IntervalSet"><code>InfiniteOpt.IntervalSet</code></a></li><li><a href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a></li><li><a href="#InfiniteOpt.MeasureConstraintRef"><code>InfiniteOpt.MeasureConstraintRef</code></a></li><li><a href="#InfiniteOpt.MeasureFiniteVariableRef"><code>InfiniteOpt.MeasureFiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a></li><li><a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.ParameterRef"><code>InfiniteOpt.ParameterRef</code></a></li><li><a href="#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a></li><li><a href="#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a></li><li><a href="#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a></li><li><a href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a></li><li><a href="#InfiniteOpt.add_measure-Tuple{InfiniteModel,Measure}"><code>InfiniteOpt.add_measure</code></a></li><li><a href="#InfiniteOpt.add_parameter"><code>InfiniteOpt.add_parameter</code></a></li><li><a href="#InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s52,N} where N where #s52&lt;:ParameterRef}}"><code>InfiniteOpt.add_parameter_ref</code></a></li><li><a href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s52,1} where #s52&lt;:Number}}"><code>InfiniteOpt.add_supports</code></a></li><li><a href="#InfiniteOpt.all_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.all_parameters</code></a></li><li><a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="#InfiniteOpt.build_optimizer_model!"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="#InfiniteOpt.build_parameter"><code>InfiniteOpt.build_parameter</code></a></li><li><a href="#InfiniteOpt.delete_supports-Tuple{ParameterRef}"><code>InfiniteOpt.delete_supports</code></a></li><li><a href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="#InfiniteOpt.expand-Tuple{MeasureRef}"><code>InfiniteOpt.expand</code></a></li><li><a href="#InfiniteOpt.expand_all_measures!-Tuple{InfiniteModel}"><code>InfiniteOpt.expand_all_measures!</code></a></li><li><a href="#InfiniteOpt.group_id-Tuple{ParameterRef}"><code>InfiniteOpt.group_id</code></a></li><li><a href="#InfiniteOpt.group_id-Tuple{AbstractArray{#s52,N} where N where #s52&lt;:ParameterRef}"><code>InfiniteOpt.group_id</code></a></li><li><a href="#InfiniteOpt.has_supports-Tuple{ParameterRef}"><code>InfiniteOpt.has_supports</code></a></li><li><a href="#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>InfiniteOpt.infinite_set</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.is_independent-Tuple{ParameterRef}"><code>InfiniteOpt.is_independent</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{ParameterRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a></li><li><a href="#InfiniteOpt.measure-Tuple{JuMP.AbstractJuMPScalar,AbstractMeasureData}"><code>InfiniteOpt.measure</code></a></li><li><a href="#InfiniteOpt.measure_data-Tuple{MeasureRef}"><code>InfiniteOpt.measure_data</code></a></li><li><a href="#InfiniteOpt.measure_function-Tuple{MeasureRef}"><code>InfiniteOpt.measure_function</code></a></li><li><a href="#InfiniteOpt.num_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.num_parameters</code></a></li><li><a href="#InfiniteOpt.num_supports-Tuple{ParameterRef}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="#InfiniteOpt.optimizer_model-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model</code></a></li><li><a href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model_key</code></a></li><li><a href="#InfiniteOpt.optimizer_model_ready-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model_ready</code></a></li><li><a href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a></li><li><a href="#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>InfiniteOpt.set_independent</code></a></li><li><a href="#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.set_infinite_set</code></a></li><li><a href="#InfiniteOpt.set_optimizer_model-Tuple{InfiniteModel,JuMP.Model}"><code>InfiniteOpt.set_optimizer_model</code></a></li><li><a href="#InfiniteOpt.set_optimizer_model_ready-Tuple{InfiniteModel,Bool}"><code>InfiniteOpt.set_optimizer_model_ready</code></a></li><li><a href="#InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}"><code>InfiniteOpt.set_parameter_refs</code></a></li><li><a href="#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s52,1} where #s52&lt;:Number}"><code>InfiniteOpt.set_supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{ParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{AbstractArray{#s42,N} where N where #s42&lt;:ParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>InfiniteOpt.unset_independent</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.used_by_point_variable</code></a></li><li><a href="#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.used_by_reduced_variable</code></a></li><li><a href="#InfiniteOpt.used_by_variable-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_variable</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a></li><li><a href="#JuMP.add_constraint"><code>JuMP.add_constraint</code></a></li><li><a href="#JuMP.add_variable"><code>JuMP.add_variable</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51&lt;:JuMP.AbstractJuMPScalar}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_constraints-Tuple{InfiniteModel}"><code>JuMP.all_constraints</code></a></li><li><a href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>JuMP.all_variables</code></a></li><li><a href="#JuMP.binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.binary_index</code></a></li><li><a href="#JuMP.binary_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.binary_index</code></a></li><li><a href="#JuMP.bridge_constraints-Tuple{InfiniteModel}"><code>JuMP.bridge_constraints</code></a></li><li><a href="#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, MeasureRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,MeasureFiniteVariableRef}, GenericAffExpr{Float64,MeasureRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,MeasureFiniteVariableRef}, GenericQuadExpr{Float64,MeasureRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>JuMP.build_constraint</code></a></li><li><a href="#JuMP.build_variable-Tuple{Function,JuMP.VariableInfo,Symbol}"><code>JuMP.build_variable</code></a></li><li><a href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a></li><li><a href="#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>JuMP.constraint_object</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a></li><li><a href="#JuMP.delete_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a></li><li><a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a></li><li><a href="#JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.fix</code></a></li><li><a href="#JuMP.fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_index</code></a></li><li><a href="#JuMP.fix_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_index</code></a></li><li><a href="#JuMP.fix_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a></li><li><a href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a></li><li><a href="#JuMP.index-Tuple{GeneralVariableRef}"><code>JuMP.index</code></a></li><li><a href="#JuMP.integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.integer_index</code></a></li><li><a href="#JuMP.integer_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.integer_index</code></a></li><li><a href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a></li><li><a href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound_index</code></a></li><li><a href="#JuMP.lower_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound_index</code></a></li><li><a href="#JuMP.name-Tuple{ParameterRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:JuMP.AbstractJuMPScalar}"><code>JuMP.num_constraints</code></a></li><li><a href="#JuMP.num_variables-Tuple{InfiniteModel}"><code>JuMP.num_variables</code></a></li><li><a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a></li><li><a href="#JuMP.objective_function-Tuple{InfiniteModel}"><code>JuMP.objective_function</code></a></li><li><a href="#JuMP.objective_function_type-Tuple{InfiniteModel}"><code>JuMP.objective_function_type</code></a></li><li><a href="#JuMP.objective_sense-Tuple{InfiniteModel}"><code>JuMP.objective_sense</code></a></li><li><a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a></li><li><a href="#JuMP.optimize!"><code>JuMP.optimize!</code></a></li><li><a href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a></li><li><a href="#JuMP.owner_model-Tuple{GeneralVariableRef}"><code>JuMP.owner_model</code></a></li><li><a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a></li><li><a href="#JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a></li><li><a href="#JuMP.set_binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_binary_index</code></a></li><li><a href="#JuMP.set_fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_fix_index</code></a></li><li><a href="#JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a></li><li><a href="#JuMP.set_integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_integer_index</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_lower_bound</code></a></li><li><a href="#JuMP.set_lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_lower_bound_index</code></a></li><li><a href="#JuMP.set_name-Tuple{PointVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{GlobalVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{ParameterRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_name-Tuple{InfiniteVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}"><code>JuMP.set_objective</code></a></li><li><a href="#JuMP.set_objective_function-Tuple{InfiniteModel,Real}"><code>JuMP.set_objective_function</code></a></li><li><a href="#JuMP.set_objective_function-Tuple{InfiniteModel,JuMP.AbstractJuMPScalar}"><code>JuMP.set_objective_function</code></a></li><li><a href="#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}"><code>JuMP.set_objective_sense</code></a></li><li><a href="#JuMP.set_optimizer-Tuple{InfiniteModel,JuMP.OptimizerFactory}"><code>JuMP.set_optimizer</code></a></li><li><a href="#JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_start_value</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.set_upper_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_upper_bound</code></a></li><li><a href="#JuMP.set_upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_upper_bound_index</code></a></li><li><a href="#JuMP.start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a></li><li><a href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a></li><li><a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a></li><li><a href="#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a></li><li><a href="#JuMP.unset_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a></li><li><a href="#JuMP.unset_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a></li><li><a href="#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a></li><li><a href="#JuMP.upper_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound_index</code></a></li><li><a href="#JuMP.upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound_index</code></a></li><li><a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a></li><li><a href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a></li><li><a href="#InfiniteOpt.@global_variable-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@global_variable</code></a></li><li><a href="#InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@infinite_parameter</code></a></li><li><a href="#InfiniteOpt.@infinite_variable-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@infinite_variable</code></a></li><li><a href="#InfiniteOpt.@point_variable-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@point_variable</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.AbstractInfiniteSet" href="#InfiniteOpt.AbstractInfiniteSet"><code>InfiniteOpt.AbstractInfiniteSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractInfiniteSet</code></pre><p>An abstract type for sets that characterize infinite parameters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.AbstractMeasureData" href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMeasureData</code></pre><p>An abstract type to define data for measures to define the behavior of <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.AbstractReducedInfo" href="#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractReducedInfo</code></pre><p>An abstract type reduced variable information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.BoundedScalarConstraint" href="#InfiniteOpt.BoundedScalarConstraint"><code>InfiniteOpt.BoundedScalarConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BoundedScalarConstraint{F &lt;: JuMP.AbstractJuMPScalar,
                        S &lt;: MOI.AbstractScalarSet} &lt;: JuMP.AbstractConstraint</code></pre><p>A DataType that stores infinite constraints defined on a subset of the infinite parameters on which they depend.</p><p><strong>Fields</strong></p><ul><li><code>func::F</code> The JuMP object.</li><li><code>set::S</code> The MOI set.</li><li><code>bounds::Dict{ParameterRef, IntervalSet}</code> A dictionary mapping parameter                                           references to an interval set.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL619-L631">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData" href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscreteMeasureData &lt;: AbstractMeasureData</code></pre><p>A DataType for one dimensional measure abstraction data where the measure abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>parameter_ref::ParameterRef</code> The infinite parameter over which the                               integration occurs.</li><li><code>coefficients::Vector{&lt;:Number}</code> Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Vector{&lt;:Number}</code> Support points <span>$\tau_i$</span> for the above                              measure abstraction.</li><li><code>name::String</code> Name of the measure that will be implemented.</li><li><code>weight_function::Function</code> Weighting function <span>$w$</span> must map support value                             input value of type <code>Number</code> to a scalar value.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL475-L492">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s43,N} where N where #s43&lt;:ParameterRef,Array{#s42,1} where #s42&lt;:Number,Array{#s41,1} where #s41&lt;:AbstractArray}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s43,N} where N where #s43&lt;:ParameterRef,Array{#s42,1} where #s42&lt;:Number,Array{#s41,1} where #s41&lt;:AbstractArray}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">DiscreteMeasureData(parameter_ref::AbstractArray{&lt;:ParameterRef},
                    coefficients::Vector{&lt;:Number},
                    supports::Vector{&lt;:AbstractArray{&lt;:Number}};
                    name::String = &quot;measure&quot;,
                    weight_function::Function = w(t) = 1
                    )::MultiDiscreteMeasureData</code></pre><p>Returns a <code>MultiDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure-Tuple{JuMP.AbstractJuMPScalar,AbstractMeasureData}"><code>measure</code></a>. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for <code>parameter_ref</code>. Note that <code>name</code> is used for printing purposes and a description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>MultiDiscreteMeasureData</code></a>. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or the parameters have different group IDs.</p><p><strong>Example</strong> ```julia julia&gt; data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]], name = &quot;example&quot;);</p><p>julia&gt; typeof(data) MultiDiscreteMeasureData</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL167-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s46,1} where #s46&lt;:Number,Array{#s45,1} where #s45&lt;:Number}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s46,1} where #s46&lt;:Number,Array{#s45,1} where #s45&lt;:Number}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">DiscreteMeasureData(parameter_ref::ParameterRef,
                    coefficients::Vector{&lt;:Number},
                    supports::Vector{&lt;:Number}; name::String = &quot;measure&quot;,
                    weight_function::Function = w(t) = 1)::DiscreteMeasureData</code></pre><p>Returns a <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure-Tuple{JuMP.AbstractJuMPScalar,AbstractMeasureData}"><code>measure</code></a>. This accepts input for a scalar (single) parameter. Note that <code>name</code> is used for printing purposes and a description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds or an unequal number of supports and coefficients are given.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], name = &quot;example&quot;)
DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], &quot;example&quot;, InfiniteOpt._w)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL138-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.DistributionSet" href="#InfiniteOpt.DistributionSet"><code>InfiniteOpt.DistributionSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DistributionSet{T &lt;: Distributions.NonMatrixDistribution} &lt;: AbstractInfiniteSet</code></pre><p>A DataType that stores the distribution characterizing infinite parameters that are random.</p><p><strong>Fields</strong></p><ul><li><code>distribution::T</code> Distribution of the random parameter.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL606-L614">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.FiniteConstraintRef" href="#InfiniteOpt.FiniteConstraintRef"><code>InfiniteOpt.FiniteConstraintRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FiniteConstraintRef{S &lt;: JuMP.AbstractShape} &lt;: GeneralConstraintRef</code></pre><p>A DataType for constraints that contain finite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of constraint in model.</li><li><code>shape::JuMP.AbstractShape</code> Shape of constraint</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL662-L671">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.FiniteVariableRef" href="#InfiniteOpt.FiniteVariableRef"><code>InfiniteOpt.FiniteVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FiniteVariableRef &lt;: GeneralVariableRef</code></pre><p>An abstract type to define new finite variable references.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL300-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.GeneralConstraintRef" href="#InfiniteOpt.GeneralConstraintRef"><code>InfiniteOpt.GeneralConstraintRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GeneralConstraintRef</code></pre><p>An abstract type for constraint references unique to InfiniteOpt.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL639-L643">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.GeneralVariableRef" href="#InfiniteOpt.GeneralVariableRef"><code>InfiniteOpt.GeneralVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GeneralVariableRef &lt;: JuMP.AbstractVariableRef</code></pre><p>An abstract type to for variable references used with infinite models.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL286-L290">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.GlobalVariable" href="#InfiniteOpt.GlobalVariable"><code>InfiniteOpt.GlobalVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GlobalVariable{S, T, U, V} &lt;: InfOptVariable</code></pre><p>A DataType for storing global variable information.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{S, T, U, V}</code> JuMP variable information.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL418-L424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.GlobalVariableRef" href="#InfiniteOpt.GlobalVariableRef"><code>InfiniteOpt.GlobalVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GlobalVariableRef &lt;: FiniteVariableRef</code></pre><p>A DataType for finite fixed variable references (e.g., first stage variables, steady-state variables).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL307-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfOptParameter" href="#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InfOptParameter{T &lt;: AbstractInfiniteSet} &lt;: JuMP.AbstractVariable</code></pre><p>A DataType for storing core infinite parameter information.</p><p><strong>Fields</strong></p><ul><li><code>set::T</code> The infinite set that characterizes the parameter.</li><li><code>supports::Vector{&lt;:Number}</code> The support points used to discretize this                              parameter.</li><li><code>independent::Bool</code> Is independent of other parameters that share its group ID                     number.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL8-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfOptVariable" href="#InfiniteOpt.InfOptVariable"><code>InfiniteOpt.InfOptVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InfOptVariable &lt;: JuMP.AbstractVariable</code></pre><p>An abstract type for infinite, point, and global variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL34-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfiniteConstraintRef" href="#InfiniteOpt.InfiniteConstraintRef"><code>InfiniteOpt.InfiniteConstraintRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>InfiniteConstraintRef{S &lt;: JuMP.AbstractShape} &lt;: GeneralConstraintRef</p><p>A DataType for constraints that contain infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of constraint in model.</li><li><code>shape::JuMP.AbstractShape</code> Shape of constraint</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL646-L655">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfiniteModel" href="#InfiniteOpt.InfiniteModel"><code>InfiniteOpt.InfiniteModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InfiniteModel &lt;: JuMP.AbstractModel</code></pre><p>A DataType for storing all of the mathematical modeling information needed to model an optmization problem with an infinite dimensional decision space.</p><p><strong>Fields</strong></p><ul><li><code>next_meas_index::Int</code> Index - 1 of next measure.</li><li><code>measures::Dict{Int, Measure}</code> Measure indices to measure datatypes.</li><li><code>meas_to_name::Dict{Int, String}</code> Measure indices to names.</li><li><code>meas_to_constrs::Dict{Int, Vector{Int}}</code> Measure indices to dependent                                           constraint indices.</li><li><code>meas_to_meas::Dict{Int, Vector{Int}}</code> Measure indices to dependent                                        measure indices.</li><li><code>meas_in_objective::Dict{Int, Bool}</code> Measure indices to if used in objective.</li><li><code>next_param_index::Int</code> Index - 1 of next infinite parameter.</li><li><code>next_param_id::Int</code> Index - 1 of the next infinite parameter group.</li><li><code>params::Dict{Int, InfOptParameter}</code> Infinite parameter indices to parameter                                      datatype.</li><li><code>param_to_name::Dict{Int, String}</code> Infinite parameter indices to names.</li><li><code>name_to_param::Union{Dict{String, Int}, Nothing}</code> Names to infinite                                                    parameters.</li><li><code>param_to_group_id::Dict{Int, Int}</code> Infinite parameter indices to group IDs.</li><li><code>param_to_constrs::Dict{Int, Vector{Int}}</code> Infinite parameter indices to list                                            of dependent constraint indices.</li><li><code>param_to_meas::Dict{Int, Vector{Int}}</code> Infinite parameter indices to list                                         of dependent measure indices.</li><li><code>param_to_vars::Dict{Int, Vector{Int}}</code> Infinite parameter indices to list                                         of dependent variable indices.</li><li><code>next_var_index::Int</code> Index - 1 of next variable index.</li><li><code>vars::Dict{Int, Dict{Int, Union{InfOptVariable, ReducedVariable}}</code> Variable                                                 indices to variable datatype.</li><li><code>var_to_name::Dict{Int, String}</code> Variable indices to names.</li><li><code>name_to_var::Union{Dict{String, Int}, Nothing}</code> Variable names to indices.</li><li><code>var_to_lower_bound::Dict{Int, Int}</code> Variable indices to lower bound index.</li><li><code>var_to_upper_bound::Dict{Int, Int}</code> Variable indices to upper bound index.</li><li><code>var_to_fix::Dict{Int, Int}</code> Variable indices to fix index.</li><li><code>var_to_zero_one::Dict{Int, Int}</code> Variable indices to binary index.</li><li><code>var_to_integrality::Dict{Int, Int}</code> Variable indices to integer index.</li><li><code>var_to_constrs::Dict{Int, Vector{Int}}</code> Variable indices to dependent                                          constraint indices.</li><li><code>var_to_meas::Dict{Int, Vector{Int}}</code> Variable indices to dependent                                       measure indices.</li><li><code>var_in_objective::Dict{Int, Bool}</code> Variable indices to if used in objective.</li><li><code>infinite_to_points::Dict{Int, Vector{Int}}</code> Infinite variable indices to                                              dependent point variable indices.</li><li><code>infinite_to_reduced::Dict{Int, Vector{Int}}</code> Infinite variable indices to                                              dependent reduced variable indices.</li><li><code>reduced_to_constrs::Dict{Int, Vector{Int}}</code> Reduced variable indices to dependent                                              constraint indices.</li><li><code>reduced_to_meas::Dict{Int, Vector{Int}}</code> Reduced variable indices to dependent                                           measure indices.</li><li><code>reduced_info::Dict{Int, AbstractReducedInfo}</code> Reduced variable indices to                                                reduced variable information.</li><li><code>next_constr_index::Int</code> Index - 1 of next constraint.</li><li><code>constrs::Dict{Int, JuMP.AbstractConstraint}</code> Constraint indices to constraint                                               datatypes.</li><li><code>constr_to_name::Dict{Int, String}</code> Constraint indices to names.</li><li><code>name_to_constr::Union{Dict{String, Int}, Nothing}</code> Constraint names to                                                     indices.</li><li><code>constr_in_var_info::Dict{Int, Bool}</code> Constraint indices to if related to                                       variable information constraints.</li><li><code>objective_sense::MOI.OptimizationSense</code> Objective sense.</li><li><code>objective_function::JuMP.AbstractJuMPScalar</code> Finite scalar function.</li><li><code>obj_dict::Dict{Symbol, Any}</code> Store Julia symbols used with <code>InfiniteModel</code></li><li><code>optimizer_factory::Union{JuMP.OptimizerFactory, Nothing}</code> Optimizer                                                            information.</li><li><code>optimizer_model::JuMP.Model</code> Model used to solve <code>InfiniteModel</code></li><li><code>ready_to_optimize::Bool</code> Is the optimizer_model up to date.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL71-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfiniteModel-Tuple{JuMP.OptimizerFactory}" href="#InfiniteOpt.InfiniteModel-Tuple{JuMP.OptimizerFactory}"><code>InfiniteOpt.InfiniteModel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">InfiniteModel(optimizer_factory::JuMP.OptimizerFactory;
              [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,
              bridge_constraints::Bool = true])</code></pre><p>Return a new infinite model using the optimizer factory <code>optimizer_factory</code> to create the optimizer. The optimizer factory can be created by the <a href="@ref"><code>JuMP.with_optimizer</code></a> function.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = InfiniteModel(with_optimizer(Ipopt.Optimizer))
An InfiniteOpt Model
Feasibility problem with:
Variables: 0
Optimizer model backend information:
Model mode: AUTOMATIC
CachingOptimizer state: EMPTY_OPTIMIZER
Solver name: SolverName() attribute not implemented by the optimizer.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL254-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfiniteModel-Tuple{}" href="#InfiniteOpt.InfiniteModel-Tuple{}"><code>InfiniteOpt.InfiniteModel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">InfiniteModel(; [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC])</code></pre><p>Return a new infinite model where no optimizer is specified. The optimizer can later be set with the <a href="@ref"><code>JuMP.optimizer!</code></a> call. By default the <code>optimizer_model</code> data field is initialized with a <code>TranscriptionModel</code>, but a different type of model can be assigned via <a href="#InfiniteOpt.set_optimizer_model-Tuple{InfiniteModel,JuMP.Model}"><code>set_optimizer_model</code></a> as can be required by extensions.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = InfiniteModel()
An InfiniteOpt Model
Feasibility problem with:
Variables: 0
Optimizer model backend information:
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL202-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfiniteVariable" href="#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InfiniteVariable{S, T, U, V} &lt;: InfOptVariable</code></pre><p>A DataType for storing core infinite variable information. Note each element of the parameter reference tuple must contain either a single <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> or an <code>AbstractArray</code> of <code>ParameterRef</code>s where each <code>ParameterRef</code> has the same group ID number.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{S, T, U, V}</code> JuMP variable information.</li><li><code>parameter_refs::Tuple</code> The infinite parameters(s) that parameterize the                         variable.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL383-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.InfiniteVariableRef" href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InfiniteVariableRef &lt;: GeneralVariableRef</code></pre><p>A DataType for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL337-L346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.IntervalSet" href="#InfiniteOpt.IntervalSet"><code>InfiniteOpt.IntervalSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntervalSet &lt;: AbstractInfiniteSet</code></pre><p>A DataType that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval.</p><p><strong>Fields</strong></p><ul><li><code>lower_bound::Float64</code> Lower bound of the infinite parameter.</li><li><code>upper_bound::Float64</code> Upper bound of the infinite parameter.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL582-L591">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.IntervalSet-Tuple{Number,Number}" href="#InfiniteOpt.IntervalSet-Tuple{Number,Number}"><code>InfiniteOpt.IntervalSet</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntervalSet(lower_bound::Number, upper_bound::Number)</code></pre><p>A constructor for <a href="#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a> that converts values of type <code>Number</code> to values of type <code>Float64</code> as required by <code>IntervalSet</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL597-L602">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.Measure" href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Measure{T &lt;: JuMP.AbstractJuMPScalar, V &lt;: AbstractMeasureData}</code></pre><p>A DataType for measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>func::T</code> Infinite variable expression.</li><li><code>data::V</code> Data of the abstraction as described in a <code>AbstractMeasureData</code>           subtype.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL56-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.MeasureConstraintRef" href="#InfiniteOpt.MeasureConstraintRef"><code>InfiniteOpt.MeasureConstraintRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MeasureConstraintRef{S &lt;: JuMP.AbstractShape} &lt;: GeneralConstraintRef</code></pre><p>A DataType for constraints that contain finite variables and measures.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of constraint in model.</li><li><code>shape::JuMP.AbstractShape</code> Shape of constraint</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL678-L687">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.MeasureFiniteVariableRef" href="#InfiniteOpt.MeasureFiniteVariableRef"><code>InfiniteOpt.MeasureFiniteVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MeasureFiniteVariableRef &lt;: GeneralVariableRef</code></pre><p>An abstract type to define finite variable and measure references.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL293-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.MeasureRef" href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MeasureRef &lt;: FiniteVariableRef</code></pre><p>A DataType for referring to measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL461-L469">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.MultiDiscreteMeasureData" href="#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MultiDiscreteMeasureData &lt;: AbstractMeasureData</code></pre><p>A DataType for multi-dimensional measure abstraction data where the measure abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>parameter_ref::JuMP.Containers.SparseAxisArray{&lt;:ParameterRef}</code> The infinite  parameters over which the integration occurs.</li><li><code>coefficients::Vector{&lt;:Number}</code> Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Vector{&lt;:JuMP.Containers.SparseAxisArray{&lt;:Number}}</code> Support points  <span>$\tau_i$</span> for the above measure abstraction.</li><li><code>name::String</code> Name of the measure that will be implemented.</li><li><code>weight_function::Function</code> Weighting function <span>$w$</span> must map a numerical                             support of type <code>JuMP.Containers.SparseAxisArray</code>                             to a scalar value.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL518-L536">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.ParameterRef" href="#InfiniteOpt.ParameterRef"><code>InfiniteOpt.ParameterRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ParameterRef &lt;: GeneralVariableRef</code></pre><p>A DataType for untranscripted infinite parameters references that parameterize the infinite variables.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL368-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.PointVariable" href="#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointVariable{S, T, U, V} &lt;: InfOptVariable</code></pre><p>A DataType for storing point variable information. Note that the elements <code>parameter_values</code> field must match the format of the parameter reference tuple defined in <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a></p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{S, T, U, V}</code> JuMP Variable information.</li><li><code>infinite_variable_ref::InfiniteVariableRef</code> The infinite variable associated                                              with the point variable.</li><li><code>parameter_values::Tuple</code> The infinite parameter values defining the point.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL400-L411">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.PointVariableRef" href="#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointVariableRef &lt;: FiniteVariableRef</code></pre><p>A DataType for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL322-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.ReducedInfiniteInfo" href="#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ReducedInfiniteInfo &lt;: AbstractReducedInfo</code></pre><p>A DataType for storing reduced infinite variable information.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::InfiniteVariableRef</code> The original infinite variable.</li><li><code>eval_supports::Dict{Int, Union{Number, JuMP.Containers.SparseAxisArray{&lt;:Number}}}</code> The original parameter tuple indices to the evaluation supports.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL429-L438">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.ReducedInfiniteVariableRef" href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ReducedInfiniteVariableRef &lt;: GeneralVariableRef</code></pre><p>A DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/datatypes.jl#LL352-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.add_measure-Tuple{InfiniteModel,Measure}" href="#InfiniteOpt.add_measure-Tuple{InfiniteModel,Measure}"><code>InfiniteOpt.add_measure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_measure(model::InfiniteModel, meas::Measure)::MeasureRef</code></pre><p>Add a measure to <code>model</code> and return the corresponding measure reference. This operates in a manner similar to <a href="#JuMP.add_variable"><code>JuMP.add_variable</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL115-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.add_parameter" href="#InfiniteOpt.add_parameter"><code>InfiniteOpt.add_parameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_parameter(model::InfiniteModel, p::InfOptParameter,
              name::String=&quot;&quot;)::ParameterRef</code></pre><p>Returns a <a href="#InfiniteOpt.ParameterRef"><code>ParameterRef</code></a> associated with the parameter <code>p</code> that is added to <code>model</code>. This adds a parameter to the model in a manner similar to <code>JuMP.add_variable</code>. This can be used to add parameters with the use of <a href="#InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}"><code>@infinite_parameter</code></a>. <a href="#InfiniteOpt.build_parameter"><code>build_parameter</code></a> should be used to construct <code>p</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; p = build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))
InfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)

julia&gt; param_ref = add_parameter(model, p, &quot;name&quot;)
name</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL163-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s52,N} where N where #s52&lt;:ParameterRef}}" href="#InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s52,N} where N where #s52&lt;:ParameterRef}}"><code>InfiniteOpt.add_parameter_ref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_parameter_ref(vref::InfiniteVariableRef,
                  pref::Union{ParameterRef, AbstractArray{&lt;:ParameterRef}})</code></pre><p>Add additional parameter reference or group of parameter references to be associated with the infinite variable <code>vref</code>. Errors if the parameter references are already added to the variable or if the added parameters have different group IDs.</p><pre><code class="language-julia">julia&gt; name(vref)
T(t)

julia&gt; add_parameter_ref(vref, x)

julia&gt; name(vref)
T(t, x)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL929-L947">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s52,1} where #s52&lt;:Number}}" href="#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s52,1} where #s52&lt;:Number}}"><code>InfiniteOpt.add_supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_supports(pref::ParameterRef, supports::Union{Number, Vector{&lt;:Number}})</code></pre><p>Add additional support points for <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; add_supports(t, 0.5)

julia&gt; supports(t)
3-element Array{Float64,1}:
 0.0
 0.5
 1.0

julia&gt; add_supports(t, [0.25, 1])

julia&gt; supports(t)
4-element Array{Float64,1}:
 0.0
 0.25
 0.5
 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL931-L955">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.all_parameters-Tuple{InfiniteModel}" href="#InfiniteOpt.all_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.all_parameters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">all_parameters(model::InfiniteModel)::Vector{ParameterRef}</code></pre><p>Return all of the infinite parameter references currently in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; all_parameters(model)
3-element Array{ParameterRef,1}:
 t
 x[1]
 x[2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL1112-L1125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.build_optimizer_model!" href="#InfiniteOpt.build_optimizer_model!"><code>InfiniteOpt.build_optimizer_model!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">build_optimizer_model!(model::InfiniteModel, key; kwargs...)</code></pre><p>Build the optimizer model stored in <code>model</code> such that it can be treated as a normal JuMP model, where the <code>Model.ext</code> field contains a key that points to a datastructure that appropriately maps the data between the two models. The key argument should be be typed to <code>Val{ext_key_name}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL187-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}" href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>InfiniteOpt.build_optimizer_model!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> build_optimizer_model!(model::InfiniteModel)</code></pre><p>Build the optimizer model stored in <code>model</code> such that it can be  treated as a normal JuMP model. Specifically, translate the variables and  constraints stored in <code>model</code> into ones that are stored in the optimizer model  and can be solved. This is build generally to accomodate extensions that use  custom optimizer model types in accordance with <a href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>optimizer_model_key</code></a>.  Extensions will need to implement their own version of the function  <code>build_optimizer_model!(model::InfiniteModel, key::Val{ext_key_name})</code>.</p><p><strong>Example</strong>  ```julia julia&gt; build<em>optimizer</em>model!(model)</p><p>julia&gt; optimizer<em>model</em>ready(model) true  ```</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL197-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.build_parameter" href="#InfiniteOpt.build_parameter"><code>InfiniteOpt.build_parameter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">build_parameter(_error::Function, set::AbstractInfiniteSet,
                [num_params::Int = 1;
                supports::Union{Number, Vector{&lt;:Number}} = Number[],
                independent::Bool = false])::InfOptParameter</code></pre><p>Returns a <a href="#InfiniteOpt.InfOptParameter"><code>InfOptParameter</code></a> given the appropriate information. This is analagous to <code>JuMP.build_variable</code>. Errors if supports violate the bounds associated <code>set</code>. Also errors if <code>set</code> contains a multivariate distribution with a different dimension than <code>num_params</code>. This is meant to primarily serve as a helper method for <a href="#InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}"><code>@infinite_parameter</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))
InfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL121-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.delete_supports-Tuple{ParameterRef}" href="#InfiniteOpt.delete_supports-Tuple{ParameterRef}"><code>InfiniteOpt.delete_supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">delete_supports(pref::ParameterRef)</code></pre><p>Delete the support points for <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; delete_supports(t)

julia&gt; supports(t)
ERROR: Parameter test does not have supports.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL965-L977">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">eval_supports(vref::ReducedInfiniteVariableRef)::Dict</code></pre><p>Return the evaluation supports associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; eval_supports(vref)
Dict{Int64,Float64} with 1 entry:
  1 =&gt; 0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL22-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.expand-Tuple{MeasureRef}" href="#InfiniteOpt.expand-Tuple{MeasureRef}"><code>InfiniteOpt.expand</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return a JuMP scalar function containing the explicit expansion of the measure <code>mref</code>. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with <a href="#InfiniteOpt.measure-Tuple{JuMP.AbstractJuMPScalar,AbstractMeasureData}"><code>measure</code></a> to expand measures on the fly.</p><p>This is useful for extensions that employ a custom optimizer<em>model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending `InfiniteOpt.</em>expand<em>measure<code>which should be of the form</code>InfiniteOpt.</em>expand<em>measure(::AbstractJuMPScalar, ::AbstractMeasureData, ::InfiniteModel, point</em>mapper::Function)`. See the source code in InfiniteOpt/src/measures.jl for examples of how to do this.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])

julia&gt; expr = expand(measure(g + z + T - h - 2, tdata))
0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measure_expansions.jl#LL353-L378">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.expand_all_measures!-Tuple{InfiniteModel}" href="#InfiniteOpt.expand_all_measures!-Tuple{InfiniteModel}"><code>InfiniteOpt.expand_all_measures!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">expand_all_measures!(model::InfiniteModel)</code></pre><p>Expand all of the measures used in the objective and/or constraints of <code>model</code>. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. Also errors if the expanded objective function is not finite.</p><p>This is useful for extensions that employ a custom optimizer<em>model since it can be used evaluate measures before <code>model</code> is translated into the new model. This method can also be extended to handle custom measure data types by extending `InfiniteOpt.</em>expand<em>measure<code>which should be of the form</code>InfiniteOpt.</em>expand<em>measure(::AbstractJuMPScalar, ::AbstractMeasureData, ::InfiniteModel, point</em>mapper::Function)`. See the source code in InfiniteOpt/src/measures.jl for examples of how to do this.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 T(t, xi) &gt;= 0.0
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 measure(T(t, xi)) &gt;= 0.0, for all xi in [-1, 1]
 t in [0, 6]
 xi in Normal(μ=0.0, σ=1.0)

julia&gt; expand_all_measures!(model)

julia&gt; print(model)
Min 3 g(6) + z
Subject to
 T(t, xi) &gt;= 0.0
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 0.5 T(0, xi) + 0.5 T(6, xi) &gt;= 0.0, for all xi in [-1, 1]
 t in [0, 6]
 xi in Normal(μ=0.0, σ=1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measure_expansions.jl#LL442-L483">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.group_id-Tuple{AbstractArray{#s52,N} where N where #s52&lt;:ParameterRef}" href="#InfiniteOpt.group_id-Tuple{AbstractArray{#s52,N} where N where #s52&lt;:ParameterRef}"><code>InfiniteOpt.group_id</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">group_id(prefs::AbstractArray{&lt;:ParameterRef})::Int</code></pre><p>Return the group ID number for a group of <code>prefs</code>. Error if contains multiple groups.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; group_id([x[1], x[2]])
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL998-L1009">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.group_id-Tuple{ParameterRef}" href="#InfiniteOpt.group_id-Tuple{ParameterRef}"><code>InfiniteOpt.group_id</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">group_id(pref::ParameterRef)::Int</code></pre><p>Return the group ID number for <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; group_id(t)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL983-L993">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.has_supports-Tuple{ParameterRef}" href="#InfiniteOpt.has_supports-Tuple{ParameterRef}"><code>InfiniteOpt.has_supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">has_supports(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> has supports or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_supports(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL803-L813">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.infinite_set-Tuple{ParameterRef}" href="#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>InfiniteOpt.infinite_set</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">infinite_set(pref::ParameterRef)::AbstractInfiniteSet</code></pre><p>Return the infinite set associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; infinite_set(t)
IntervalSet(0.0, 3.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL593-L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">infinite_variable_ref(vref::PointVariableRef)::InfiniteVariableRef</code></pre><p>Return the <code>InfiniteVariableRef</code> associated with the point variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; infinite_variable_ref(vref)
T(t, x)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL796-L806">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">infinite_variable_ref(vref::ReducedInfiniteVariableRef)::InfiniteVariableRef</code></pre><p>Return the <code>InfiniteVariableRef</code> associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; infinite_variable_ref(vref)
g(t, x)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL6-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.is_independent-Tuple{ParameterRef}" href="#InfiniteOpt.is_independent-Tuple{ParameterRef}"><code>InfiniteOpt.is_independent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_independent(pref::ParameterRef)::Bool</code></pre><p>Returns true for <code>pref</code> if it is independent or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_independent(t)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL1018-L1028">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_used(vref::InfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_used(vref)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL570-L580">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{MeasureRef}" href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_used(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_used(mref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL392-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{ParameterRef}" href="#InfiniteOpt.is_used-Tuple{ParameterRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_used(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used in the model or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_used(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL240-L250">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#InfiniteOpt.is_used-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_used(vref::InfOptVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_used(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL525-L535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.map_value" href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">map_value(vref::GeneralVariableRef, key)</code></pre><p>Map the value of <code>vref</code> to its counterpart in the optimizer model type distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL71-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.measure-Tuple{JuMP.AbstractJuMPScalar,AbstractMeasureData}" href="#InfiniteOpt.measure-Tuple{JuMP.AbstractJuMPScalar,AbstractMeasureData}"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">measure(expr::JuMP.AbstractJuMPScalar, data::AbstractMeasureData)::MeasureRef</code></pre><p>Return a measure reference that evaluates <code>expr</code> using according to <code>data</code>. This is the preferred method for implementing measures which follow the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter (scalar or vector) and <span>$w$</span> is the weight function. The measure data <code>data</code> determines how the measure is to be evaluated. Typically, the <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> constructor can be used to for <code>data</code>. The variable expression <code>expr</code> can contain <code>InfiniteOpt</code> variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Errors if <code>expr</code> does not contain infinite variables, infinite parameters, or measure references. Also errors if the measure parameter specified in <code>data</code> is not in <code>expr</code> and is not in any the nested measure references. Typically, this is called inside of <a href="@ref"><code>JuMP.@expression</code></a>, <a href="@ref"><code>JuMP.@objective</code></a>, and <a href="@ref"><code>JuMP.@constraint</code></a> in a manner similar to <code>sum</code>. Note measures are not explicitly evaluated until <a href="#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> is called.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2], name = &quot;name1&quot;);

julia&gt; xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]],
                                   name = &quot;name2&quot;);

julia&gt; constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)
name1(g(t) - s + 2) + s²

julia&gt; @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))
name1(g(t) - 1 + name2(T(t, x)))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL298-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.measure_data-Tuple{MeasureRef}" href="#InfiniteOpt.measure_data-Tuple{MeasureRef}"><code>InfiniteOpt.measure_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">measure_data(mref::MeasureRef)::AbstractMeasureData</code></pre><p>Return the measure data associated with <code>mref</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL212-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.measure_function-Tuple{MeasureRef}" href="#InfiniteOpt.measure_function-Tuple{MeasureRef}"><code>InfiniteOpt.measure_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return the function associated with <code>mref</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL203-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.num_parameters-Tuple{InfiniteModel}" href="#InfiniteOpt.num_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.num_parameters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_parameters(model::InfiniteModel)::Int</code></pre><p>Return the number of infinite parameters currently present in <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; num_parameters(model)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL556-L566">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.num_supports-Tuple{ParameterRef}" href="#InfiniteOpt.num_supports-Tuple{ParameterRef}"><code>InfiniteOpt.num_supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">num_supports(pref::ParameterRef)::Int</code></pre><p>Return the number of support points associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; num_supports(t)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL788-L798">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.optimizer_model-Tuple{InfiniteModel}" href="#InfiniteOpt.optimizer_model-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimizer_model(model::InfiniteModel)::JuMP.Model</code></pre><p>Return the JuMP model stored in <code>model</code> that is used to solve it.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; opt_model = optimizer_model(model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}" href="#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model_key</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimizer_model_key(model::InfiniteModel)::Any</code></pre><p>Return the extension key used in the optimizer model of <code>model</code>. Errors if <code>optimizer_model.ext</code> contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to <a href="#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; optimizer_model_key(model)
:TransData</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL165-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.optimizer_model_ready-Tuple{InfiniteModel}" href="#InfiniteOpt.optimizer_model_ready-Tuple{InfiniteModel}"><code>InfiniteOpt.optimizer_model_ready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">optimizer_model_ready(model::InfiniteModel)::Bool</code></pre><p>Return <code>Bool</code> if the optimizer model is up to date with <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; optimizer_model_ready(model)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL50-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}" href="#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parameter_by_name(model::InfiniteModel, name::String)::Union{ParameterRef,
                                                             Nothing}</code></pre><p>Return the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; parameter_by_name(model, &quot;t&quot;)
t</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL1073-L1085">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parameter_refs(vref::InfiniteVariableRef)::Tuple</code></pre><p>Return the <code>ParameterRef</code>(s) associated with the infinite variable <code>vref</code>. This is formatted as a Tuple of containing the parameter references as they inputted to define <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; parameter_refs(vref)
(t,   [2]  =  x[2]
  [1]  =  x[1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL874-L887">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parameter_refs(vref::ReducedInfiniteVariableRef)::Tuple</code></pre><p>Return the <code>ParameterRef</code>(s) associated with the reduced infinite variable <code>vref</code>. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untracripted infinite variable except, the evaluated parameters are excluded.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; parameter_refs(vref)
(t,   [2]  =  x[2]
  [1]  =  x[1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL39-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.parameter_values-Tuple{PointVariableRef}" href="#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">parameter_values(vref::PointVariableRef)::Tuple</code></pre><p>Return the support point associated with the point variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; parameter_values(vref)
(0, )</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL811-L821">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.set_independent-Tuple{ParameterRef}" href="#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>InfiniteOpt.set_independent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_independent(pref::ParameterRef)</code></pre><p>Specify that <code>pref</code> be independent.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_independent(t)

julia&gt; is_independent(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL1033-L1045">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}" href="#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.set_infinite_set</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_infinite_set(pref::ParameterRef, set::AbstractInfiniteSet)</code></pre><p>Specify the infinite set of <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_infinite_set(t, IntervalSet(0, 1))

julia&gt; infinite_set(t)
IntervalSet(0.0, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL608-L620">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.set_optimizer_model-Tuple{InfiniteModel,JuMP.Model}" href="#InfiniteOpt.set_optimizer_model-Tuple{InfiniteModel,JuMP.Model}"><code>InfiniteOpt.set_optimizer_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_optimizer_model(inf_model::InfiniteModel, opt_model::JuMP.Model)</code></pre><p>Specify the JuMP model that is used to solve <code>inf_model</code>. This is intended for internal use and extensions. Note that <code>opt_model</code> should contain extension data to allow it to map to <code>inf_model</code> in a manner similar to <a href="@ref"><code>TranscriptionModel</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_optimizer_model(model, TranscriptionModel())

julia&gt; optimizer_model(model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL82-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.set_optimizer_model_ready-Tuple{InfiniteModel,Bool}" href="#InfiniteOpt.set_optimizer_model_ready-Tuple{InfiniteModel,Bool}"><code>InfiniteOpt.set_optimizer_model_ready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_optimizer_model_ready(model::InfiniteModel, status::Bool)</code></pre><p>Set the status of the optimizer model to whether it is up to date or not. Note is more intended as an internal function, but is useful for extensions.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_optimizer_model_ready(model, true)

julia&gt; optimizer_model_ready(model)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL63-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}" href="#InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}"><code>InfiniteOpt.set_parameter_refs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_parameter_refs(vref::InfiniteVariableRef, prefs::Tuple)</code></pre><p>Specify a new parameter reference tuple <code>prefs</code> for the infinite variable <code>vref</code>. Note each element must contain a single parameter reference or an array of parameter references. Errors if a parameter is double specified or if an element contains parameters with different group IDs.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_parameter_refs(vref, (t, x))

julia&gt; parameter_refs(vref)
(t,   [2]  =  x[2]
  [1]  =  x[1])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL900-L916">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s52,1} where #s52&lt;:Number}" href="#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s52,1} where #s52&lt;:Number}"><code>InfiniteOpt.set_supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_supports(pref::ParameterRef, supports::Vector{&lt;:Number})</code></pre><p>Specify the support points for <code>pref</code>. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. Note that this will overwrite existing supports.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_supports(t, [0, 1])

julia&gt; supports(t)
2-element Array{Int64,1}:
 0
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL903-L919">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{AbstractArray{#s42,N} where N where #s42&lt;:ParameterRef}" href="#InfiniteOpt.supports-Tuple{AbstractArray{#s42,N} where N where #s42&lt;:ParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">supports(prefs::AbstractArray{&lt;:ParameterRef})::Vector</code></pre><p>Return the support points associated with an array of <code>prefs</code> formatted as a vector of SparseAxisArrays following the format of the input array. If the parameters are not independent then the supports of each parameter are simply spliced together. Alternatively can call <code>supports.</code> to more efficiently obtain an array of the same input format whose parameter references have been replaced with their supports. Errors if all the parameter references do not have the same group ID number (were intialized together as an array) or if the nonindependent parameters have support vectors of different lengths. If the parameters are independent then all the unique combinations are identified and returned as supports. Warning this operation is computationally expensive if there exist a large number of combinations.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; x = @infinite_parameter(model, [i = 1:2], set = IntervalSet(-1, 1),
                               base_name = &quot;x&quot;, independent = true)
2-element Array{ParameterRef,1}:
 x[1]
 x[2]

julia&gt; for i = 1:length(x)
           set_supports(x[i], [-1, 1])
       end

julia&gt; supports(x)
4-element Array{JuMP.Containers.SparseAxisArray,1}:
   [2]  =  -1
  [1]  =  -1
   [2]  =  1
  [1]  =  -1
   [2]  =  -1
  [1]  =  1
   [2]  =  1
  [1]  =  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL834-L872">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{ParameterRef}" href="#InfiniteOpt.supports-Tuple{ParameterRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">supports(pref::ParameterRef)::Vector</code></pre><p>Return the support points associated with <code>pref</code>. Errors if there are no supports.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; supports(t)
1-element Array{Int64,1}:
 1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL816-L828">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.unset_independent-Tuple{ParameterRef}" href="#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>InfiniteOpt.unset_independent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unset_independent(pref::ParameterRef)</code></pre><p>Specify that <code>pref</code> be not independent.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; unset_independent(t)

julia&gt; is_independent(t)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL1053-L1065">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_constraint(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_constraint(mref)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL347-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{ParameterRef}" href="#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_constraint(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by a constraint or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_constraint(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL195-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_constraint(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_constraint(vref)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL427-L437">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#InfiniteOpt.used_by_constraint-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_constraint(vref::InfOptVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_constraint(vref)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL480-L490">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_measure(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_measure(mref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL362-L372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{ParameterRef}" href="#InfiniteOpt.used_by_measure-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_measure(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by a measure or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_measure(t)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL210-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_measure(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_measure(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL442-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#InfiniteOpt.used_by_measure-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_measure(vref::InfOptVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_measure(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL495-L505">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_objective(vmref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_objective(mref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL377-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#InfiniteOpt.used_by_objective-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_objective(vref::InfOptVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_objective(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL510-L520">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.used_by_point_variable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_point_variable(vref::InfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a point variable.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_point_variable(vref)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL540-L550">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.used_by_reduced_variable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_reduced_variable(vref::InfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a reduced infinite variable.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_reduced_variable(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL555-L565">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.used_by_variable-Tuple{ParameterRef}" href="#InfiniteOpt.used_by_variable-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_variable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">used_by_variable(pref::ParameterRef)::Bool</code></pre><p>Return true if <code>pref</code> is used by an infinite variable or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_variable(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL225-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.@global_variable-Tuple{Any,Vararg{Any,N} where N}" href="#InfiniteOpt.@global_variable-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@global_variable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@global_variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> global variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference.</p><pre><code class="language-none">@global_variable(model, varexpr, args..., kw_args...)</code></pre><p>Add a global variable to <code>model</code> described by the expression <code>varexpr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>varexpr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>) of the form:</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of name <code>varname</code></li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; @global_variable(model, x)
x

julia&gt; @global_variable(model, 0 &lt;= y &lt;= 4, Bin)
y

julia&gt; y = @global_variable(model, lower_bound = 0, upper_bound = 4,
                            binary = true, base_name = &quot;y&quot;)
y

julia @global_variable(model, z[2:3] == 0)
1-dimensional DenseAxisArray{GlobalVariableRef,1,...} with index sets:
    Dimension 1, 2:3
And data, a 2-element Array{GlobalVariableRef,1}:
 z[2]
 z[3]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/macros.jl#LL674-L737">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}" href="#InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@infinite_parameter</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@infinite_parameter(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> infinite parameter to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the parameter reference.</p><pre><code class="language-none">@infinite_parameter(model, expr, kw_args...)</code></pre><p>Add a parameter to the model <code>model</code> described by the expression <code>expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code>, the symbol <code>&gt;=</code>can be used instead of <code>≥</code>, and the symbo <code>in</code> can be used instead of <code>∈</code>) The expression <code>expr</code> can be of the form:</p><ul><li><code>paramexpr</code> creating parameters described by <code>paramexpr</code>.</li><li><code>lb ≤ varexpr ≤ ub</code> creating parameters described by <code>paramexpr</code> characterized  by a continuous interval set with lower bound <code>lb</code> and upper bound <code>ub</code>.</li><li><code>paramexpr ∈ dist</code> creating parameters described by <code>paramexpr</code> characterized  by the <code>Distributions.jl</code> distribution object <code>dist</code>.</li></ul><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>paramname</code> creating a scalar parameter of name <code>paramname</code></li><li><code>paramname[...]</code> or <code>[...]</code> creating a container of parameters</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the parameter lower bound for an interval set.</li><li><code>upper_bound</code>: Sets the value of the parameter upper bound for an interval set.</li><li><code>set</code>: The <code>InfiniteSet</code> characterizing the parameters see <a href="#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>  and <a href="#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>.</li><li><code>distribution</code>: Sets the <code>Distributions.jl</code> distribution object that characterizes the parameters.</li><li><code>supports</code>: Sets the support points for the parameters.</li><li><code>independent</code>: Specifies if the each parameter is independent from each other or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong>  ```julia julia&gt; @infinite_parameter(m, 0 &lt;= x &lt;= 1) x</p><p>julia&gt; supps = [[0, 1, 2], [-1, 1]];</p><p>julia&gt; @infinite_parameter(m, y[i = 1:2] in Normal(), supports = supps[i]) 2-element Array{ParameterRef,1}:  y[1]  y[2]</p><p>julia&gt; z = @infinite_parameter(m, [&quot;a&quot;, &quot;b&quot;], distribution = Uniform(), independent = true) 2-dimensional DenseAxisArray{ParameterRef,2,...} with index sets:     Dimension 1, &quot;a&quot;     Dimension 2, &quot;b&quot; And data, a 1×1 Array{ParameterRef,2}:  noname  ```</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/macros.jl#LL90-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.@infinite_variable-Tuple{Any,Vararg{Any,N} where N}" href="#InfiniteOpt.@infinite_variable-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@infinite_variable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@infinte_variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> infinite variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference. Note that the <code>parameter_refs</code> keyword is required in this case.</p><pre><code class="language-none">@infinite_variable(model, varexpr, args..., kw_args...)</code></pre><p>Add an infinite variable to <code>model</code> described by the expression <code>var_expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>varexpr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>) of the form:</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of name <code>varname</code></li><li><code>varname(params...)</code> creating a scalar real variable of name <code>varname</code> with infinite parameters <code>params...</code> see <code>parameter_refs</code> for format.</li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li><li><code>varname[...](params...)</code> or <code>[...]</code> creating a container of variables with infinite parameters <code>params...</code> in the first case.</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>parameter_refs</code>: This is mandatory if not specified in <code>varexpr</code>. Can be a single parameter reference, a single parameter array with parameters defined in the same call of <a href="#InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}"><code>@infinite_parameter</code></a> (i.e., have same group ID), or a tuple where each element is either of the first two options listed.</li><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>. Furthermore, the parameter reference tuple is appended on the end of the name i.e., <code>base_name(params...)</code> or <code>base_name[...](params...)</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 1)
t

julia&gt; @infinite_parameter(model, w[1:2] in Normal())
2-element Array{ParameterRef,1}:
 w[1]
 w[2]

julia&gt; @infinite_variable(model, x(t, w) &gt;= 0)
x(t, w)

julia&gt; x = @infinite_variable(model, parameter_refs = (t, w), base_name = &quot;x&quot;,
                              lower_bound = 0)
x(t, w)

julia&gt; @infinite_variable(model, lb[i] &lt;= y[i = 1:2](t) &lt;= ub[i], Int)
2-element Array{InfiniteVariableRef,1}:
 y[1](t)
 y[2](t)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/macros.jl#LL363-L439">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="InfiniteOpt.@point_variable-Tuple{Any,Vararg{Any,N} where N}" href="#InfiniteOpt.@point_variable-Tuple{Any,Vararg{Any,N} where N}"><code>InfiniteOpt.@point_variable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@point_variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> point variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference. Note that the <code>infinite_variable_ref</code> and <code>parameter_values</code> keywords are required in this case.</p><pre><code class="language-none">@point_variable(model, infvarexpr, varexpr, args..., kw_args...)</code></pre><p>Add a point variable to <code>model</code> described by the expression <code>varexpr</code>, the positional arguments <code>args</code>, and the keyword arguments <code>kw_args</code> and the infinite variable expr <code>infvarexpr</code>. The expression <code>infvarexpr</code> specifies the infinite variable this point variable corresponds to and the values at which the parameters are evaluated and must be of the form: <code>infvar(param_values...)</code> where the parameter values <code>param_values...</code> are listed in the same format as they are in teh definition of <code>infvar</code>. The expression <code>varexpr</code> is used to define variable specific bounds and whose name is used as an alias for the point variable which is simply the infinite variable evaluated at the values indicated. The expression <code>varexpr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>) of the form:</p><ul><li><code>varexpr</code> creating variables described by <code>varexpr</code></li><li><code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>Note that be default a point variable inherits all of the same properties as  the infinite variable it corresponds to, but that these can be overwritten  by specifying properties such as lower bounds, fix values, etc.</p><p>The expression <code>varexpr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of alias name <code>varname</code></li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>infinite_variable_ref</code>: Sets the infinite variable reference that the point variable is associated with.</li><li><code>parameter_refs</code>: Sets the values of the infinite parameters of the infinite variable at which this poitn variable is evaluated at. Must be of the same format of that specified for the parameters in the definition of the infinite variable.</li><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>. This serves as the alias for <code>infvarexpr</code> (the infinite variable evaluated at particular parameter values).</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; @infinite_parameter(model, 0 &lt;= t &lt;= 1)
t

julia&gt; @infinite_parameter(model, w[1:2] in Normal())
2-element Array{ParameterRef,1}:
 w[1]
 w[2]

julia&gt; @infinite_variable(model, x(t, w) &gt;= 0)
x(t, w)

julia&gt; @point_variable(model, x(0, [0, 0]), x0 &lt;= 1)
x0

julia&gt; x0 = @point_variable(model, x(0, [0, 0]), upper_bound = 1, base_name = &quot;x0&quot;)
x0

julia&gt; x0 = @point_variable(model, upper_bound = 1, base_name = &quot;x0&quot;,
                            infinite_variable_ref = x, parameter_values = (0, [0, 0]))
x0

julia&gt; @point_variable(model, x([0, 1][i], [0, 0]), xf[i = 1:2])
2-element Array{PointVariableRef,1}:
 xf[1]
 xf[2]

julia&gt; @infinite_variable(model, lb[i] &lt;= y[i = 1:2](t) &lt;= ub[i], Int)
2-element Array{InfiniteVariableRef,1}:
y[1](t)
y[2](t)

julia&gt; @point_variable(model, y[i](0), y0[i = 1:2], Bin)
2-element Array{PointVariableRef,1}:
 y0[1]
 y0[2]

 julia&gt; y0 = @point_variable(model, [i = 1:2], binary = true, base_name = &quot;y0&quot;,
                             infinite_variable_ref = y[i], parameter_values = 0)
 2-element Array{PointVariableRef,1}:
  y0[1]
  y0[2]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/macros.jl#LL515-L624">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.BinaryRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL357-L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.BinaryRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.BinaryRef(vref::InfOptVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL589-L600">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.FixRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL288-L300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.FixRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.FixRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.FixRef(vref::InfOptVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL430-L441">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.IntegerRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL410-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.IntegerRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.IntegerRef(vref::InfOptVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL707-L718">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL146-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.LowerBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL132-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL217-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.UpperBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL272-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.add_bridge-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:MathOptInterface.Bridges.AbstractBridge}" href="#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.add_bridge(model::Model, BridgeType::Type{&lt;:MOI.Bridges.AbstractBridge})</code></pre><p>Extend [<code>JuMP.add_bridge</code>] to add <code>BridgeType</code> to the list of bridges that can be used by the optimizer model to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL37-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.add_constraint" href="#JuMP.add_constraint"><code>JuMP.add_constraint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">JuMP.add_constraint(model::InfiniteModel, c::JuMP.AbstractConstraint,
                    [name::String = &quot;&quot;])</code></pre><p>Extend <a href="#JuMP.add_constraint"><code>JuMP.add_constraint</code></a> to add a constraint <code>c</code> to an infinite model <code>model</code> with name <code>name</code>. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if a vector constraint is used, the constraint only constains parameters, or if any variables do not belong to <code>model</code>. This is primarily used as an internal method for the cosntraint macros.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; constr = build_constraint(error, g + x, MOI.EqualTo(42));

julia&gt; cref = add_constraint(model, constr, &quot;name&quot;)
name : g(t) + x == 42.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL156-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.add_variable" href="#JuMP.add_variable"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">JuMP.add_variable(model::InfiniteModel, v::InfOptVariable, name::String = &quot;&quot;)</code></pre><p>Extend the <a href="#JuMP.add_variable"><code>JuMP.add_variable</code></a> function to accomodate <code>InfiniteOpt</code> variable types. Adds a variable to an infinite model <code>model</code> and returns an appropriate variable reference (i.e., <a href="#InfiniteOpt.InfiniteVariableRef"><code>InfiniteVariableRef</code></a>, <a href="#InfiniteOpt.PointVariableRef"><code>PointVariableRef</code></a>, or <a href="#InfiniteOpt.GlobalVariableRef"><code>GlobalVariableRef</code></a>). Primarily intended to be an internal function of the constructor macros <a href="#InfiniteOpt.@infinite_variable-Tuple{Any,Vararg{Any,N} where N}"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable-Tuple{Any,Vararg{Any,N} where N}"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@global_variable-Tuple{Any,Vararg{Any,N} where N}"><code>@global_variable</code></a>. However, it can be used in combination with <a href="#JuMP.build_variable-Tuple{Function,JuMP.VariableInfo,Symbol}"><code>JuMP.build_variable</code></a> to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in <code>v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = t);

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,
                               parameter_values = 0.5);

julia&gt; pvref = add_variable(m, pt_var, &quot;var_alias&quot;)
var_alias

julia&gt; gb_var = build_variable(error, info, Global)

julia&gt; gvref = add_variable(m, gb_var, &quot;var_name&quot;)
var_name</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL357-L388">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar},
                     set_type::Type{&lt;:MOI.AbstractSet}
                     )::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to return a list of all the constraints with a particular function type and set type.</p><pre><code class="language-julia">julia&gt; all_constraints(model, GlobalVariableRef, MOI.LessThan)
1-element Array{GeneralConstraintRef,1}:
 x &lt;= 1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL465-L479">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51&lt;:JuMP.AbstractJuMPScalar}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51&lt;:JuMP.AbstractJuMPScalar}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar}
                     )::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to search by function types for all MOI sets and return a list of all constraints use a particular function type.</p><pre><code class="language-julia">julia&gt; all_constraints(model, GlobalVariableRef)
3-element Array{GeneralConstraintRef,1}:
 x &gt;= 0.0
 x &lt;= 3.0
 x integer</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL497-L512">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51&lt;:MathOptInterface.AbstractSet}" href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel,
                     set_type::Type{&lt;:MOI.AbstractSet}
                     )::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to search by MOI set type for all function types and return a list of all constraints that use a particular set type.</p><pre><code class="language-julia">julia&gt; all_constraints(model, MOI.GreaterThan)
3-element Array{GeneralConstraintRef,1}:
 x &gt;= 0.0
 g(t) &gt;= 0.0
 g(0.5) &gt;= 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL519-L534">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.all_constraints-Tuple{InfiniteModel}" href="#JuMP.all_constraints-Tuple{InfiniteModel}"><code>JuMP.all_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.all_constraints(model::InfiniteModel)::Vector{&lt;:GeneralConstraintRef}</code></pre><p>Extend <a href="#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a> to return all a list of all the constraints in an infinite model <code>model</code>.</p><pre><code class="language-julia">julia&gt; all_constraints(model)
5-element Array{GeneralConstraintRef,1}:
 x &gt;= 0.0
 x &lt;= 3.0
 x integer
 g(t) &gt;= 0.0
 g(0.5) &gt;= 0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL541-L556">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.all_variables-Tuple{InfiniteModel}" href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.all_variables(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Extend <a href="#JuMP.all_variables-Tuple{InfiniteModel}"><code>JuMP.all_variables</code></a> to return a list of all the variable references associated with <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; all_variables(m)
4-element Array{GeneralVariableRef,1}:
 ivar(test, θ)
 ivar2(test, x)
 name
 z</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL1047-L1062">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.binary_index-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.binary_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.binary_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.binary_index(vref::ReducedInfiniteVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.binary_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.binary_index</code></a> to return the index of the binary constraint associated with the original infinite variable of <code>vref</code>. Errors if <code>vref</code> is not binary.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; binary_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL337-L349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.binary_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.binary_index(vref::InfOptVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.binary_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.binary_index</code></a> to return the index of the binary constraint associated with <code>vref</code>. Errors if <code>vref</code> is not binary.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; binary_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL526-L537">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.bridge_constraints-Tuple{InfiniteModel}" href="#JuMP.bridge_constraints-Tuple{InfiniteModel}"><code>JuMP.bridge_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.bridge_constraints(model::InfiniteModel)::Bool</code></pre><p>Extend <a href="#JuMP.bridge_constraints-Tuple{InfiniteModel}"><code>JuMP.bridge_constraints</code></a> to return if an infinite model <code>model</code> has an optimizer model where the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; bridge_constraints(model)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL19-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, MeasureRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,MeasureFiniteVariableRef}, GenericAffExpr{Float64,MeasureRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,MeasureFiniteVariableRef}, GenericQuadExpr{Float64,MeasureRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}" href="#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, MeasureRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,MeasureFiniteVariableRef}, GenericAffExpr{Float64,MeasureRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,MeasureFiniteVariableRef}, GenericQuadExpr{Float64,MeasureRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>JuMP.build_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.build_constraint(_error::Function, expr::InfiniteExpr,
                      set::MOI.AbstractScalarSet;
                      [parameter_bounds::Dict{ParameterRef, IntervalSet} = Dict()])</code></pre><p>Extend <a href="#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, MeasureRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,MeasureFiniteVariableRef}, GenericAffExpr{Float64,MeasureRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,MeasureFiniteVariableRef}, GenericQuadExpr{Float64,MeasureRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>JuMP.build_constraint</code></a> to accept the parameter<em>bounds argument and return a <a href="#InfiniteOpt.BoundedScalarConstraint"><code>BoundedScalarConstraint</code></a> if the `parameter</em>bounds<code>keyword argument is specifed or return a [</code>ScalarConstraint`](@ref) otherwise. This is primarily intended to work as an internal function for constraint macros.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; constr = build_constraint(error, g + x, MOI.EqualTo(42.0),
                               parameter_bounds = Dict(t =&gt; IntervalSet(0, 1)));

julia&gt; isa(constr, BoundedScalarConstraint)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL61-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.build_variable-Tuple{Function,JuMP.VariableInfo,Symbol}" href="#JuMP.build_variable-Tuple{Function,JuMP.VariableInfo,Symbol}"><code>JuMP.build_variable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.build_variable(_error::Function, info::JuMP.VariableInfo,
                    var_type::Symbol;
                    parameter_refs::Union{ParameterRef,
                                          AbstractArray{&lt;:ParameterRef},
                                          Tuple, Nothing} = nothing,
                    infinite_variable_ref::Union{InfiniteVariableRef,
                                                 Nothing} = nothing,
                    parameter_values::Union{Number, AbstractArray{&lt;:Number},
                                            Tuple, Nothing} = nothing,
                    error::Union{Function, Nothing} = nothing,
                    extra_kw_args...)</code></pre><p>Extend the <a href="#JuMP.build_variable-Tuple{Function,JuMP.VariableInfo,Symbol}"><code>JuMP.build_variable</code></a> function to accomodate <code>InfiniteOpt</code> variable types. Returns the appropriate variable Datatype (i.e., <a href="#InfiniteOpt.InfiniteVariable"><code>InfiniteVariable</code></a>, <a href="#InfiniteOpt.PointVariable"><code>PointVariable</code></a>, and <a href="#InfiniteOpt.GlobalVariable"><code>GlobalVariable</code></a>). Primarily this method is to be used internally by the appropriate constructor macros <a href="#InfiniteOpt.@infinite_variable-Tuple{Any,Vararg{Any,N} where N}"><code>@infinite_variable</code></a>, <a href="#InfiniteOpt.@point_variable-Tuple{Any,Vararg{Any,N} where N}"><code>@point_variable</code></a>, and <a href="#InfiniteOpt.@global_variable-Tuple{Any,Vararg{Any,N} where N}"><code>@global_variable</code></a>. However, it can be called manually to build <code>InfiniteOpt</code> variables. Errors if an unneeded keyword argument is given or if the keywoard arguments are formatted incorrectly (e.g., <code>parameter_refs</code> contains repeated parameter references when an infinite variable is defined). Also errors if needed kewword arguments are negated.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; @infinite_parameter(m, 0 &lt;= t &lt;= 1)
t

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);

julia&gt; inf_var = build_variable(error, info, Infinite, parameter_refs = t)
InfiniteVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}
(false, 0, false, 0, false, 0, false, 0, false, false), (t,))

julia&gt; ivref = add_variable(m, inf_var, &quot;var_name&quot;)
var_name(t)

julia&gt; pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,
                               parameter_values = 0.5)
PointVariable{Int64,Int64,Int64,Float64}(VariableInfo{Int64,Int64,Int64,Float64}
(false, 0, false, 0, false, 0, true, 0.0, false, false), var_name(t), (0.5,))

julia&gt; gb_var = build_variable(error, info, Global)
GlobalVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}
(false, 0, false, 0, false, 0, false, 0, false, false))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL199-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.constraint_by_name-Tuple{InfiniteModel,String}" href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.constraint_by_name(model::InfiniteModel,
                        name::String)::Union{GeneralConstraintRef, Nothing}</code></pre><p>Extend <a href="#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a> to return the constraint reference associated with <code>name</code> if one exists or returns nothing. Errors if more than one constraint uses the same name.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; constraint_by_name(model, &quot;constr_name&quot;)
constr_name : x + pt == 3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL351-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.constraint_object-Tuple{GeneralConstraintRef}" href="#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>JuMP.constraint_object</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.constraint_object(cref::GeneralConstraintRef)::JuMP.AbstractConstraint</code></pre><p>Extend <a href="#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>JuMP.constraint_object</code></a> to return the constraint object associated with <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; obj = constraint_object(cref)
ScalarConstraint{GlobalVariableRef,MathOptInterface.LessThan{Float64}}(x,
MathOptInterface.LessThan{Float64}(1.0))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL285-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}" href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, cref::GeneralConstraintRef)</code></pre><p>Extend <a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> to delete an <code>InfiniteOpt</code> constraint and all associated information. Errors if <code>cref</code> is invalid.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 t in [0, 6]

julia&gt; delete(model, cref)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z &gt;= 0.0
 t in [0, 6]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL204-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, mref::MeasureRef)</code></pre><p>Extend <a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z &gt;= 0.0
 measure(g(t)) == 0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]

julia&gt; delete(model, meas)

julia&gt; print(model)
Min z
Subject to
 z &gt;= 0.0
 0 == 0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL407-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,ParameterRef}" href="#JuMP.delete-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, pref::ParameterRef)</code></pre><p>Extend <a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> to delete infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on <code>pref</code> are updated to exclude it. Errors if the parameter is contained in an <code>AbstractMeasureData</code> datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that <code>_check_param_in_data(pref, measure_data)</code> needs to be extended to allow deletion of parameters when custom <code>AbstractMeasureData</code> datatypes are used.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t, x)*t + x) + z
Subject to
 z &gt;= 0.0
 g(t, x) + z &gt;= 42.0
 g(0.5, x) == 0
 t in [0, 6]
 x in [0, 1]

julia&gt; delete(model, x)

julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 z &gt;= 0.0
 t in [0, 6]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL390-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}" href="#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, vref::ReducedInfiniteVariableRef)</code></pre><p>Extend <a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> to delete reduced infinite variables and its dependencies. Errors if <code>vref</code> is invalid, meaning it has already been deleted or it belongs to another model.</p><p><strong>Example</strong> ``julia julia&gt; print(model) Min measure(g(0, t)<em>t + g(1, t)</em>t) + z Subject to  z &gt;= 0.0  g(0, t) + g(1, t) == 0  g(x, t) + z &gt;= 42.0  g(0.5, 0.5) == 0  t in [0, 6]  x in [0, 1]</p><p>julia&gt; delete(model, rvref1)</p><p>julia&gt; print(model) Min measure(t + g(1, t)*t) + z Subject to  z &gt;= 0.0  g(1, t) == 0  g(x, t) + z &gt;= 42.0  g(0.5, 0.5) == 0  t in [0, 6]  x in [0, 1] ```</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL473-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, vref::InfOptVariableRef)</code></pre><p>Extend <a href="#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a> to delete <code>InfiniteOpt</code> variables and their dependencies. Errors if variable is invalid, meaning it has already been deleted or it belongs to another model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]

julia&gt; delete(model, g)

julia&gt; print(model)
Min measure(t) + z
Subject to
 z &gt;= 0.0
 z &gt;= 42.0
 t in [0, 6]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL603-L629">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete_lower_bound(vref::InfOptVariableRef)</code></pre><p>Extend the <code>JuMP.delete_lower_bound</code> function to accomodate our new variable types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL156-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.delete_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.delete_upper_bound(vref::InfOptVariableRef)</code></pre><p>Extend the <code>JuMP.delete_upper_bound</code> function to accomodate our new variable types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL296-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.dual_status-Tuple{InfiniteModel}" href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.dual_status(model::InfiniteModel)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL21-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}" href="#JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.fix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.fix(vref::InfOptVariableRef, value::Number; force::Bool = false)</code></pre><p>Extend <a href="#JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.fix</code></a> to fix the value of an <code>InfiniteOpt</code> variable. Errors if variable has lower/upper bound unless <code>force = true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; fix(vref, 3)

julia&gt; fix_value(vref)
3.0

julia&gt; fix(vref2, 2, force = true)

julia&gt; fix_value(vref2)
2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL375-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.fix_index-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.fix_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.fix_index(vref::ReducedInfiniteVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.fix_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_index</code></a> to return the index of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors if <code>vref</code> is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; fix_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL268-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.fix_index(vref::InfOptVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.fix_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_index</code></a> to return the index of the fix constraint associated with <code>vref</code>. Errors if <code>vref</code> is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; fix_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL345-L356">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.fix_value(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of the original infinite variable of <code>vref</code>. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; fix_value(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL249-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.fix_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.fix_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.fix_value(vref::InfOptVariableRef)::Float64</code></pre><p>Extend <a href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of an <code>InfiniteOpt</code> variable. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; fix_value(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL326-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{ParameterRef}" href="#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.has_lower_bound(pref::ParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_lower_bound</code> function to accomodate infinite parameters. Return true if the set associated with <code>pref</code> has a defined lower bound or if a lower bound can be found.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_lower_bound(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL626-L638">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_lower_bound(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL91-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.has_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::InfOptVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether an <code>InfiniteOpt</code> variable has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_lower_bound(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL32-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{ParameterRef}" href="#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.has_upper_bound(pref::ParameterRef)::Bool</code></pre><p>Extend the <code>JuMP.has_upper_bound</code> function to accomodate infinite parameters. Return true if the set associated with <code>pref</code> has a defined upper bound or if a upper bound can be found.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_upper_bound(t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL707-L719">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_upper_bound(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL162-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.has_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::InfOptVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether an <code>InfiniteOpt</code> variable has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_upper_bound(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL172-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.has_values-Tuple{InfiniteModel}" href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">has_values(model::InfiniteModel)</code></pre><p>Return <code>true</code> if the solver has a primal solution available to query, otherwise return <code>false</code>. See also <a href="@ref"><code>value</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL44-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.index-Tuple{GeneralConstraintRef}" href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.index(cref::GeneralConstraintRef)::Int</code></pre><p>Extend <a href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a> to return the index of an <code>InfiniteOpt</code> constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; index(cref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL24-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.index-Tuple{GeneralVariableRef}" href="#JuMP.index-Tuple{GeneralVariableRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.index(v::GeneralVariableRef::Int</code></pre><p>Extent <a href="#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a> to return the index of a <code>InfiniteOpt</code> variable.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; index(vref)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL467-L477">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.integer_index-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.integer_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.integer_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.integer_index(vref::ReducedInfiniteVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.integer_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.integer_index</code></a> to return the index of the integer constraint associated with the original infinite variable of <code>vref</code>. Errors if <code>vref</code> is not integer.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; integer_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL390-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.integer_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.integer_index(vref::InfOptVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.integer_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.integer_index</code></a> to return the index of the integer constraint associated with <code>vref</code>. Errors if <code>vref</code> is not integer.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; integer_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL643-L654">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_binary(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_binary(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL321-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_binary(vref::InfOptVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_binary(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL512-L523">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_fixed(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_fixed(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL233-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_fixed-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_fixed-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_fixed(vref::InfOptVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_fixed(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL312-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_integer(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_integer(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL374-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_integer(vref::InfOptVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> variable is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_integer(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL629-L640">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, cref::GeneralConstraintRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> to return <code>Bool</code> whether an <code>InfiniteOpt</code> constraint reference is valid.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_valid(model, cref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL269-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, mref::MeasureRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> to return <code>Bool</code> whether <code>mref</code> is valid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL25-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, pref::ParameterRef)::Bool</code></pre><p>Extend the <a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> function to accomodate infinite parameters. Returns true if the <code>InfiniteModel</code> stored in <code>pref</code> matches <code>model</code> and if the parameter index is used by <code>model</code>. It returns false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_valid(model, t)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL501-L513">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> to accomodate reduced infinite variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_valid(model, vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL457-L467">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.is_valid-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, vref::InfOptVariableRef)::Bool</code></pre><p>Extend <a href="#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a> to accomodate <code>InfiniteOpt</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_valid(model, ivref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL729-L739">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.list_of_constraint_types-Tuple{InfiniteModel}" href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple)</code></pre><p>Extend <a href="#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a> to return a list of tuples that contain all the used combinations of function types and set types in the model.</p><pre><code class="language-julia">julia&gt; all_constraints(model)
5-element Array{Tuple{DataType,DataType},1}:
 (GlobalVariableRef, MathOptInterface.LessThan{Float64})
 (PointVariableRef, MathOptInterface.GreaterThan{Float64})
 (GlobalVariableRef, MathOptInterface.GreaterThan{Float64})
 (GlobalVariableRef, MathOptInterface.Integer)
 (InfiniteVariableRef, MathOptInterface.GreaterThan{Float64})</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL561-L576">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.lower_bound-Tuple{ParameterRef}" href="#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.lower_bound(pref::ParameterRef)::Number</code></pre><p>Extend the <code>JuMP.lower_bound</code> function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; lower_bound(t)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL655-L667">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.lower_bound(vref::ReducedInfiniteVariableRef::Float64</code></pre><p>Extend <a href="#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; lower_bound(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL107-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.lower_bound(vref::InfOptVariableRef)::Float64</code></pre><p>Extend <a href="#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of an <code>InfiniteOpt</code> variable. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; lower_bound(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL46-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.lower_bound_index-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.lower_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.lower_bound_index(vref::ReducedInfiniteVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.lower_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound_index</code></a> to return the index of the lower bound constraint associated with the original infinite variable of <code>vref</code>. Errors if <code>vref</code> does not have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; lower_bound_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL126-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.lower_bound_index(vref::InfOptVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.lower_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound_index</code></a> to return the index of the lower bound constraint associated with <code>vref</code>. Errors if <code>vref</code> does not have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; lower_bound_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL65-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.name-Tuple{GeneralConstraintRef}" href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.name(cref::GeneralConstraintRef)::String</code></pre><p>Extend <a href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a> to return the name of an <code>InfiniteOpt</code> constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; name(cref)
constr_name</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL302-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.name-Tuple{MeasureRef}" href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.name(mref::MeasureRef)::String</code></pre><p>Extend <a href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a> to return the name associated with a measure reference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL5-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.name-Tuple{ParameterRef}" href="#JuMP.name-Tuple{ParameterRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.name(pref::ParameterRef)::String</code></pre><p>Extend the <code>JuMP.name</code> function to accomodate infinite parameters. Returns the name string associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; name(t)
&quot;t&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL520-L531">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.name-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.name(vref::ReducedInfiniteVariableRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return name of reduced infinite variable references. This is used when displaying measure expansions that contain such variables.</p><p><strong>Exanple</strong></p><pre><code class="language-julia">julia&gt; name(rvref)
g(1.25, x)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL60-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.name-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.name-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.name(vref::InfOptVariableRef)::String</code></pre><p>Extend <a href="#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a> to return the names of <code>InfiniteOpt</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; name(vref)
&quot;var_name&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL762-L772">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar},
                     set_type::Type{&lt;:MOI.AbstractSet})::Int</code></pre><p>Extend <a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to return the number of constraints with a partiuclar function type and set type.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; num_constraints(model, GlobalVariableRef, MOI.LessThan)
1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL389-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:JuMP.AbstractJuMPScalar}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:JuMP.AbstractJuMPScalar}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:JuMP.AbstractJuMPScalar})::Int</code></pre><p>Extend <a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to search by function types for all MOI sets and return the total number of constraints with a particular function type.</p><pre><code class="language-julia">julia&gt; num_constraints(model, GlobalVariableRef)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL415-L426">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:MathOptInterface.AbstractSet}" href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel,
                     function_type::Type{&lt;:MOI.AbstractSet})::Int</code></pre><p>Extend <a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to search by MOI set type for all function types and return the total number of constraints that use a particular MOI set type.</p><pre><code class="language-julia">julia&gt; num_constraints(model, MOI.LessThan)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL432-L444">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.num_constraints-Tuple{InfiniteModel}" href="#JuMP.num_constraints-Tuple{InfiniteModel}"><code>JuMP.num_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.num_constraints(model::InfiniteModel)::Int</code></pre><p>Extend <a href="#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49&lt;:JuMP.AbstractJuMPScalar,Type{#s48} where #s48&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a> to return the total number of constraints in an infinite model <code>model</code>.</p><pre><code class="language-julia">julia&gt; num_constraints(model)
4</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL450-L460">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.num_variables-Tuple{InfiniteModel}" href="#JuMP.num_variables-Tuple{InfiniteModel}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.num_variables(model::InfiniteModel)::Int</code></pre><p>Extend <a href="#JuMP.num_variables-Tuple{InfiniteModel}"><code>JuMP.num_variables</code></a> to return the number of <code>InfiniteOpt</code> variables assigned to <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; num_variables(model)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL744-L755">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.objective_bound-Tuple{InfiniteModel}" href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.objective_bound(model::InfiniteModel)::Float64</code></pre><p>Return the best known bound on the optimal objective value after a call to <code>optimize!(model)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL52-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.objective_function-Tuple{InfiniteModel}" href="#JuMP.objective_function-Tuple{InfiniteModel}"><code>JuMP.objective_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.objective_function(model::InfiniteModel)::JuMP.AbstractJuMPScalar</code></pre><p>Extend <a href="#JuMP.objective_function-Tuple{InfiniteModel}"><code>JuMP.objective_function</code></a> to return the objective of infinite model <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; objective_function(model)
x + measure(g(t))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL156-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.objective_function_type-Tuple{InfiniteModel}" href="#JuMP.objective_function_type-Tuple{InfiniteModel}"><code>JuMP.objective_function_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.objective_function_type(model::InfiniteModel)::Type{&lt;:JuMP.AbstractJuMPScalar}</code></pre><p>Extend <a href="#JuMP.objective_function_type-Tuple{InfiniteModel}"><code>JuMP.objective_function_type</code></a> to return the objective function type of infinite model <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; objective_function_type(model)
GenericAffExpr{Float64, FiniteVariableRef}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL140-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.objective_sense-Tuple{InfiniteModel}" href="#JuMP.objective_sense-Tuple{InfiniteModel}"><code>JuMP.objective_sense</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.objective_sense(model::InfiniteModel)::MOI.OptimizationSense</code></pre><p>Extend <a href="#JuMP.objective_sense-Tuple{InfiniteModel}"><code>JuMP.objective_sense</code></a> to return the objective sense of the infinite model <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; objective_sense(model)
MIN_SENSE::OptimizationSense = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL124-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.objective_value-Tuple{InfiniteModel}" href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.objective_value(model::InfiniteModel)::Float64</code></pre><p>Return the objective value after a call to <code>optimize!(model)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL62-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.optimize!" href="#JuMP.optimize!"><code>JuMP.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">JuMP.optimize!(model::InfiniteModel,
               optimizer_factory::Union{Nothing, OptimizerFactory} = nothing;
               bridge_constraints::Bool=true, kwargs...)</code></pre><p>Extend <a href="#JuMP.optimize!"><code>JuMP.optimize!</code></a> to optimize infinite models using the internal optimizer model. Will call <a href="#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> if the optimizer model isn&#39;t up to date. The <code>kwargs</code> correspond to keyword arguments passed to <a href="#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> if any are defined.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; optimize!(model, with_optimizer(Clp.Optimizer))

julia&gt; has_values(model)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL222-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.owner_model-Tuple{GeneralConstraintRef}" href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.owner_model(cref::GeneralConstraintRef)::InfiniteModel</code></pre><p>Extend <a href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a> to return the infinite model associated with <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; model = owner_model(cref)
An InfiniteOpt Model
Minimization problem with:
Variables: 3
Objective function type: GlobalVariableRef
`GenericAffExpr{Float64,FiniteVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
Names registered in the model: g, t, h, x
Optimizer model backend information:
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL1-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.owner_model-Tuple{GeneralVariableRef}" href="#JuMP.owner_model-Tuple{GeneralVariableRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.owner_model(vref::GeneralVariableRef)::InfiniteModel</code></pre><p>Extend <a href="#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a> function for <code>InfiniteOpt</code> variables. Returns the infinite model associated with <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; owner_model(vref)
An InfiniteOpt Model
Feasibility problem with:
Variable: 1
`GlobalVariableRef`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint
`GlobalVariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
`GlobalVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint
Names registered in the model: vref
Optimizer model backend information:
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL443-L464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.primal_status-Tuple{InfiniteModel}" href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia"> JuMP.primal_status(model::InfiniteModel)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL11-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_binary(vref::InfOptVariableRef)</code></pre><p>Extend <a href="#JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a> to specify an <code>InfiniteOpt</code> variable as a binary variable. Errors if <code>vref</code> is an integer variable.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_binary(vref)

julia&gt; is_binary(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL556-L569">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}" href="#JuMP.set_binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_binary_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_binary_index(vref::InfOptVariableRef, cindex::Int)</code></pre><p>Extend <a href="#JuMP.set_binary_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_binary_index</code></a> to specify the index of the binary constraint associated with <code>vref</code>. This is intended as an internal function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL545-L550">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}" href="#JuMP.set_fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_fix_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_fix_index(vref::InfOptVariableRef, cindex::Int)</code></pre><p>Extend <a href="#JuMP.set_fix_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_fix_index</code></a> to set the index of the fix constraint associated with <code>vref</code>. This is intended as an internal function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL364-L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_integer(vref::InfOptVariableRef)</code></pre><p>Extend <a href="#JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a> to specify an <code>InfiniteOpt</code> variable as a integer variable. Errors if <code>vref</code> is an binary variable.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_integery(vref)

julia&gt; is_integer(vref)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL673-L686">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}" href="#JuMP.set_integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_integer_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_integer_index(vref::InfOptVariableRef, cindex::Int)</code></pre><p>Extend <a href="#JuMP.set_integer_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_integer_index</code></a> to specify the index of the integer constraint associated with <code>vref</code>. This is intended as an internal function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL662-L667">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{ParameterRef,Number}" href="#JuMP.set_lower_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_lower_bound(pref::ParameterRef, lower::Number)</code></pre><p>Extend the <code>JuMP.set_lower_bound</code> function to accomodate infinite parameters. Updates the infinite set lower bound if and only if it is an IntervalSet. Errors otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_lower_bound(t, -1)

julia&gt; lower_bound(t)
-1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL680-L694">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}" href="#JuMP.set_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_lower_bound(vref::InfOptVariableRef, lower::Number)</code></pre><p>Extend <a href="#JuMP.set_lower_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_lower_bound</code></a> to specify the lower bound of an <code>InfiniteOpt</code> variable <code>vref</code>. Errors if <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_lower_bound(vref, -1)

julia&gt; lower_bound(vref)
-1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL95-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}" href="#JuMP.set_lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_lower_bound_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_lower_bound_index(vref::InfOptVariableRef, cindex::Int)</code></pre><p>Extend <a href="#JuMP.set_lower_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_lower_bound_index</code></a> to specify the index <code>cindex</code> of a lower bound constraint for <code>vref</code>. This is intended as an internal function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL84-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{GeneralConstraintRef,String}" href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_name(cref::GeneralConstraintRef, name::String)</code></pre><p>Extend <a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> to specify the name of a constraint <code>cref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_name(cref, &quot;new_name&quot;)

julia&gt; name(cref)
new_name</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/constraints.jl#LL317-L329">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{GlobalVariableRef,String}" href="#JuMP.set_name-Tuple{GlobalVariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_name(vref::GlobalVariableRef, name::String)</code></pre><p>Extend <a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> to set names of global variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_name(gvref, &quot;var_name&quot;)

julia&gt; name(t)
&quot;var_name&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL777-L789">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{InfiniteVariableRef,String}" href="#JuMP.set_name-Tuple{InfiniteVariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_name(vref::InfiniteVariableRef, root_name::String)</code></pre><p>Extend <a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> to set names of infinite variables. Adds on to <code>root_name</code> the ending <code>(prefs...)</code> where the parameter reference names are listed in the same format as input in the parameter reference tuple.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; name(vref)
old_name(t, x)

julia&gt; set_name(vref, &quot;new_name&quot;)

julia&gt; name(vref)
new_name(t, x)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL954-L971">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{MeasureRef,String}" href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_name(mref::MeasureRef, name::String)</code></pre><p>Extend <a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> to specify the name of a measure reference.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/measures.jl#LL15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{ParameterRef,String}" href="#JuMP.set_name-Tuple{ParameterRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_name(pref::ParameterRef, name::String)</code></pre><p>Extend the <code>JuMP.set_name</code> function to accomodate infinite parameters. Set a new base name to be associated with <code>pref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_name(t, &quot;time&quot;)

julia&gt; name(t)
&quot;time&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL536-L549">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{PointVariableRef,String}" href="#JuMP.set_name-Tuple{PointVariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_name(vref::PointVariableRef, name::String)</code></pre><p>Extend <a href="#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a> to set the names of point variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; name(vref)
old_name

julia&gt; set_name(vref, &quot;new_name&quot;)

julia&gt; name(vref)
new_name</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL841-L856">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}" href="#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}"><code>JuMP.set_objective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_objective(model::InfiniteModel, sense::MOI.OptimizationSense,
                   func::Union{JuMP.AbstractJuMPScalar, Real})</code></pre><p>Extend <a href="#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}"><code>JuMP.set_objective</code></a> to set the objective of infinite model <code>model</code>. Errors if <code>func</code> contains infinite variables and/or parameters, or if it does not belong to the model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_objective(model, MOI.MIN_SENSE, x + measure(g + 2, tdata))

julia&gt; objective_function(model)
x + measure(g(t) + 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL95-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_objective_function-Tuple{InfiniteModel,JuMP.AbstractJuMPScalar}" href="#JuMP.set_objective_function-Tuple{InfiniteModel,JuMP.AbstractJuMPScalar}"><code>JuMP.set_objective_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_objective_function(model::InfiniteModel,
                            func::JuMP.AbstractJuMPScalar)</code></pre><p>Extend <a href="#JuMP.set_objective_function-Tuple{InfiniteModel,JuMP.AbstractJuMPScalar}"><code>JuMP.set_objective_function</code></a> to set the objective expression of infinite model <code>model</code>. Errors if <code>func</code> contains infinite variables and/or parameters. Also errors if <code>func</code> contains invalid variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_objective_function(model, x + measure(g + 2, tdata))

julia&gt; objective_function(model)
x + measure(g(t) + 2)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_objective_function-Tuple{InfiniteModel,Real}" href="#JuMP.set_objective_function-Tuple{InfiniteModel,Real}"><code>JuMP.set_objective_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_objective_function(model::InfiniteModel, func::Real)</code></pre><p>Extend <a href="#JuMP.set_objective_function-Tuple{InfiniteModel,JuMP.AbstractJuMPScalar}"><code>JuMP.set_objective_function</code></a> to set the objective expression of <code>model</code> with a number.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_objective_function(model, 3)

julia&gt; objective_function(model)
3</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL46-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}" href="#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}"><code>JuMP.set_objective_sense</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_objective_sense(model::InfiniteModel, sense::MOI.OptimizationSense)</code></pre><p>Extend <a href="#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}"><code>JuMP.set_objective_sense</code></a> to set the objective sense of infinite model <code>model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_objective_sense(model, MOI.MIN_SENSE)

julia&gt; objective_sense(model)
MIN_SENSE::OptimizationSense = 0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/objective.jl#LL74-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_optimizer-Tuple{InfiniteModel,JuMP.OptimizerFactory}" href="#JuMP.set_optimizer-Tuple{InfiniteModel,JuMP.OptimizerFactory}"><code>JuMP.set_optimizer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_optimizer(model::InfiniteModel,
                   optimizer_factory::JuMP.OptimizerFactory;
                   bridge_constraints::Bool=true)</code></pre><p>Extend <a href="#JuMP.set_optimizer-Tuple{InfiniteModel,JuMP.OptimizerFactory}"><code>JuMP.set_optimizer</code></a> to set optimizer of infinite models. Specifically, the optimizer of the optimizer model is modified.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_optimizer(model, with_optimizer(Clp.Optimizer))

julia&gt; optimizer_model(model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: EMPTY_OPTIMIZER
Solver name: SolverName() attribute not implemented by the optimizer.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/optimize.jl#LL109-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}" href="#JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_start_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_start_value(vref::InfOptVariableRef, value::Number)</code></pre><p>Extend <a href="#JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_start_value</code></a> to specify the start value of <code>InfiniteOpt</code> variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_start_value(vref, 1)

julia&gt; start_value(vref)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL486-L499">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{ParameterRef,Number}" href="#JuMP.set_upper_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_upper_bound(pref::ParameterRef, lower::Number)</code></pre><p>Extend the <code>JuMP.set_upper_bound</code> function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_upper_bound(t, 2)

julia&gt; upper_bound(t)
2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL761-L775">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}" href="#JuMP.set_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_upper_bound(vref::InfOptVariableRef, upper::Number)</code></pre><p>Extend <a href="#JuMP.set_upper_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_upper_bound</code></a> to specify the upper bound of an <code>InfiniteOpt</code> variable <code>vref</code>. Errors if <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; set_upper_bound(vref, 1)

julia&gt; upper_bound(vref)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL235-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}" href="#JuMP.set_upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_upper_bound_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.set_upper_bound_index(vref::InfOptVariableRef, cindex::Int)</code></pre><p>Extend <a href="#JuMP.set_upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Int64}"><code>JuMP.set_upper_bound_index</code></a> to specify the index <code>cindex</code> of a upper bound constraint for <code>vref</code>. This is intended as an internal function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL224-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.start_value-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.start_value(vref::ReducedInfiniteVariableRef)::Union{Nothing, Float64}</code></pre><p>Extend <a href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a> to return starting value of the original infinite variable of <code>vref</code> if it has one. Returns <code>nothing</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; start_value(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL305-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.start_value(vref::InfOptVariableRef)::Union{Nothing, Float64}</code></pre><p>Extend <a href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a> to return starting value of <code>InfiniteOpt</code> variable if it has one. Returns <code>nothing</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; start_value(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL470-L481">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.termination_status-Tuple{InfiniteModel}" href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.termination_status(model::InfiniteModel)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.unfix(vref::InfOptVariableRef)</code></pre><p>Extend <code>JuMP.unfix</code> function to accomodate our new variable types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL454-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.unset_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unset_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.unset_binary(vref::InfOptVariableRef)</code></pre><p>Extend the <code>JuMP.unset_binary</code> function to accomodate our new variable types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL613-L616">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.unset_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.unset_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.unset_integer(vref::InfOptVariableRef)</code></pre><p>Extend the <code>JuMP.unset_integer</code> function to accomodate our new variable types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL731-L734">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.upper_bound-Tuple{ParameterRef}" href="#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.upper_bound(pref::ParameterRef)::Number</code></pre><p>Extend the <code>JuMP.upper_bound</code> function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; upper_bound(t)
1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/parameters.jl#LL736-L748">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.upper_bound(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; upper_bound(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL178-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.upper_bound(vref::InfOptVariableRef)::Float64</code></pre><p>Extend <a href="#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of an <code>InfiniteOpt</code> variable. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; upper_bound(vref)
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL186-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.upper_bound_index-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.upper_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.upper_bound_index(vref::ReducedInfiniteVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.upper_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound_index</code></a> to return the index of the upper bound constraint associated with the original infinite variable of <code>vref</code>. Errors if <code>vref</code> does not have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; upper_bound_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/reduced_variables.jl#LL197-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}" href="#JuMP.upper_bound_index-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.upper_bound_index(vref::InfOptVariableRef)::Int</code></pre><p>Extend <a href="#JuMP.upper_bound_index-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound_index</code></a> to return the index of the upper bound constraint associated with <code>vref</code>. Errors if <code>vref</code> does not have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; upper_bound_index(vref)
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variable_info.jl#LL205-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.value-Tuple{GeneralVariableRef}" href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.value(vref::GeneralVariableRef)</code></pre><p>Get the value of this variable in the result returned by a solver. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/results.jl#LL79-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.variable_by_name-Tuple{InfiniteModel,String}" href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">JuMP.variable_by_name(model::InfiniteModel,
                      name::String)::Union{GeneralVariableRef, Nothing}</code></pre><p>Extend <a href="#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a> for <code>InfiniteModel</code> objects. Return the varaible reference assoociated with a variable name. Errors if multiple variables have the same name. Returns nothing if no such name exists.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; variable_by_name(m, &quot;var_name&quot;)
var_name

julia&gt; variable_by_name(m, &quot;fake_name&quot;)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/767446535975c4bc91cefe62fdd1adda948db38e/src/variables.jl#LL1004-L1020">source</a></section><footer><hr/></footer></article></body></html>
