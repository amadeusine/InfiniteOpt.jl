<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JuMP Docs · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../guide/install/">Installation</a></li><li><a class="tocitem" href="../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../guide/variable/">Variables</a></li><li><a class="tocitem" href="../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../guide/measure/">Measures</a></li><li><a class="tocitem" href="../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../guide/result/">Results</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li><li><a class="tocitem" href="../develop/">Development</a></li><li><a class="tocitem" href="../library/">Library</a></li><li class="is-active"><a class="tocitem" href>JuMP Docs</a><ul class="internal"><li><a class="tocitem" href="#Model-1"><span>Model</span></a></li><li><a class="tocitem" href="#Variables-1"><span>Variables</span></a></li><li><a class="tocitem" href="#Expressions-1"><span>Expressions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>JuMP Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JuMP Docs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/JuMP.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JuMP-Documentation-1"><a class="docs-heading-anchor" href="#JuMP-Documentation-1">JuMP Documentation</a><a class="docs-heading-anchor-permalink" href="#JuMP-Documentation-1" title="Permalink"></a></h1><h2 id="Model-1"><a class="docs-heading-anchor" href="#Model-1">Model</a><a class="docs-heading-anchor-permalink" href="#Model-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.Model" href="#JuMP.Model"><code>JuMP.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Model</code></pre><p>A mathematical model of an optimization problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.Model-Tuple{}" href="#JuMP.Model-Tuple{}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
        bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the <code>CachingOptimizer</code> storing this cache is <code>caching_mode</code>. The optimizer can be set later in the <a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> call. If <code>bridge_constraints</code> is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the <code>MathOptInterface.Bridges</code> module or is defined in another module and is explicitely added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.Model-Tuple{OptimizerFactory}" href="#JuMP.Model-Tuple{OptimizerFactory}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Model(optimizer_factory::OptimizerFactory;
      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
      bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model using the optimizer factory <code>optimizer_factory</code> to create the optimizer. The optimizer factory can be created by the <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a> function.</p><p><strong>Examples</strong></p><p>The following creates a model using the optimizer <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">model = Model(with_optimizer(Ipopt.Optimizer, print_level=0))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.with_optimizer" href="#JuMP.with_optimizer"><code>JuMP.with_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">with_optimizer(constructor, args...; kwargs...)</code></pre><p>Return an <code>OptimizerFactory</code> that creates optimizers using the constructor <code>constructor</code> with positional arguments <code>args</code> and keyword arguments <code>kwargs</code>.</p><p><strong>Examples</strong></p><p>The following returns an optimizer factory that creates <code>Ipopt.Optimizer</code>s using the constructor call <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">with_optimizer(Ipopt.Optimizer, print_level=0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.NoOptimizer" href="#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NoOptimizer &lt;: Exception end</code></pre><p>No optimizer is set. The optimizer can be provided at the <a href="#JuMP.Model"><code>Model</code></a> constructor or at the <a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> call with <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a>.</p></div></section></article><h2 id="Variables-1"><a class="docs-heading-anchor" href="#Variables-1">Variables</a><a class="docs-heading-anchor-permalink" href="#Variables-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_variable" href="#JuMP.add_variable"><code>JuMP.add_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_variable(m::Model, v::AbstractVariable, name::String=&quot;&quot;)</code></pre><p>Add a variable <code>v</code> to <code>Model m</code> and sets its name.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.@variable" href="#JuMP.@variable"><code>JuMP.@variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable.</p><pre><code class="language-none">@variable(model, expr, args..., kw_args...)</code></pre><p>Add a variable to the model <code>model</code> described by the expression <code>expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>expr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>)</p><ul><li>of the form <code>varexpr</code> creating variables described by <code>varexpr</code>;</li><li>of the form <code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>);</li><li>of the form <code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values given by <code>value</code>; or</li><li>of the form <code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code>.</li></ul><p>The expression <code>varexpr</code> can either be</p><ul><li>of the form <code>varname</code> creating a scalar real variable of name <code>varname</code>;</li><li>of the form <code>varname[...]</code> or <code>[...]</code> creating a container of variables (see <a href="@ref">Containers in macros</a>).</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li><li><code>Symmetric</code>: Only available when creating a square matrix of variables, i.e. when <code>varexpr</code> is of the form <code>varname[1:n,1:n]</code> or <code>varname[i=1:n,j=1:n]</code>. It creates a symmetric matrix of variable, that is, it only creates a new variable for <code>varname[i,j]</code> with <code>i ≤ j</code> and sets <code>varname[j,i]</code> to the same variable as <code>varname[i,j]</code>.</li><li><code>PSD</code>: The square matrix of variable is both <code>Symmetric</code> and constrained to be positive semidefinite.</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>variable_type</code>: See the &quot;Note for extending the variable macro&quot; section below.</li><li><code>container</code>: Specify the container type, see <a href="@ref">Containers in macros</a>.</li></ul><p><strong>Examples</strong></p><p>The following are equivalent ways of creating a variable <code>x</code> of name <code>x</code> with lower bound 0:</p><pre><code class="language-julia"># Specify everything in `expr`
@variable(model, x &gt;= 0)
# Specify the lower bound using a keyword argument
@variable(model, x, lower_bound=0)
# Specify everything in `kw_args`
x = @variable(model, base_name=&quot;x&quot;, lower_bound=0)</code></pre><p>The following are equivalent ways of creating a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code>.</p><pre><code class="language-julia">ub = Dict(:a =&gt; 2, :b =&gt; 3)
# Specify everything in `expr`
@variable(model, x[i=keys(ub)] &lt;= ub[i])
# Specify the upper bound using a keyword argument
@variable(model, x[i=keys(ub)], upper_bound=ub[i])</code></pre><p><strong>Note for extending the variable macro</strong></p><p>The single scalar variable or each scalar variable of the container are created using <code>add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...))</code> where</p><ul><li><code>model</code> is the model passed to the <code>@variable</code> macro;</li><li><code>_error</code> is an error function with a single <code>String</code> argument showing the <code>@variable</code> call in addition to the error message given as argument;</li><li><code>info</code> is the <code>VariableInfo</code> struct containing the information gathered in <code>expr</code>, the recognized keyword arguments (except <code>base_name</code> and <code>variable_type</code>) and the recognized positional arguments (except <code>Symmetric</code> and <code>PSD</code>);</li><li><code>extra_args</code> are the unrecognized positional arguments of <code>args</code> plus the value of the <code>variable_type</code> keyword argument if present. The <code>variable_type</code> keyword argument allows the user to pass a position argument to <code>build_variable</code> without the need to give a positional argument to <code>@variable</code>. In particular, this allows the user to give a positional argument to the <code>build_variable</code> call when using the anonymous single variable syntax <code>@variable(model, kw_args...)</code>; and</li><li><code>extra_kw_args</code> are the unrecognized keyword argument of <code>kw_args</code>.</li></ul><p><strong>Examples</strong></p><p>The following creates a variable <code>x</code> of name <code>x</code> with <code>lower_bound</code> 0 as with the first example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia">info = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)
JuMP.add_variable(model, JuMP.build_variable(error, info), &quot;x&quot;)</code></pre><p>The following creates a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code> as with the second example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia"># Without the `@variable` macro
data = Vector{JuMP.variable_type(model)}(undef, length(keys(ub)))
x = JuMP.Containers.DenseAxisArray(data, keys(ub))
for i in keys(ub)
    info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)
    x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), &quot;x[$i]&quot;)
end</code></pre><p>The following are equivalent ways of creating a <code>Matrix</code> of size <code>N x N</code> with variables custom variables created with a JuMP extension using the <code>Poly(X)</code> positional argument to specify its variables:</p><pre><code class="language-julia"># Using the `@variable` macro
@variable(model, x[1:N,1:N], Symmetric, Poly(X))
# Without the `@variable` macro
x = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)
info = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)
for i in 1:N, j in i:N
    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), &quot;x[$i,$j]&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{Model,VariableRef}" href="#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(model::Model, variable_ref::VariableRef)</code></pre><p>Delete the variable associated with <code>variable_ref</code> from the model <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{Model,VariableRef}" href="#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_valid(model::Model, variable_ref::VariableRef)</code></pre><p>Return <code>true</code> if <code>variable</code> refers to a valid variable in <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{VariableRef,String}" href="#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name(v::VariableRef, s::AbstractString)</code></pre><p>Set a variable&#39;s name attribute.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.owner_model-Tuple{AbstractVariableRef}" href="#JuMP.owner_model-Tuple{AbstractVariableRef}"><code>JuMP.owner_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">owner_model(v::AbstractVariableRef)</code></pre><p>Returns the model to which <code>v</code> belongs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; model = Model()

julia&gt; x = @variable(model)

julia&gt; owner_model(x) === model
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.index-Tuple{VariableRef}" href="#JuMP.index-Tuple{VariableRef}"><code>JuMP.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index(v::VariableRef)::MOI.VariableIndex</code></pre><p>Return the index of the variable that corresponds to <code>v</code> in the MOI backend.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.num_variables-Tuple{Model}" href="#JuMP.num_variables-Tuple{Model}"><code>JuMP.num_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_variables(model::Model)::Int64</code></pre><p>Returns number of variables in <code>model</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{VariableRef}" href="#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">name(v::VariableRef)::String</code></pre><p>Get a variable&#39;s name attribute.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.variable_by_name-Tuple{Model,String}" href="#JuMP.variable_by_name-Tuple{Model,String}"><code>JuMP.variable_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">variable_by_name(model::AbstractModel,
                 name::String)::Union{AbstractVariableRef, Nothing}</code></pre><p>Returns the reference of the variable with name attribute <code>name</code> or <code>Nothing</code> if no variable has this name attribute. Throws an error if several variables have <code>name</code> as their name attribute.</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; variable_by_name(model, &quot;x&quot;)
x

julia&gt; @variable(model, base_name=&quot;x&quot;)
x

julia&gt; variable_by_name(model, &quot;x&quot;)
ERROR: Multiple variables have the name x.
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222
 [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]
 [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490
 [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268
 [6] top-level scope at none:0

julia&gt; var = @variable(model, base_name=&quot;y&quot;)
y

julia&gt; variable_by_name(model, &quot;y&quot;)
y

julia&gt; set_name(var, &quot;z&quot;)

julia&gt; variable_by_name(model, &quot;y&quot;)

julia&gt; variable_by_name(model, &quot;z&quot;)
z

julia&gt; @variable(model, u[1:2])
2-element Array{VariableRef,1}:
 u[1]
 u[2]

julia&gt; variable_by_name(model, &quot;u[2]&quot;)
u[2]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.all_variables-Tuple{Model}" href="#JuMP.all_variables-Tuple{Model}"><code>JuMP.all_variables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all_variables(model::Model)::Vector{VariableRef}</code></pre><p>Returns a list of all variables currently in the model. The variables are ordered by creation time.</p><p><strong>Example</strong></p><pre><code class="language-julia">model = Model()
@variable(model, x)
@variable(model, y)
all_variables(model)

# output

2-element Array{VariableRef,1}:
 x
 y</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{VariableRef}" href="#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_lower_bound(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> has a lower bound. If <code>true</code>, the lower bound can be queried with <a href="#JuMP.lower_bound-Tuple{VariableRef}"><code>lower_bound</code></a>. See also <a href="#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>LowerBoundRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{VariableRef}" href="#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lower_bound(v::VariableRef)</code></pre><p>Return the lower bound of a variable. Error if one does not exist. See also <a href="#JuMP.has_lower_bound-Tuple{VariableRef}"><code>has_lower_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_lower_bound-Tuple{VariableRef,Number}" href="#JuMP.set_lower_bound-Tuple{VariableRef,Number}"><code>JuMP.set_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_lower_bound(v::VariableRef, lower::Number)</code></pre><p>Set the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also <a href="#JuMP.delete_lower_bound-Tuple{VariableRef}"><code>delete_lower_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{VariableRef}" href="#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LowerBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the lower bound constraint of <code>v</code>. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_lower_bound-Tuple{VariableRef}" href="#JuMP.delete_lower_bound-Tuple{VariableRef}"><code>JuMP.delete_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_lower_bound(v::VariableRef)</code></pre><p>Delete the lower bound constraint of a variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{VariableRef}" href="#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_upper_bound(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> has a upper bound. If <code>true</code>, the upper bound can be queried with <a href="#JuMP.upper_bound-Tuple{VariableRef}"><code>upper_bound</code></a>. See also <a href="#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>UpperBoundRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{VariableRef}" href="#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">upper_bound(v::VariableRef)</code></pre><p>Return the upper bound of a variable. Error if one does not exist. See also <a href="#JuMP.has_upper_bound-Tuple{VariableRef}"><code>has_upper_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_upper_bound-Tuple{VariableRef,Number}" href="#JuMP.set_upper_bound-Tuple{VariableRef,Number}"><code>JuMP.set_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_upper_bound(v::VariableRef,upper::Number)</code></pre><p>Set the upper bound of a variable. If one does not exist, create an upper bound constraint. See also <a href="#JuMP.delete_upper_bound-Tuple{VariableRef}"><code>delete_upper_bound</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{VariableRef}" href="#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UpperBoundRef(v::VariableRef)</code></pre><p>Return a constraint reference to the upper bound constraint of <code>v</code>. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete_upper_bound-Tuple{VariableRef}" href="#JuMP.delete_upper_bound-Tuple{VariableRef}"><code>JuMP.delete_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete_upper_bound(v::VariableRef)</code></pre><p>Delete the upper bound constraint of a variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{VariableRef}" href="#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_fixed(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is a fixed variable. If <code>true</code>, the fixed value can be queried with <a href="#JuMP.fix_value-Tuple{VariableRef}"><code>fix_value</code></a>. See also <a href="#JuMP.FixRef-Tuple{VariableRef}"><code>FixRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{VariableRef}" href="#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fix_value(v::VariableRef)</code></pre><p>Return the value to which a variable is fixed. Error if one does not exist. See also <a href="#JuMP.is_fixed-Tuple{VariableRef}"><code>is_fixed</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix-Tuple{VariableRef,Number}" href="#JuMP.fix-Tuple{VariableRef,Number}"><code>JuMP.fix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fix(v::VariableRef, value::Number; force::Bool = false)</code></pre><p>Fix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also <a href="#JuMP.unfix-Tuple{VariableRef}"><code>unfix</code></a>.</p><p>If the variable already has variable bounds and <code>force=false</code>, calling <code>fix</code> will throw an error. If <code>force=true</code>, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to <a href="#JuMP.unfix-Tuple{VariableRef}"><code>unfix</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{VariableRef}" href="#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FixRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint fixing the value of <code>v</code>. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unfix-Tuple{VariableRef}" href="#JuMP.unfix-Tuple{VariableRef}"><code>JuMP.unfix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unfix(v::VariableRef)</code></pre><p>Delete the fixing constraint of a variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.start_value-Tuple{VariableRef}" href="#JuMP.start_value-Tuple{VariableRef}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_value(v::VariableRef)</code></pre><p>Return the start value (MOI attribute <code>VariablePrimalStart</code>) of the variable <code>v</code>. See also <a href="#JuMP.set_start_value-Tuple{VariableRef,Number}"><code>set_start_value</code></a>.</p><p>Note: <code>VariablePrimalStart</code>s are sometimes called &quot;MIP-starts&quot; or &quot;warmstarts&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_start_value-Tuple{VariableRef,Number}" href="#JuMP.set_start_value-Tuple{VariableRef,Number}"><code>JuMP.set_start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value(variable::VariableRef, value::Number)</code></pre><p>Set the start value (MOI attribute <code>VariablePrimalStart</code>) of the variable <code>v</code> to <code>value</code>. See also <a href="#JuMP.start_value-Tuple{VariableRef}"><code>start_value</code></a>.</p><p>Note: <code>VariablePrimalStart</code>s are sometimes called &quot;MIP-starts&quot; or &quot;warmstarts&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{VariableRef}" href="#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_binary(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is constrained to be binary. See also <a href="#JuMP.BinaryRef-Tuple{VariableRef}"><code>BinaryRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_binary-Tuple{VariableRef}" href="#JuMP.set_binary-Tuple{VariableRef}"><code>JuMP.set_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_binary(v::VariableRef)</code></pre><p>Add a constraint on the variable <code>v</code> that it must take values in the set <span>$\{0,1\}$</span>. See also <a href="#JuMP.unset_binary-Tuple{VariableRef}"><code>unset_binary</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{VariableRef}" href="#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BinaryRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint constrainting <code>v</code> to be binary. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_binary-Tuple{VariableRef}" href="#JuMP.unset_binary-Tuple{VariableRef}"><code>JuMP.unset_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_binary(variable_ref::VariableRef)</code></pre><p>Remove the binary constraint on the variable <code>variable_ref</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{VariableRef}" href="#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_integer(v::VariableRef)</code></pre><p>Return <code>true</code> if <code>v</code> is constrained to be integer. See also <a href="#JuMP.IntegerRef-Tuple{VariableRef}"><code>IntegerRef</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_integer-Tuple{VariableRef}" href="#JuMP.set_integer-Tuple{VariableRef}"><code>JuMP.set_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_integer(variable_ref::VariableRef)</code></pre><p>Add an integrality constraint on the variable <code>variable_ref</code>. See also <a href="#JuMP.unset_integer-Tuple{VariableRef}"><code>unset_integer</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{VariableRef}" href="#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">IntegerRef(v::VariableRef)</code></pre><p>Return a constraint reference to the constraint constrainting <code>v</code> to be integer. Errors if one does not exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.unset_integer-Tuple{VariableRef}" href="#JuMP.unset_integer-Tuple{VariableRef}"><code>JuMP.unset_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unset_integer(variable_ref::VariableRef)</code></pre><p>Remove the integrality constraint on the variable <code>variable_ref</code>.</p></div></section></article><h2 id="Expressions-1"><a class="docs-heading-anchor" href="#Expressions-1">Expressions</a><a class="docs-heading-anchor-permalink" href="#Expressions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuMP.@expression" href="#JuMP.@expression"><code>JuMP.@expression</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@expression(args...)</code></pre><p>Efficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:</p><pre><code class="language-julia">@expression(m, shared, sum(i*x[i] for i=1:5))
@constraint(m, shared + y &gt;= 5)
@constraint(m, shared + z &lt;= 10)</code></pre><p>The <code>ref</code> accepts index sets in the same way as <code>@variable</code>, and those indices can be used in the construction of the expressions:</p><pre><code class="language-julia">@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))</code></pre><p>Anonymous syntax is also supported:</p><pre><code class="language-julia">expr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.add_to_expression!" href="#JuMP.add_to_expression!"><code>JuMP.add_to_expression!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_to_expression!(expression, terms...)</code></pre><p>Updates <code>expression</code> <em>in place</em> to <code>expression + (*)(terms...)</code>. This is typically much more efficient than <code>expression += (*)(terms...)</code>. For example, <code>add_to_expression!(expression, a, b)</code> produces the same result as <code>expression += a*b</code>, and <code>add_to_expression!(expression, a)</code> produces the same result as <code>expression += a</code>.</p><p>Only a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) <code>expression</code> is capable of storing the result. For example, <code>add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef)</code> is not defined because a <code>GenericAffExpr</code> cannot store the product of two variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.@objective" href="#JuMP.@objective"><code>JuMP.@objective</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@objective(model::Model, sense, func)</code></pre><p>Set the objective sense to <code>sense</code> and objective function to <code>func</code>. The objective sense can be either <code>Min</code>, <code>Max</code>, <code>MathOptInterface.MIN_SENSE</code>, <code>MathOptInterface.MAX_SENSE</code> or <code>MathOptInterface.FEASIBILITY_SENSE</code>; see <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.8/apireference.html#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a>. In order to set the sense programatically, i.e., when <code>sense</code> is a Julia variable whose value is the sense, one of the three <code>MathOptInterface.ObjectiveSense</code> values should be used. The function <code>func</code> can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.</p><p><strong>Examples</strong></p><p>To minimize the value of the variable <code>x</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @objective(model, Min, x)
x</code></pre><p>To maximize the value of the affine expression <code>2x - 1</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; @objective(model, Max, 2x - 1)
2 x - 1</code></pre><p>To set a quadratic objective and set the objective sense programatically, do as follows:</p><pre><code class="language-julia-repl">julia&gt; sense = MOI.MIN_SENSE
MIN_SENSE::OptimizationSense = 0

julia&gt; @objective(model, sense, x^2 - 2x + 1)
x² - 2 x + 1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.ScalarConstraint" href="#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ScalarConstraint</code></pre><p>The data for a scalar constraint. The <code>func</code> field containts a JuMP object representing the function and the <code>set</code> field contains the MOI set. See also the <a href="../guide/constraint/#Constraints-1">documentation</a> on JuMP&#39;s representation of constraints for more background.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.@constraint" href="#JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@constraint(m::Model, expr)</code></pre><p>Add a constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@constraint(m::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> can either be</p><ul><li>of the form <code>func in set</code> constraining the function <code>func</code> to belong to the set <code>set</code> which is either a <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1"><code>MathOptInterface.AbstractSet</code></a> or one of the JuMP shortcuts <a href="#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>, <a href="#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> and <a href="#JuMP.PSDCone"><code>PSDCone</code></a>, e.g. <code>@constraint(model, [1, x-1, y-2] in SecondOrderCone())</code> constrains the norm of <code>[x-1, y-2]</code> be less than 1;</li><li>of the form <code>a sign b</code>, where <code>sign</code> is one of <code>==</code>, <code>≥</code>, <code>&gt;=</code>, <code>≤</code> and <code>&lt;=</code> building the single constraint enforcing the comparison to hold for the expression <code>a</code> and <code>b</code>, e.g. <code>@constraint(m, x^2 + y^2 == 1)</code> constrains <code>x</code> and <code>y</code> to lie on the unit circle;</li><li>of the form <code>a ≤ b ≤ c</code> or <code>a ≥ b ≥ c</code> (where <code>≤</code> and <code>&lt;=</code> (resp. <code>≥</code> and <code>&gt;=</code>) can be used interchangeably) constraining the paired the expression <code>b</code> to lie between <code>a</code> and <code>c</code>;</li><li>of the forms <code>@constraint(m, a .sign b)</code> or <code>@constraint(m, a .sign b .sign c)</code> which broadcast the constraint creation to each element of the vectors.</li></ul><p><strong>Note for extending the constraint macro</strong></p><p>Each constraint will be created using <code>add_constraint(m, build_constraint(_error, func, set))</code> where</p><ul><li><code>_error</code> is an error function showing the constraint call in addition to the error message given as argument,</li><li><code>func</code> is the expression that is constrained</li><li>and <code>set</code> is the set in which it is constrained to belong.</li></ul><p>For <code>expr</code> of the first type (i.e. <code>@constraint(m, func in set)</code>), <code>func</code> and <code>set</code> are passed unchanged to <code>build_constraint</code> but for the other types, they are determined from the expressions and signs. For instance, <code>@constraint(m, x^2 + y^2 == 1)</code> is transformed into <code>add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0)))</code>.</p><p>To extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to <code>build_constraint</code>. Note that this will likely mean that either <code>func</code> or <code>set</code> will be some custom type, rather than e.g. a <code>Symbol</code>, since we will likely want to dispatch on the type of the function or set appearing in the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.SecondOrderCone" href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SecondOrderCone</code></pre><p>Second order cone object that can be used to constrain the euclidean norm of a vector <code>x</code> to be less than or equal to a nonnegative scalar <code>t</code>. This is a shortcut for the <code>MathOptInterface.SecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le t$</span> and <span>$t \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x-1, x-2] in SecondOrderCone())
[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.RotatedSecondOrderCone" href="#JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RotatedSecondOrderCone</code></pre><p>Rotated second order cone object that can be used to constrain the square of the euclidean norm of a vector <code>x</code> to be less than or equal to <span>$2tu$</span> where <code>t</code> and <code>u</code> are nonnegative scalars. This is a shortcut for the <code>MathOptInterface.RotatedSecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le 2tx$</span> and <span>$t, x \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())
[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.PSDCone" href="#JuMP.PSDCone"><code>JuMP.PSDCone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSDCone</code></pre><p>Positive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. If the matrix has type <code>Symmetric</code> then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the <code>MOI.PositiveSemidefiniteConeTriangle</code> set, otherwise its column vectorization is constrained to belong to the <code>MOI.PositiveSemidefiniteConeSquare</code> set.</p><p><strong>Examples</strong></p><p>Consider the following example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [ x 2x
            2x  x];

julia&gt; b = [1 2
            2 4];

julia&gt; cref = @SDconstraint(model, a ⪰ b)
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
4-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>We see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra # For Symmetric

julia&gt; cref = @constraint(model, Symmetric(a - b) in PSDCone())
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
3-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeTriangle(2)</code></pre><p>As we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Library</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 December 2019 19:59">Friday 6 December 2019</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
