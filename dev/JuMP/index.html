<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JuMP Docs · InfiniteOpt.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="InfiniteOpt.jl logo"/></a><h1>InfiniteOpt.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../guide/install/">Installation</a></li><li><a class="toctext" href="../guide/model/">Infinite Models</a></li><li><a class="toctext" href="../guide/parameter/">Infinite Parameters</a></li><li><a class="toctext" href="../guide/finite_parameter/">Finite Parameters</a></li><li><a class="toctext" href="../guide/variable/">Variables</a></li><li><a class="toctext" href="../guide/expression/">Expressions</a></li><li><a class="toctext" href="../guide/measure/">Measures</a></li><li><a class="toctext" href="../guide/objective/">Objectives</a></li><li><a class="toctext" href="../guide/constraint/">Constraints</a></li><li><a class="toctext" href="../guide/transcribe/">Model Transcription</a></li><li><a class="toctext" href="../guide/optimize/">Optimization</a></li><li><a class="toctext" href="../guide/result/">Results</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../extensions/">Extensions</a></li><li><a class="toctext" href="../develop/">Development</a></li><li><a class="toctext" href="../library/">Library</a></li><li class="current"><a class="toctext" href>JuMP Docs</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>JuMP Docs</a></li></ul><a class="edit-page" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/JuMP.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>JuMP Docs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="JuMP-Documentation-1" href="#JuMP-Documentation-1">JuMP Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.Model" href="#JuMP.Model"><code>JuMP.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Model</code></pre><p>A mathematical model of an optimization problem.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.Model-Tuple{}" href="#JuMP.Model-Tuple{}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
        bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the <code>CachingOptimizer</code> storing this cache is <code>caching_mode</code>. The optimizer can be set later in the <a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> call. If <code>bridge_constraints</code> is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the <code>MathOptInterface.Bridges</code> module or is defined in another module and is explicitely added.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.Model-Tuple{OptimizerFactory}" href="#JuMP.Model-Tuple{OptimizerFactory}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(optimizer_factory::OptimizerFactory;
      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
      bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model using the optimizer factory <code>optimizer_factory</code> to create the optimizer. The optimizer factory can be created by the <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a> function.</p><p><strong>Examples</strong></p><p>The following creates a model using the optimizer <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">model = Model(with_optimizer(Ipopt.Optimizer, print_level=0))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.with_optimizer" href="#JuMP.with_optimizer"><code>JuMP.with_optimizer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">with_optimizer(constructor, args...; kwargs...)</code></pre><p>Return an <code>OptimizerFactory</code> that creates optimizers using the constructor <code>constructor</code> with positional arguments <code>args</code> and keyword arguments <code>kwargs</code>.</p><p><strong>Examples</strong></p><p>The following returns an optimizer factory that creates <code>Ipopt.Optimizer</code>s using the constructor call <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">with_optimizer(Ipopt.Optimizer, print_level=0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.fix-Tuple{VariableRef,Number}" href="#JuMP.fix-Tuple{VariableRef,Number}"><code>JuMP.fix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fix(v::VariableRef, value::Number; force::Bool = false)</code></pre><p>Fix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also <a href="../guide/variable/#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unfix</code></a>.</p><p>If the variable already has variable bounds and <code>force=false</code>, calling <code>fix</code> will throw an error. If <code>force=true</code>, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to <a href="../guide/variable/#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>unfix</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@expression" href="#JuMP.@expression"><code>JuMP.@expression</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@expression(args...)</code></pre><p>Efficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:</p><pre><code class="language-julia">@expression(m, shared, sum(i*x[i] for i=1:5))
@constraint(m, shared + y &gt;= 5)
@constraint(m, shared + z &lt;= 10)</code></pre><p>The <code>ref</code> accepts index sets in the same way as <code>@variable</code>, and those indices can be used in the construction of the expressions:</p><pre><code class="language-julia">@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))</code></pre><p>Anonymous syntax is also supported:</p><pre><code class="language-julia">expr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.add_to_expression!" href="#JuMP.add_to_expression!"><code>JuMP.add_to_expression!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_to_expression!(expression, terms...)</code></pre><p>Updates <code>expression</code> <em>in place</em> to <code>expression + (*)(terms...)</code>. This is typically much more efficient than <code>expression += (*)(terms...)</code>. For example, <code>add_to_expression!(expression, a, b)</code> produces the same result as <code>expression += a*b</code>, and <code>add_to_expression!(expression, a)</code> produces the same result as <code>expression += a</code>.</p><p>Only a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) <code>expression</code> is capable of storing the result. For example, <code>add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef)</code> is not defined because a <code>GenericAffExpr</code> cannot store the product of two variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@objective" href="#JuMP.@objective"><code>JuMP.@objective</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@objective(model::Model, sense, func)</code></pre><p>Set the objective sense to <code>sense</code> and objective function to <code>func</code>. The objective sense can be either <code>Min</code>, <code>Max</code>, <code>MathOptInterface.MIN_SENSE</code>, <code>MathOptInterface.MAX_SENSE</code> or <code>MathOptInterface.FEASIBILITY_SENSE</code>; see <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.8/apireference.html#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a>. In order to set the sense programatically, i.e., when <code>sense</code> is a Julia variable whose value is the sense, one of the three <code>MathOptInterface.ObjectiveSense</code> values should be used. The function <code>func</code> can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.</p><p><strong>Examples</strong></p><p>To minimize the value of the variable <code>x</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @objective(model, Min, x)
x</code></pre><p>To maximize the value of the affine expression <code>2x - 1</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; @objective(model, Max, 2x - 1)
2 x - 1</code></pre><p>To set a quadratic objective and set the objective sense programatically, do as follows:</p><pre><code class="language-julia-repl">julia&gt; sense = MOI.MIN_SENSE
MIN_SENSE::OptimizationSense = 0

julia&gt; @objective(model, sense, x^2 - 2x + 1)
x² - 2 x + 1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.ScalarConstraint" href="#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ScalarConstraint</code></pre><p>The data for a scalar constraint. The <code>func</code> field containts a JuMP object representing the function and the <code>set</code> field contains the MOI set. See also the <a href="../guide/constraint/#Constraints-1">documentation</a> on JuMP&#39;s representation of constraints for more background.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@constraint" href="#JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@constraint(m::Model, expr)</code></pre><p>Add a constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@constraint(m::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> can either be</p><ul><li>of the form <code>func in set</code> constraining the function <code>func</code> to belong to the set <code>set</code> which is either a <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1"><code>MathOptInterface.AbstractSet</code></a> or one of the JuMP shortcuts <a href="#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>, <a href="#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> and <a href="#JuMP.PSDCone"><code>PSDCone</code></a>, e.g. <code>@constraint(model, [1, x-1, y-2] in SecondOrderCone())</code> constrains the norm of <code>[x-1, y-2]</code> be less than 1;</li><li>of the form <code>a sign b</code>, where <code>sign</code> is one of <code>==</code>, <code>≥</code>, <code>&gt;=</code>, <code>≤</code> and <code>&lt;=</code> building the single constraint enforcing the comparison to hold for the expression <code>a</code> and <code>b</code>, e.g. <code>@constraint(m, x^2 + y^2 == 1)</code> constrains <code>x</code> and <code>y</code> to lie on the unit circle;</li><li>of the form <code>a ≤ b ≤ c</code> or <code>a ≥ b ≥ c</code> (where <code>≤</code> and <code>&lt;=</code> (resp. <code>≥</code> and <code>&gt;=</code>) can be used interchangeably) constraining the paired the expression <code>b</code> to lie between <code>a</code> and <code>c</code>;</li><li>of the forms <code>@constraint(m, a .sign b)</code> or <code>@constraint(m, a .sign b .sign c)</code> which broadcast the constraint creation to each element of the vectors.</li></ul><p><strong>Note for extending the constraint macro</strong></p><p>Each constraint will be created using <code>add_constraint(m, build_constraint(_error, func, set))</code> where</p><ul><li><code>_error</code> is an error function showing the constraint call in addition to the error message given as argument,</li><li><code>func</code> is the expression that is constrained</li><li>and <code>set</code> is the set in which it is constrained to belong.</li></ul><p>For <code>expr</code> of the first type (i.e. <code>@constraint(m, func in set)</code>), <code>func</code> and <code>set</code> are passed unchanged to <code>build_constraint</code> but for the other types, they are determined from the expressions and signs. For instance, <code>@constraint(m, x^2 + y^2 == 1)</code> is transformed into <code>add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0)))</code>.</p><p>To extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to <code>build_constraint</code>. Note that this will likely mean that either <code>func</code> or <code>set</code> will be some custom type, rather than e.g. a <code>Symbol</code>, since we will likely want to dispatch on the type of the function or set appearing in the constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.SecondOrderCone" href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SecondOrderCone</code></pre><p>Second order cone object that can be used to constrain the euclidean norm of a vector <code>x</code> to be less than or equal to a nonnegative scalar <code>t</code>. This is a shortcut for the <code>MathOptInterface.SecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le t$</span> and <span>$t \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x-1, x-2] in SecondOrderCone())
[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.RotatedSecondOrderCone" href="#JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RotatedSecondOrderCone</code></pre><p>Rotated second order cone object that can be used to constrain the square of the euclidean norm of a vector <code>x</code> to be less than or equal to <span>$2tu$</span> where <code>t</code> and <code>u</code> are nonnegative scalars. This is a shortcut for the <code>MathOptInterface.RotatedSecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le 2tx$</span> and <span>$t, x \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())
[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.PSDCone" href="#JuMP.PSDCone"><code>JuMP.PSDCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PSDCone</code></pre><p>Positive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. If the matrix has type <code>Symmetric</code> then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the <code>MOI.PositiveSemidefiniteConeTriangle</code> set, otherwise its column vectorization is constrained to belong to the <code>MOI.PositiveSemidefiniteConeSquare</code> set.</p><p><strong>Examples</strong></p><p>Consider the following example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [ x 2x
            2x  x];

julia&gt; b = [1 2
            2 4];

julia&gt; cref = @SDconstraint(model, a ⪰ b)
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
4-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>We see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra # For Symmetric

julia&gt; cref = @constraint(model, Symmetric(a - b) in PSDCone())
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
3-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeTriangle(2)</code></pre><p>As we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.NoOptimizer" href="#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NoOptimizer &lt;: Exception end</code></pre><p>No optimizer is set. The optimizer can be provided at the <a href="#JuMP.Model"><code>Model</code></a> constructor or at the <a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> call with <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.delete-Tuple{Model,VariableRef}" href="#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">delete(model::Model, variable_ref::VariableRef)</code></pre><p>Delete the variable associated with <code>variable_ref</code> from the model <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.is_valid-Tuple{Model,VariableRef}" href="#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_valid(model::Model, variable_ref::VariableRef)</code></pre><p>Return <code>true</code> if <code>variable</code> refers to a valid variable in <code>model</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_name-Tuple{VariableRef,String}" href="#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_name(v::VariableRef, s::AbstractString)</code></pre><p>Set a variable&#39;s name attribute.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@variable" href="#JuMP.@variable"><code>JuMP.@variable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@variable(model, kw_args...)</code></pre><p>Add an <em>anonymous</em> variable to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable.</p><pre><code class="language-none">@variable(model, expr, args..., kw_args...)</code></pre><p>Add a variable to the model <code>model</code> described by the expression <code>expr</code>, the positional arguments <code>args</code> and the keyword arguments <code>kw_args</code>. The expression <code>expr</code> can either be (note that in the following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be used instead of <code>≥</code>)</p><ul><li>of the form <code>varexpr</code> creating variables described by <code>varexpr</code>;</li><li>of the form <code>varexpr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>varexpr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>);</li><li>of the form <code>varexpr == value</code> creating variables described by <code>varexpr</code> with fixed values given by <code>value</code>; or</li><li>of the form <code>lb ≤ varexpr ≤ ub</code> or <code>ub ≥ varexpr ≥ lb</code> creating variables described by <code>varexpr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code>.</li></ul><p>The expression <code>varexpr</code> can either be</p><ul><li>of the form <code>varname</code> creating a scalar real variable of name <code>varname</code>;</li><li>of the form <code>varname[...]</code> or <code>[...]</code> creating a container of variables (see <a href="@ref">Containers in macros</a>).</li></ul><p>The recognized positional arguments in <code>args</code> are the following:</p><ul><li><code>Bin</code>: Sets the variable to be binary, i.e. either 0 or 1.</li><li><code>Int</code>: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...</li><li><code>Symmetric</code>: Only available when creating a square matrix of variables, i.e. when <code>varexpr</code> is of the form <code>varname[1:n,1:n]</code> or <code>varname[i=1:n,j=1:n]</code>. It creates a symmetric matrix of variable, that is, it only creates a new variable for <code>varname[i,j]</code> with <code>i ≤ j</code> and sets <code>varname[j,i]</code> to the same variable as <code>varname[i,j]</code>.</li><li><code>PSD</code>: The square matrix of variable is both <code>Symmetric</code> and constrained to be positive semidefinite.</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the variable starting value used as initial guess in optimization.</li><li><code>binary</code>: Sets whether the variable is binary or not.</li><li><code>integer</code>: Sets whether the variable is integer or not.</li><li><code>variable_type</code>: See the &quot;Note for extending the variable macro&quot; section below.</li><li><code>container</code>: Specify the container type, see <a href="@ref">Containers in macros</a>.</li></ul><p><strong>Examples</strong></p><p>The following are equivalent ways of creating a variable <code>x</code> of name <code>x</code> with lower bound 0:</p><pre><code class="language-julia"># Specify everything in `expr`
@variable(model, x &gt;= 0)
# Specify the lower bound using a keyword argument
@variable(model, x, lower_bound=0)
# Specify everything in `kw_args`
x = @variable(model, base_name=&quot;x&quot;, lower_bound=0)</code></pre><p>The following are equivalent ways of creating a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code>.</p><pre><code class="language-julia">ub = Dict(:a =&gt; 2, :b =&gt; 3)
# Specify everything in `expr`
@variable(model, x[i=keys(ub)] &lt;= ub[i])
# Specify the upper bound using a keyword argument
@variable(model, x[i=keys(ub)], upper_bound=ub[i])</code></pre><p><strong>Note for extending the variable macro</strong></p><p>The single scalar variable or each scalar variable of the container are created using <code>add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...))</code> where</p><ul><li><code>model</code> is the model passed to the <code>@variable</code> macro;</li><li><code>_error</code> is an error function with a single <code>String</code> argument showing the <code>@variable</code> call in addition to the error message given as argument;</li><li><code>info</code> is the <code>VariableInfo</code> struct containing the information gathered in <code>expr</code>, the recognized keyword arguments (except <code>base_name</code> and <code>variable_type</code>) and the recognized positional arguments (except <code>Symmetric</code> and <code>PSD</code>);</li><li><code>extra_args</code> are the unrecognized positional arguments of <code>args</code> plus the value of the <code>variable_type</code> keyword argument if present. The <code>variable_type</code> keyword argument allows the user to pass a position argument to <code>build_variable</code> without the need to give a positional argument to <code>@variable</code>. In particular, this allows the user to give a positional argument to the <code>build_variable</code> call when using the anonymous single variable syntax <code>@variable(model, kw_args...)</code>; and</li><li><code>extra_kw_args</code> are the unrecognized keyword argument of <code>kw_args</code>.</li></ul><p><strong>Examples</strong></p><p>The following creates a variable <code>x</code> of name <code>x</code> with <code>lower_bound</code> 0 as with the first example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia">info = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)
JuMP.add_variable(model, JuMP.build_variable(error, info), &quot;x&quot;)</code></pre><p>The following creates a <code>DenseAxisArray</code> of index set <code>[:a, :b]</code> and with respective upper bounds 2 and 3 and names <code>x[a]</code> and <code>x[b]</code> as with the second example above but does it without using the <code>@variable</code> macro</p><pre><code class="language-julia"># Without the `@variable` macro
data = Vector{JuMP.variable_type(model)}(undef, length(keys(ub)))
x = JuMP.Containers.DenseAxisArray(data, keys(ub))
for i in keys(ub)
    info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)
    x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), &quot;x[$i]&quot;)
end</code></pre><p>The following are equivalent ways of creating a <code>Matrix</code> of size <code>N x N</code> with variables custom variables created with a JuMP extension using the <code>Poly(X)</code> positional argument to specify its variables:</p><pre><code class="language-julia"># Using the `@variable` macro
@variable(model, x[1:N,1:N], Symmetric, Poly(X))
# Without the `@variable` macro
x = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)
info = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)
for i in 1:N, j in i:N
    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), &quot;x[$i,$j]&quot;)
end</code></pre></div></div></section><footer><hr/><a class="previous" href="../library/"><span class="direction">Previous</span><span class="title">Library</span></a></footer></article></body></html>
