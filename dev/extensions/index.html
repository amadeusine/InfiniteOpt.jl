<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extensions · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../guide/install/">Installation</a></li><li><a class="tocitem" href="../guide/model/">Infinite Models</a></li><li><a class="tocitem" href="../guide/sets/">Infinite Sets</a></li><li><a class="tocitem" href="../guide/parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../guide/finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../guide/variable/">Variables</a></li><li><a class="tocitem" href="../guide/expression/">Expressions</a></li><li><a class="tocitem" href="../guide/measure/">Measures</a></li><li><a class="tocitem" href="../guide/objective/">Objectives</a></li><li><a class="tocitem" href="../guide/constraint/">Constraints</a></li><li><a class="tocitem" href="../guide/transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../guide/optimize/">Optimization</a></li><li><a class="tocitem" href="../guide/result/">Results</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Extensions</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Infinite-Sets-1"><span>Infinite Sets</span></a></li><li><a class="tocitem" href="#Measure-Evaluation-Techniques-1"><span>Measure Evaluation Techniques</span></a></li><li><a class="tocitem" href="#Measure-Data-1"><span>Measure Data</span></a></li><li><a class="tocitem" href="#extend_optimizer_model-1"><span>Optimizer Models</span></a></li><li><a class="tocitem" href="#Wrapper-Packages-1"><span>Wrapper Packages</span></a></li></ul></li><li><a class="tocitem" href="../develop/">Development</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Extensions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extensions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/extensions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Extensions-1"><a class="docs-heading-anchor" href="#Extensions-1">Extensions</a><a class="docs-heading-anchor-permalink" href="#Extensions-1" title="Permalink"></a></h1><p>Here we provide guidance to various ways <code>InfinitOpt</code> can be extended.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>Extendibility is one of the core ideas of <code>InfinitOpt</code> so that it can serve as a convenient tool for those developing and implementing advanced techniques for infinite dimensional optimization problems. Thus, <code>InfiniteOpt</code> is developed in a modular manner to readily accommodate user-defined functionality and/or to serve as useful base in writing a <code>JuMP</code> extension. Admittedly, this modularity might be imperfect and comments/suggestions are welcomed to help us improve this.</p><h2 id="Infinite-Sets-1"><a class="docs-heading-anchor" href="#Infinite-Sets-1">Infinite Sets</a><a class="docs-heading-anchor-permalink" href="#Infinite-Sets-1" title="Permalink"></a></h2><p>Infinite sets are used to characterize the behavior of infinite parameters and used to govern the behavior of supports in <code>InfiniteOpt</code>. Here we walk through how user-defined sets can be added to various degrees of functionality. A template is provided in <code>./InfiniteOpt/test/extensions/infinite_set.jl</code>. The extension steps employed are:</p><ol><li>Define the new <code>struct</code> infinite set type (only thing required as bare minimum)</li><li>Extend <a href="../guide/sets/#InfiniteOpt.supports_in_set"><code>InfiniteOpt.supports_in_set</code></a> (enables error checking of supports)</li><li>Extend <a href="../guide/sets/#InfiniteOpt.generate_support_values"><code>InfiniteOpt.generate_support_values</code></a> (enables support generation via <code>num_supports</code> keyword arguments)</li><li>Extend <a href="../guide/measure/#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> and register the new set type via <a href="../guide/measure/#InfiniteOpt.MeasureEvalMethods.register_eval_method"><code>register_eval_method</code></a> (enables measure evaluation methods)</li><li>If a lower bound and upper bound can be reported, extend <code>JuMP</code> lower bound and upper bound methods</li></ol><p>As an example, let&#39;s create a disjoint interval set as an infinite set type. This corresponds to the set <span>$[lb_1, ub_1] \cup [lb_2, ub_2]$</span> where <span>$ub_1 \leq lb_2$</span>. First, we need to create the <code>DataType</code> with inheritance from <a href="../guide/sets/#InfiniteOpt.AbstractInfiniteSet"><code>AbstractInfiniteSet</code></a>:</p><pre><code class="language-julia">using InfiniteOpt, JuMP

struct DisjointSet &lt;: InfiniteOpt.AbstractInfiniteSet
    lb1::Float64
    ub1::Float64
    lb2::Float64
    ub2::Float64
    # constructor
    function DisjointSet(lb1::Number, ub1::Number, lb2::Number, ub2::Number)
        if lb1 &gt; ub1 || lb2 &gt; ub2 || ub1 &gt; lb2
            error(&quot;Invalid bounds&quot;)
        end
        return new(convert(Float64, lb1), convert(Float64, ub1),
                   convert(Float64, lb2), convert(Float64, ub2))
    end
end</code></pre><p>Notice that we also define the constructor function to error check and convert as needed (this is recommended, but not required). For basic functionality this is all we have to do to add a set in <code>InfiniteOpt</code>.</p><p>We can now define infinite parameters using this set via <a href="../guide/parameter/#InfiniteOpt.@infinite_parameter"><code>@infinite_parameter</code></a> both anonymously and explicitly:</p><pre><code class="language-julia-repl">julia&gt; model = InfiniteModel();

julia&gt; t = @infinite_parameter(model, set = DisjointSet(0, 1, 3, 4), base_name = &quot;t&quot;)
t

julia&gt; @infinite_parameter(model, t in DisjointSet(0, 1, 3, 4))
t</code></pre><p>Once defined (without further extension), these parameters can be used as normal with the following limitations:</p><ul><li>Supports must be specified manually (<code>num_supports</code> is not enabled)</li><li>Supports will not be checked if they are in the domain of the infinite set</li><li>The <a href="../guide/measure/#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> must be provided explicitly to evaluate measures</li><li>Set bounds cannot be queried.</li></ul><p>However, all of these limitations can be eliminated by extending a few functions as outlined above.</p><p>To enable support domain checking which is useful to avoid strange bugs, we will extend <a href="../guide/sets/#InfiniteOpt.supports_in_set"><code>InfiniteOpt.supports_in_set</code></a>. This returns a <code>Bool</code> to indicate if a vector of supports are in the set&#39;s domain:</p><pre><code class="language-julia">function InfiniteOpt.supports_in_set(supports::Union{Number, Vector{&lt;:Number}},
                                     set::DisjointSet)::Bool
    return all((set.lb1 .&lt;= supports .&lt;= set.ub1) .| (set.lb2 .&lt;= supports .&lt;= set.ub2))
end</code></pre><p>Now the checks are enabled so, the following would yield an error because the support is not in the set domain:</p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, set = DisjointSet(0, 1, 3, 4), supports = 2)
ERROR: In `@infinite_parameter(model, set = DisjointSet(0, 1, 3, 4), supports = 2)`: Supports violate the set domain bounds.</code></pre><p>To enable automatic support generation via the <code>num_supports</code> keyword and with functions such as <a href="../guide/parameter/#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}"><code>fill_in_supports!</code></a>, we will extend <a href="../guide/sets/#InfiniteOpt.generate_support_values"><code>InfiniteOpt.generate_support_values</code></a>:</p><pre><code class="language-julia">function InfiniteOpt.generate_support_values(set::DisjointSet;
                                             num_supports::Int = 50,
                                             sig_fig::Int = 5)::Array
    length_ratio = (set.ub1 - set.lb1) / (set.ub1 - set.lb1 + set.ub2 - set.lb2)
    num_supports1 = Int64(ceil(length_ratio * num_supports))
    num_supports2 = num_supports - num_supports1
    supports1 = collect(range(set.lb1, stop = set.ub1, length = num_supports1))
    supports2 = collect(range(set.lb2, stop = set.ub2, length = num_supports2))
    return round.([supports1; supports2], sigdigits = sig_fig)
end</code></pre><p>Now automatic support generation is enabled, for example:</p><pre><code class="language-julia-repl">julia&gt; par = @infinite_parameter(model, set = DisjointSet(0, 2, 3, 4), num_supports = 10)
noname

julia&gt; supports(par)
10-element Array{Float64,1}:
 0.0
 0.33333
 0.66667
 1.0
 1.3333
 1.6667
 2.0
 3.0
 3.5
 4.0</code></pre><p>Note that in some cases <a href="../guide/sets/#InfiniteOpt.generate_support_values"><code>generate_support_values</code></a> might not be extendable since returning supports for a single infinite parameter may not be appropriate. This is typically true when a single set is used for multi-dimensional infinite parameters. In these cases, <a href="../guide/parameter/#InfiniteOpt.generate_and_add_supports!"><code>generate_and_add_supports!</code></a> will need to be extended. This is exemplified with multivariate distribution sets that correspond to an array of parameters where <code>generate_and_add_supports!</code> is extended to generate the supports and then add the appropriate slices to each dependent infinite parameter.</p><p>Next we can enable typical measure definition by extending <a href="../guide/measure/#InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs"><code>InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs</code></a> for our new set type. This function creates support values and corresponding coefficients for a measure using the <code>method</code> argument if appropriate. Also, if the <code>method</code> argument is used then we&#39;ll need to register valid method calls for our new set via <a href="../guide/measure/#InfiniteOpt.MeasureEvalMethods.register_eval_method"><code>register_eval_method</code></a>. If we wish to ignore the <code>method</code> then we&#39;ll need to set <code>check_method = false</code> when calling <a href="../guide/measure/#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s13,N} where N where #s13&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number},Union{Nothing, Number, AbstractArray{#s2,N} where N where #s2&lt;:Number}}"><code>measure</code></a> or using <a href="../guide/measure/#InfiniteOpt.set_measure_defaults"><code>set_measure_defaults</code></a>. Continuing our example, we obtain:</p><pre><code class="language-julia">const JuMPC = JuMP.Containers

function InfiniteOpt.MeasureEvalMethods.generate_supports_and_coeffs(
    set::DisjointSet,
    params::Union{InfiniteOpt.ParameterRef, AbstractArray{&lt;:InfiniteOpt.ParameterRef}},
    num_supports::Int,
    lb::Union{Number, JuMPC.SparseAxisArray, Nothing},
    ub::Union{Number, JuMPC.SparseAxisArray, Nothing},
    method::Function)::Tuple
    length_ratio = (set.ub1 - set.lb1) / (set.ub1 - set.lb1 + set.ub2 - set.lb2)
    num_supports1 = Int64(ceil(length_ratio * num_supports))
    num_supports2 = num_supports - num_supports1
    supports1, coeffs1 = method(set.lb1, set.ub1, num_supports1)
    supports2, coeffs2 = method(set.lb2, set.ub2, num_supports2)
    return ([supports1; supports2], [coeffs1; coeffs2])
end

register_eval_method(model, DisjointSet, [mc_sampling, gauss_legendre])</code></pre><p>Now we can define measures as normal:</p><pre><code class="language-julia-repl">julia&gt; mref = measure(t^2, t)
measure(t²)</code></pre><p>Finally, we can extend the appropriate <code>JuMP</code> upper and lower bound functions if desired which are:</p><ul><li><a href="../guide/sets/#JuMP.has_lower_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.has_lower_bound</code></a></li><li><a href="../guide/sets/#JuMP.lower_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.lower_bound</code></a></li><li><a href="../guide/sets/#JuMP.set_lower_bound-Tuple{AbstractInfiniteSet,Number}"><code>JuMP.set_lower_bound</code></a></li><li><a href="../guide/sets/#JuMP.has_upper_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.has_upper_bound</code></a></li><li><a href="../guide/sets/#JuMP.upper_bound-Tuple{AbstractInfiniteSet}"><code>JuMP.upper_bound</code></a></li><li><a href="../guide/sets/#JuMP.set_upper_bound-Tuple{AbstractInfiniteSet,Number}"><code>JuMP.set_upper_bound</code></a></li></ul><p>However, if we want <code>has_lower_bound = false</code> and <code>has_upper_bound = false</code> then no extension is needed. For our current, example we won&#39;t do this since lower and upper bounds aren&#39;t exactly clear for a disjoint interval. Please refer to the template in <code>./InfiniteOpt/test/extensions/infinite_set.jl</code> to see how this is done.</p><h2 id="Measure-Evaluation-Techniques-1"><a class="docs-heading-anchor" href="#Measure-Evaluation-Techniques-1">Measure Evaluation Techniques</a><a class="docs-heading-anchor-permalink" href="#Measure-Evaluation-Techniques-1" title="Permalink"></a></h2><h2 id="Measure-Data-1"><a class="docs-heading-anchor" href="#Measure-Data-1">Measure Data</a><a class="docs-heading-anchor-permalink" href="#Measure-Data-1" title="Permalink"></a></h2><p>Measures are used to evaluate over infinite domains. Users may wish to employ measures that are strictly integrals and thus may wish to extend <code>InfiniteOpt</code>&#39;s measure framework to accommodate other paradigms. This can be accomplished my implementing a user-defined measure data structure that inherits from <a href="../guide/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a>. A template for how such an extension is accomplished is provided in <code>./InfiniteOpt/test/extensions/measure_data.jl</code>. The extension steps employed are:</p><ol><li>Define the new data struct inheriting from <a href="../guide/measure/#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> (required)</li><li>Extend <a href="../guide/measure/#InfiniteOpt.parameter_refs-Tuple{AbstractMeasureData}"><code>InfiniteOpt.parameter_refs</code></a> (required)</li><li>Extend <a href="../guide/measure/#InfiniteOpt.expand_measure"><code>InfiniteOpt.expand_measure</code></a> (required)</li><li>Extend <a href="../guide/measure/#InfiniteOpt.supports-Tuple{AbstractMeasureData}"><code>InfiniteOpt.supports</code></a> (required if parameter supports are employed in any way)</li><li>Extend <a href="../guide/measure/#InfiniteOpt.measure_data_in_hold_bounds"><code>InfiniteOpt.measure_data_in_hold_bounds</code></a> (enables hold variable bound checking with measures)</li><li>Extend <a href="../guide/measure/#InfiniteOpt.measure_name"><code>InfiniteOpt.measure_name</code></a> (enables meaningful measure naming)</li><li>Make simple measure constructor wrapper of <a href="../guide/measure/#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,AbstractMeasureData}"><code>measure</code></a> to ease definition</li></ol><p>TODO: Provide an extension example using CVaR.</p><h2 id="extend_optimizer_model-1"><a class="docs-heading-anchor" href="#extend_optimizer_model-1">Optimizer Models</a><a class="docs-heading-anchor-permalink" href="#extend_optimizer_model-1" title="Permalink"></a></h2><h2 id="Wrapper-Packages-1"><a class="docs-heading-anchor" href="#Wrapper-Packages-1">Wrapper Packages</a><a class="docs-heading-anchor-permalink" href="#Wrapper-Packages-1" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../develop/">Development »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 12 March 2020 18:44">Thursday 12 March 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
