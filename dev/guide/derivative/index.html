<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Derivatives · InfiniteOpt.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-178297470-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../sets/">Infinite Sets</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li class="is-active"><a class="tocitem" href>Derivatives</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Advanced-Information"><span>Advanced Information</span></a></li><li><a class="tocitem" href="#Numerical-Evaluation-Methods"><span>Numerical Evaluation Methods</span></a></li><li><a class="tocitem" href="#Datatypes"><span>Datatypes</span></a></li><li><a class="tocitem" href="#deriv_methods"><span>Methods/Macros</span></a></li></ul></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Derivatives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Derivatives</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/derivative.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h1><p>A guide and manual for the definition and use of derivatives in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><h2 id="Advanced-Information"><a class="docs-heading-anchor" href="#Advanced-Information">Advanced Information</a><a id="Advanced-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Information" title="Permalink"></a></h2><h2 id="Numerical-Evaluation-Methods"><a class="docs-heading-anchor" href="#Numerical-Evaluation-Methods">Numerical Evaluation Methods</a><a id="Numerical-Evaluation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Evaluation-Methods" title="Permalink"></a></h2><h2 id="Datatypes"><a class="docs-heading-anchor" href="#Datatypes">Datatypes</a><a id="Datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#Datatypes" title="Permalink"></a></h2><ul><li><a href="../variable/#InfiniteOpt.HoldVariable"><code>InfiniteOpt.HoldVariable</code></a></li><li><a href="../variable/#InfiniteOpt.HoldVariableIndex"><code>InfiniteOpt.HoldVariableIndex</code></a></li><li><a href="../variable/#InfiniteOpt.HoldVariableRef"><code>InfiniteOpt.HoldVariableRef</code></a></li><li><a href="../variable/#InfiniteOpt.InfOptVariable"><code>InfiniteOpt.InfOptVariable</code></a></li><li><a href="../variable/#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a></li><li><a href="../variable/#InfiniteOpt.InfiniteVariableIndex"><code>InfiniteOpt.InfiniteVariableIndex</code></a></li><li><a href="../variable/#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a></li><li><a href="../variable/#InfiniteOpt.ParameterBounds"><code>InfiniteOpt.ParameterBounds</code></a></li><li><a href="../variable/#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a></li><li><a href="../variable/#InfiniteOpt.PointVariableIndex"><code>InfiniteOpt.PointVariableIndex</code></a></li><li><a href="../variable/#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a></li><li><a href="../variable/#InfiniteOpt.VariableData"><code>InfiniteOpt.VariableData</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DerivativeIndex" href="#InfiniteOpt.DerivativeIndex"><code>InfiniteOpt.DerivativeIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DerivativeIndex &lt;: ObjectIndex</code></pre><p>A <code>DataType</code> for storing the index of a <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::Int64</code>: The index value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DerivativeRef" href="#InfiniteOpt.DerivativeRef"><code>InfiniteOpt.DerivativeRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DerivativeRef &lt;: DispatchVariableRef</code></pre><p>A <code>DataType</code> for untranscripted derivative references.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code>: Infinite model.</li><li><code>index::DerivativeIndex</code>: Index of the derivative in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL1360-L1368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Derivative" href="#InfiniteOpt.Derivative"><code>InfiniteOpt.Derivative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Derivative{V &lt;: GeneralVariableRef} &lt;: InfOptVariable</code></pre><p>A <code>DataType</code> for storing core infinite derivative information. This follows a  derivative of the form: <span>$\frac{\partial x(\alpha, \hdots)}{\partial \alpha}$</span>  where <span>$x(\alpha, \hdots)$</span> is an infinite variable and <span>$\alpha$</span> is an infinite  parameter. Here, both <span>$x$</span> and <span>$\alpha$</span> must be scalars. </p><p>It is important to note that <code>info.start</code> should contain a start value function that generates the start value for a given infinite parameter support. This function should map a support to a start value using user-formatting if <code>is_vector_start = false</code>, otherwise it should do the mapping using a single support vector as input. Also, the variable reference type <code>V</code> must pertain to infinite variables and parameters.</p><p><strong>Fields</strong></p><ul><li><code>info::JuMP.VariableInfo{Float64, Float64, Float64, Function}</code>: JuMP variable information.</li><li><code>is_vector_start::Bool</code>: Does the start function take support values formatted as vectors?</li><li><code>variable_ref::V</code>: The variable reference of the infinite variable argument.</li><li><code>parameter_ref::V</code>: The variable reference of the infinite parameter the defines the  differential operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL756-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractDerivativeMethod" href="#InfiniteOpt.AbstractDerivativeMethod"><code>InfiniteOpt.AbstractDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDerivativeMethod</code></pre><p>An abstract type for storing derivative evaluation data that is pertinent to its  reformation/transcription. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL277-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.GenerativeDerivativeMethod" href="#InfiniteOpt.GenerativeDerivativeMethod"><code>InfiniteOpt.GenerativeDerivativeMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GenerativeDerivativeMethod &lt;: AbstractDerivativeMethod</code></pre><p>An abstract type for derivative evaluation method types that will require support  generation when employed (e.g., internal node points associated with orthogonal  collocation). Such methods can be used with derivatives that on independent  infinite parameters, but cannot be used for ones that depend on dependent parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL285-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.OrthogonalCollocation" href="#InfiniteOpt.OrthogonalCollocation"><code>InfiniteOpt.OrthogonalCollocation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrthogonalCollocation &lt;: GenerativeDerivativeMethod</code></pre><p>A <code>DataType</code> for storing information about orthogonal collocation method for derivative evaluation. Note that the constructor for this method is of the form: </p><pre><code class="language-julia">    OrthogonalCollocation(num_nodes::Int, technique::Type{&lt;:OCTechnique} = Labatto)</code></pre><p>where <code>num_nodes</code> is total number of nodes for each collocation interval. In  practice, this corresponds to <code>num_nodes = num_internal_nodes + 2</code>. </p><p><strong>Fields</strong></p><ul><li><code>num_internal_nodes::Int</code>: The number of internal collocation points (nodes)  between the each support pair.</li><li><code>technique::Type{&lt;:OCTechnique}</code>: The method used to produce the points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL310-L326">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>OCQuadrature</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Lobatto" href="#InfiniteOpt.Lobatto"><code>InfiniteOpt.Lobatto</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lobatto &lt;: OCTechnique</code></pre><p>A quadrature method label for orthogonal collocation method that generates internal nodes between public supports using Lobatto quadrature method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL302-L307">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>NonGenerativeDerivateMethod</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FiniteDifference" href="#InfiniteOpt.FiniteDifference"><code>InfiniteOpt.FiniteDifference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteDifference &lt;: NonGenerativeDerivativeMethod</code></pre><p>A <code>DataType</code> for information about finite difference method applied to  a derivative evaluation. </p><p><strong>Fields</strong> </p><ul><li><code>technique::Type{&lt;:FDTechnique}</code>: Mathematical technqiue behind finite difference</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL382-L390">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>FDTechniques</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FDForward" href="#InfiniteOpt.FDForward"><code>InfiniteOpt.FDForward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDForward &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a forward  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FDCentral" href="#InfiniteOpt.FDCentral"><code>InfiniteOpt.FDCentral</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDCentral &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a central  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL366-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.FDBackward" href="#InfiniteOpt.FDBackward"><code>InfiniteOpt.FDBackward</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FDBackward &lt;: FDTechnique</code></pre><p>A technique label for finite difference method that implements a backward  difference approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL374-L379">source</a></section></article><h2 id="deriv_methods"><a class="docs-heading-anchor" href="#deriv_methods">Methods/Macros</a><a id="deriv_methods-1"></a><a class="docs-heading-anchor-permalink" href="#deriv_methods" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.@deriv"><code>InfiniteOpt.@deriv</code></a></li><li><a href="#InfiniteOpt.@derivative_variable"><code>InfiniteOpt.@derivative_variable</code></a></li><li><a href="#InfiniteOpt.add_derivative"><code>InfiniteOpt.add_derivative</code></a></li><li><a href="#InfiniteOpt.add_derivative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.add_derivative_supports</code></a></li><li><a href="#InfiniteOpt.all_derivatives"><code>InfiniteOpt.all_derivatives</code></a></li><li><a href="#InfiniteOpt.build_derivative"><code>InfiniteOpt.build_derivative</code></a></li><li><a href="#InfiniteOpt.deriv"><code>InfiniteOpt.deriv</code></a></li><li><a href="#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_argument</code></a></li><li><a href="#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_method</code></a></li><li><a href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>InfiniteOpt.evaluate</code></a></li><li><a href="#InfiniteOpt.evaluate_all_derivatives!"><code>InfiniteOpt.evaluate_all_derivatives!</code></a></li><li><a href="#InfiniteOpt.evaluate_derivative"><code>InfiniteOpt.evaluate_derivative</code></a></li><li><a href="#InfiniteOpt.make_reduced_expr"><code>InfiniteOpt.make_reduced_expr</code></a></li><li><a href="#InfiniteOpt.num_derivatives"><code>InfiniteOpt.num_derivatives</code></a></li><li><a href="#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>InfiniteOpt.operator_parameter</code></a></li><li><a href="#InfiniteOpt.parameter_list-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_list</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.raw_parameter_refs</code></a></li><li><a href="#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>InfiniteOpt.reset_start_value_function</code></a></li><li><a href="#InfiniteOpt.set_all_derivative_methods"><code>InfiniteOpt.set_all_derivative_methods</code></a></li><li><a href="#InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a></li><li><a href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a></li><li><a href="#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a></li><li><a href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@deriv" href="#InfiniteOpt.@deriv"><code>InfiniteOpt.@deriv</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@deriv(expr, pref_expr1[, ...]
       )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>The macro variant of <a href="#InfiniteOpt.deriv"><code>deriv</code></a> that is more efficient for expression building  and enables symbolic differential operator parameter defintions via <code>pref_expr</code>s.  Like <code>deriv</code> expr can be any InfiniteOpt expression and the appropriate calculus  rules will applied to <code>expr</code> to take its derivative with respect to the indicated  infinite parameters detailed by the <code>pref_expr</code>s. The resulting derivative  expression will contain individual derivatives that were created and added to the  InfiniteModel as needed. Here each <code>pref_expr</code> arugment can be of the form:</p><ul><li><code>pref::GeneralVariableRef</code>: An indiviudal infinite parameter reference</li><li><code>(pref::GeneralVariableRef)^(p::Int)</code>: An infinite parameter applied <code>p</code> times.</li></ul><p>Thus, the syntax <code>@deriv(expr, pref^2)</code> is equivalent to <code>@deriv(expr, pref, pref)</code>. </p><p>This will error if <code>pref_expr</code> is an unrecongnized syntax, no infinite parameter  is given, or if any of the specified parameters are not infinite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1])
t

julia&gt; @infinite_variable(m, x(t))
x(t)

julia&gt; @hold_variable(m, z)
z

julia&gt; deriv_expr = @deriv(x^2 + z, t^2)
2 ∂/∂t[∂/∂t[x(t)]]*x(t) + 2 ∂/∂t[x(t)]²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL344-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.deriv" href="#InfiniteOpt.deriv"><code>InfiniteOpt.deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deriv(expr::JuMP.AbstractJuMPScalar, pref1::GeneralVariableRef[, ....]
      )::Union{JuMP.AbstractJuMPScalar, Float64}</code></pre><p>Apply appropriate calculus methods to define and return the derivative expression of <code>expr</code>  with respect to the infinite parameter(s) <code>pref1</code>, pref2<code>, etc. in that respective  order. This will implicilty build and add individual [</code>Derivative`](@ref)s as  appropriate. Errors if no infinite parameter is given or if the parameters are  not infinite.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1])
t

julia&gt; @infinite_variable(m, x(t))
x(t)

julia&gt; @hold_variable(m, z)
z

julia&gt; deriv_expr = deriv(x^2 + z, t, t)
2 ∂/∂t[∂/∂t[x(t)]]*x(t) + 2 ∂/∂t[x(t)]²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL306-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.@derivative_variable" href="#InfiniteOpt.@derivative_variable"><code>InfiniteOpt.@derivative_variable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@derivative_variable(model::InfiniteModel, kw_args...)::GeneralVariableRef</code></pre><p>Add an <em>anonymous</em> derivative to the model <code>model</code> described by the keyword arguments <code>kw_args</code> and returns the variable reference. Note that the <code>argument</code> and <code>operator_parameter</code> keywords are required in this case.</p><pre><code class="language-julia">@derivative_variable(model::InfiniteModel, deriv_expr, var_expr,
                     kw_args...)::GeneralVariableRef</code></pre><p>Add a derivative to <code>model</code> described by the expression <code>var_expr</code>, the keyword  arguments <code>kw_args</code>, and the derivative expr <code>deriv_expr</code>. The expression  <code>deriv_expr</code> specifies the derivative argument and operator parameter and must be  of the from: <code>d(arg_vref)/d(pref)</code> where <code>arg_vref</code> is a variable/derivative/measure  with an infinite dependence on the infinite parameter <code>pref</code>. Equivalently, the  derivative can be expressed <code>∂(arg_vref)/∂(pref)</code>. The expression <code>var_expr</code> is  used to define variable specific bounds and whose name is used as an alias for the  derivative reference. The expression <code>var_expr</code> can either be (note that in the  following the symbol <code>&lt;=</code> can be used instead of <code>≤</code> and the symbol <code>&gt;=</code>can be  used instead of <code>≥</code>) of the form:</p><ul><li><code>var_expr</code> creating variables described by <code>varexpr</code></li><li><code>var_expr ≤ ub</code> (resp. <code>varexpr ≥ lb</code>) creating variables described by <code>var_expr</code> with upper bounds given by <code>ub</code> (resp. lower bounds given by <code>lb</code>)</li><li><code>var_expr == value</code> creating variables described by <code>var_expr</code> with fixed values  given by <code>value</code></li><li><code>lb ≤ var_expr ≤ ub</code> or <code>ub ≥ var_expr ≥ lb</code> creating variables described by <code>var_expr</code> with lower bounds given by <code>lb</code> and upper bounds given by <code>ub</code></li></ul><p>Note that the preferred way to define derivatives is via <a href="#InfiniteOpt.@deriv"><code>@deriv</code></a> which  provides a more succinct way to specify more complex derivatives. However, this  variable based syntax is provided as a convenient way to specify starting  values/functions when needed.</p><p>The expression <code>var_expr</code> can be of the form:</p><ul><li><code>varname</code> creating a scalar real variable of alias name <code>varname</code></li><li><code>varname[...]</code> or <code>[...]</code> creating a container of variables.</li></ul><p>The recognized keyword arguments in <code>kw_args</code> are the following:</p><ul><li><code>argument</code>: Sets the argument of the differential operator.</li><li><code>operator_parameter</code>: Sets the infinite parameter the derivative is with respect to.</li><li><code>base_name</code>: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to <code>base_name[...]</code> for each index <code>...</code> of the axes <code>axes</code>.</li><li><code>lower_bound</code>: Sets the value of the variable lower bound.</li><li><code>upper_bound</code>: Sets the value of the variable upper bound.</li><li><code>start</code>: Sets the derivative starting value used as initial guess in optimization.          This can be a single value enforced over the entire infinite          domain or it can be a function that maps a support value to a scalar          guess value. Note that the function arguments must match the format          of <code>parameter_refs(argument)</code>.</li><li><code>container</code>: Specify the container type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, t in [0, 10])
t

julia&gt; @infinite_variable(model, x(t) &gt;= 0)
x(t)

julia&gt; @infinite_variable(model, y[1:2](t))
2-element Array{GeneralVariableRef,1}:
 y[1](t)
 y[2](t)

julia&gt; @derivative_variable(model, d(x)/d(t), dx &lt;= 1, start = 0)
dx

julia&gt; dx = @derivative_variable(model, d(x)/d(t), upper_bound = 1, base_name = &quot;dx&quot;)
dx

julia&gt; dx = @derivative_variable(model, upper_bound = 1, base_name = &quot;dx&quot;,
                                  argument = x, operator_parameter = t)
dx

julia&gt; @derivative_variable(model, d(y[i])/d(t), dx2[i = 1:2])
2-element Array{GeneralVariableRef,1}:
 dx2[1]
 dx2[2]

julia&gt; dx = @derivative_variable(model, d(y[i])/d(t), [i = 1:2])
2-element Array{GeneralVariableRef,1}:
 ∂/∂t[y[1](t)]
 ∂/∂t[y[2](t)]
 
julia&gt; dx = @derivative_variable(model, [i = 1:2], argument = y[i], 
                                 operator_parameter = t)
2-element Array{GeneralVariableRef,1}:
 ∂/∂t[y[1](t)]
 ∂/∂t[y[2](t)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/macros.jl#LL1256-L1354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_derivative" href="#InfiniteOpt.build_derivative"><code>InfiniteOpt.build_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_derivative(_error::Function, info::JuMP.VariableInfo, 
                 argument_ref::GeneralVariableRef, 
                 parameter_ref::GeneralVariableRef
                 )::Derivative</code></pre><p>Constructs and returns a <a href="#InfiniteOpt.Derivative"><code>Derivative</code></a> with a differential operator that  depends on <code>parameter_ref</code> and operates on <code>argument_ref</code>. Variable <code>info</code> can also  be provided to associate this derivative with bounds and a starting value function  like that of infinite variables. Errors when <code>argument_ref</code> is not an  infinite/reduced variable or derivative that depends on <code>parameter_ref</code>. Also,  errors if such a derivative was already added to the model.</p><p><strong>Example</strong> ```julia-repl  julia&gt; @infinite<em>parameter(m, t in [0, 1]); @infinite</em>variable(m, x(t));</p><p>julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);</p><p>julia&gt; build<em>derivative(error, info, x, t) Derivative{GeneralVariableRef}(VariableInfo{Float64,Float64,Float64,Function}(false, 0.0, false, 0.0, false, 0.0, false, start</em>func, false, false), true, x(t), t) ````</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL136-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_derivative" href="#InfiniteOpt.add_derivative"><code>InfiniteOpt.add_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_derivative(model::InfiniteModel, d::Derivative, 
               [name::String = &quot;&quot;])::GeneralVariableRef</code></pre><p>Adds a derivative <code>d</code> to <code>model</code> and returns a <code>GeneralVariableRef</code> that points  to it. Errors if the derivative dependencies do not belong to <code>model</code>. Note that  <code>d</code> should be built using <a href="#InfiniteOpt.build_derivative"><code>build_derivative</code></a> to avoid nuance internal  errors.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, t in [0, 1]); @infinite_variable(m, x(t));

julia&gt; info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);

julia&gt; d = build_derivative(error, info, x, t);

julia&gt; dref = add_derivative(m, d)
∂/∂t[x(t)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL201-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_argument-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_argument-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_argument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_argument(dref::DerivativeRef)::GeneralVariableRef</code></pre><p>Returns the infinite variable/derivative reference that is the input the differential operator (i.e., the dependent variable of the derivative).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_argument(dref) 
x(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.operator_parameter-Tuple{DerivativeRef}" href="#InfiniteOpt.operator_parameter-Tuple{DerivativeRef}"><code>InfiniteOpt.operator_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">operator_parameter(dref::DerivativeRef)::GeneralVariableRef</code></pre><p>Returns the infinite parameter reference that is what the differential operator  is operating with respect to (i.e., the independent  variable of the derivative).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; operator_parameter(dref) 
t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL62-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.derivative_method-Tuple{DerivativeRef}" href="#InfiniteOpt.derivative_method-Tuple{DerivativeRef}"><code>InfiniteOpt.derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">derivative_method(dref::DerivativeRef)::AbstractDerivativeMethod</code></pre><p>Returns the evaluation method employed by <code>dref</code> that determines the numerical  computation scheme that will be used to evaluate the derivative. Note that this  is set on by the infinite parameter with respect to which the derivative is  defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; derivative_method(dref) 
FiniteDifference()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}" href="#InfiniteOpt.raw_parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.raw_parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">raw_parameter_refs(dref::DerivativeRef)::VectorTuple{GeneralVariableRef}</code></pre><p>Return the raw <a href="../variable/#InfiniteOpt.Collections.VectorTuple"><code>VectorTuple</code></a> of the parameter references that <code>dref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL398-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{DerivativeRef}" href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(dref::DerivativeRef)::Tuple</code></pre><p>Return the parameter references associated with the infinite derivative <code>dref</code>. This is formatted as a Tuple of containing the parameter references as they inputted to define <code>dref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; parameter_refs(deriv)
(t,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL410-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_list-Tuple{DerivativeRef}" href="#InfiniteOpt.parameter_list-Tuple{DerivativeRef}"><code>InfiniteOpt.parameter_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_list(dref::DerivativeRef)::Vector{GeneralVariableRef}</code></pre><p>Return a vector of the parameter references that <code>dref</code> depends on. This is primarily an internal method where <a href="#InfiniteOpt.parameter_refs-Tuple{DerivativeRef}"><code>parameter_refs</code></a> is intended as the preferred user function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL427-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}" href="#InfiniteOpt.set_start_value_function-Tuple{DerivativeRef,Union{Function, Real}}"><code>InfiniteOpt.set_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_start_value_function(dref::DerivativeRef,
                         start::Union{Real, Function})::Nothing</code></pre><p>Set the start value function of <code>dref</code>. If <code>start::Real</code> then a function is generated to such that the start value will be <code>start</code> for the entire infinite domain. If <code>start::Function</code> then this function should map to a scalar start value given a support value arguments matching the format of the parameter elements in <code>parameter_refs(dref)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_start_value_function(dref, 1) # all start values will be 1

julia&gt; set_start_value_function(dref, my_func) # each value will be made via my_func</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL456-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}" href="#InfiniteOpt.reset_start_value_function-Tuple{DerivativeRef}"><code>InfiniteOpt.reset_start_value_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset_start_value_function(dref::DerivativeRef)::Nothing</code></pre><p>Remove the existing start value function and return to the default. Generally, this is triggered by deleting an infinite parameter that <code>dref</code> depends on.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; reset_start_value_function(dref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL489-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.num_derivatives" href="#InfiniteOpt.num_derivatives"><code>InfiniteOpt.num_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">num_derivatives(model::InfiniteModel)::Int</code></pre><p>Returns the number of derivatives that have been defined in <code>model</code>. Note that  nested derivatives will be counted in accordance with their components (e.g.,  <span>$\frac{d^2 x(t)}{dt^2} =$</span>\frac{d}{dt}\left(\frac{d x(t)}{dt} \right)``  will count as 2 derivatives.)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; num_derivatives(model)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL522-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.all_derivatives" href="#InfiniteOpt.all_derivatives"><code>InfiniteOpt.all_derivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_derivatives(model::InfiniteModel)::Vector{GeneralVariableRef}</code></pre><p>Returns a list of all the individual derivatives stored in <code>model</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; all_derivatives(model)
4-element Array{GeneralVariableRef,1}:
 TODO PUT OUTPUT HERE ONCE PRINTING IS DONE</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivatives.jl#LL540-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}" href="#InfiniteOpt.set_derivative_method-Tuple{IndependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_derivative_method(pref::IndependentParameterRef, 
                      method::AbstractDerivativeMethod)::Nothing</code></pre><p>Specfies the desired derivative evaluation method <code>method</code> for derivatives that are  taken with respect to <code>pref</code>. Any internal supports exclusively associated with  the previous method will be deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(d, OrthogonalCollocation(2))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/scalar_parameters.jl#LL661-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef,AbstractDerivativeMethod}" href="#InfiniteOpt.set_derivative_method-Tuple{DependentParameterRef,AbstractDerivativeMethod}"><code>InfiniteOpt.set_derivative_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_derivative_method(pref::DependentParameterRef, 
                      method::NonGenerativeDerivativeMethod)::Nothing</code></pre><p>Specfies the desired derivative evaluation method <code>method</code> for derivatives that are  taken with respect to <code>pref</code>. Errors if <code>method</code> is generative (i.e., it requires  the definition of additional supports)</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_derivative_method(d, FiniteDifference())
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/array_parameters.jl#LL576-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.set_all_derivative_methods" href="#InfiniteOpt.set_all_derivative_methods"><code>InfiniteOpt.set_all_derivative_methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_all_derivative_methods(model::InfiniteModel, 
                           method::AbstractDerivativeMethod)::Nothing</code></pre><p>Sets the desired evaluation method <code>method</code> for all the derivatives currently added  to <code>model</code>. Note that this is done with respect to the infinite parameters. Errors  if a generative method is specified and the model contains dependent parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; set_all_derivative_methods(model, OrthogonalCollocation(2))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/array_parameters.jl#LL605-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate-Tuple{DerivativeRef}" href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>InfiniteOpt.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(dref::DerivativeRef)::Nothing</code></pre><p>Numerically evaluate <code>dref</code> by computing its auxiliary derivative constraints  (e.g., collocation equations) and add them to the model. For normal usage, it is  recommended that this method not be called directly and instead have TranscriptionOpt  handle these equations, since preemptive evaluation can lead to invalid relations  if the support structure is modified. Errors if <code>evaluate_derivative</code> is not  defined for the derivative method employed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel(); @infinite_parameter(m, t in [0,2]); @infinite_variable(m, T(t));

julia&gt; dref = @deriv(T,t)
∂/∂t[T(t)]

julia&gt; add_supports(t, [0, 0.5, 1, 1.5, 2])

julia&gt; evaluate(dref)

julia&gt; print(m)
Feasibility
Subject to
 0.5 ∂/∂t[T(t)](0) - T(0.5) + T(0) = 0.0
 ∂/∂t[T(t)](0.5) - T(1) + T(0) = 0.0
 ∂/∂t[T(t)](1) - T(1.5) + T(0.5) = 0.0
 ∂/∂t[T(t)](1.5) - T(2) + T(1) = 0.0
 0.5 ∂/∂t[T(t)](2) - T(2) + T(1.5) = 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivative_evaluations.jl#LL319-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate_all_derivatives!" href="#InfiniteOpt.evaluate_all_derivatives!"><code>InfiniteOpt.evaluate_all_derivatives!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate_all_derivatives!(model::InfiniteModel)::Nothing</code></pre><p>Evaluate all the derivatives in <code>model</code> by adding the corresponding auxiliary  equations to <code>model</code>. See <a href="#InfiniteOpt.evaluate-Tuple{DerivativeRef}"><code>evaluate</code></a> for more information.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; m = InfiniteModel();

julia&gt; @infinite_parameter(m, t in [0,2], supports = [0, 1, 2]);

julia&gt; @infinite_parameter(m, x in [0,1], supports = [0, 0.5, 1]);

julia&gt; @infinite_variable(m, T(x, t));

julia&gt; dref1 = @deriv(T, t); dref2 = @deriv(T, x^2);

julia&gt; evaluate_all_derivatives!(m)

julia&gt; print(m)
Feasibility
Subject to
 ∂/∂t[T(x, t)](x, 0) - T(x, 1) + T(x, 0) = 0.0, ∀ x ∈ [0, 1]
 2 ∂/∂t[T(x, t)](x, 1) - T(x, 2) + T(x, 0) = 0.0, ∀ x ∈ [0, 1]
 ∂/∂t[T(x, t)](x, 2) - T(x, 2) + T(x, 1) = 0.0, ∀ x ∈ [0, 1]
 0.5 ∂/∂x[T(x, t)](0, t) - T(0.5, t) + T(0, t) = 0.0, ∀ t ∈ [0, 2]
 ∂/∂x[T(x, t)](0.5, t) - T(1, t) + T(0, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[T(x, t)](1, t) - T(1, t) + T(0.5, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[∂/∂x[T(x, t)]](0, t) - ∂/∂x[T(x, t)](0.5, t) + ∂/∂x[T(x, t)](0, t) = 0.0, ∀ t ∈ [0, 2]
 ∂/∂x[∂/∂x[T(x, t)]](0.5, t) - ∂/∂x[T(x, t)](1, t) + ∂/∂x[T(x, t)](0, t) = 0.0, ∀ t ∈ [0, 2]
 0.5 ∂/∂x[∂/∂x[T(x, t)]](1, t) - ∂/∂x[T(x, t)](1, t) + ∂/∂x[T(x, t)](0.5, t) = 0.0, ∀ t ∈ [0, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivative_evaluations.jl#LL367-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.evaluate_derivative" href="#InfiniteOpt.evaluate_derivative"><code>InfiniteOpt.evaluate_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate_derivative(dref::GeneralVariableRef, 
                    method::AbstractDerivativeMethod,
                    write_model::JuMP.AbstractModel)::Vector{JuMP.AbstractJuMPScalar}</code></pre><p>Build expressions for derivative <code>dref</code> evaluated in accordance with <code>method</code>.  The expressions are of the form <code>lhs - rhs</code>, where <code>lhs</code> is a function of derivatives evaluated at some supports for certain infinite parameter, and <code>rhs</code> is a function of the derivative arguments evaluated at some supports for certain infinite parameter. For example, for finite difference methods at point <code>t = 1</code>, <code>lhs</code> is <code>Δt * ∂/∂t[T(1)]</code>, and <code>rhs</code> could be <code>T(1+Δt) - T(1)</code> in case of forward difference mode. This is intended as a helper function for <code>evaluate</code>, which  will take the the expressions generated by this method and generate constraints that approximate the derivative values by setting the expressions as 0. However, one can extend this function  to encode custom methods for approximating derivatives. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivative_evaluations.jl#LL172-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}" href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>InfiniteOpt.support_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">support_label(method::GenerativeDerivativeMethod)</code></pre><p>Return the support label associated with <code>method</code> if there is one, errors otherwise.  This should be extended for any <code>GenerativeDerivativeMethod</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/datatypes.jl#LL399-L404">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>InfiniteOPt.generate_derivative_supports</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_derivative_supports-Tuple{IndependentParameterRef}" href="#InfiniteOpt.add_derivative_supports-Tuple{IndependentParameterRef}"><code>InfiniteOpt.add_derivative_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_derivative_supports(pref::Union{IndependentParameterRef, DependentParameterRef})::Nothing</code></pre><p>Add any supports <code>pref</code> that are needed for derivative evaluation. This is intended  as a helper method for derivative evaluation and depends <a href="guide/@ref InfiniteOpt.generate_derivative_supports"><code>generate_derivative_supports</code></a>  which will need to be extended for user-defined derivative methods that generate supports.  In such cases, it is necessary to also extend  <a href="#InfiniteOpt.support_label-Tuple{AbstractDerivativeMethod}"><code>support_label</code></a> Errors if  such is not defined for the current derivative method associated with <code>pref</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivative_evaluations.jl#LL79-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.make_reduced_expr" href="#InfiniteOpt.make_reduced_expr"><code>InfiniteOpt.make_reduced_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_reduced_expr(vref::GeneralVariableRef, pref::GeneralVariableRef, 
                  support::Float64, write_model::Union{InfiniteModel, JuMP.Model})</code></pre><p>Given the argument variable <code>vref</code> and the operator parameter <code>pref</code> from a  derivative, build and return the reduced expression in accordance to the support  <code>support</code> with respect to <code>pref</code>. New point/reduced variables will be written to  <code>write_model</code>. This is solely intended as a helper function for derivative  evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/31d920d226024998a5e0d4e451b8e88e2d1c2f7a/src/derivative_evaluations.jl#LL106-L115">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variable/">« Variables</a><a class="docs-footer-nextpage" href="../expression/">Expressions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 5 October 2020 21:35">Monday 5 October 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
