<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Transcription · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li class="is-active"><a class="tocitem" href>Model Transcription</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Transcription-Theory-1"><span>Transcription Theory</span></a></li><li><a class="tocitem" href="#TranscriptionOpt-1"><span>TranscriptionOpt</span></a></li><li><a class="tocitem" href="#Datatypes-1"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Model Transcription</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Transcription</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/transcribe.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-Transcription-1"><a class="docs-heading-anchor" href="#Model-Transcription-1">Model Transcription</a><a class="docs-heading-anchor-permalink" href="#Model-Transcription-1" title="Permalink"></a></h1><p>A guide and manual for transcribing infinite models using <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>All infinite models need to be reformulated in such a way that they can be solved using traditional optimization methods. Typically, this involves discretization of the infinite domain via particular parameter support points. By default, <code>InfiniteOpt</code> employs this methodology via the use of transcription models (which comprise the <code>optimizer_model</code> as discussed in the <a href="../model/#Infinite-Models-1">Infinite Models</a> section). <code>InfiniteOpt</code> is built modularly to readily accept other user defined techniques and this is discussed in further detail on the <a href="../../extensions/#Extensions-1">Extensions</a> page. This page will detail transcription models based in <code>InfiniteOpt.TranscriptionOpt</code> which provide the default transcription (reformulation) capabilities of <code>InfiniteOpt</code>.</p><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><p>Most users will not need to employ the capabilities of <code>TranscriptionOpt</code> directly since they are employed implicitly with the call of <a href="../optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> on an infinite model. This occurs since <code>TranscriptionModel</code>s are the default optimizer model type that is employed.</p><p>However, some users may wish to use <code>TranscriptionOpt</code> to extract a fully discretized/transcribed version of an infinite model that is conveniently output as a typical <code>JuMP</code> model and can then be treated as such. This is principally accomplished via the <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}"><code>TranscriptionModel</code></a> constructor. To illustrate how this is done, let&#39;s first define a basic infinite model with a simple support structure for the sake of example:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP

julia&gt; inf_model = InfiniteModel();

julia&gt; @infinite_parameter(inf_model, t in [0, 10], supports = [0, 5, 10])
t

julia&gt; @infinite_variable(inf_model, g(t) &gt;= 0)
g(t)

julia&gt; @hold_variable(inf_model, z, Bin)
z

julia&gt; @objective(inf_model, Min, 2z + support_sum(g, t))
2 z + sum(g(t))

julia&gt; @BDconstraint(inf_model, initial(t == 0), g == 1)
initial : g(t) = 1.0, ∀ t = 0

julia&gt; @constraint(inf_model, constr, g^2 - z &lt;= 42)
constr : g(t)² - z ≤ 42.0

julia&gt; print(inf_model)
Min 2 z + sum(g(t))
Subject to
 g(t) ≥ 0.0
 z binary
 g(t) = 1.0, ∀ t = 0
 g(t)² - z ≤ 42.0
 t ∈ [0, 10]</code></pre><p>Now we can make <code>JuMP</code> model containing the transcribed version of <code>inf_model</code> via <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}"><code>TranscriptionModel</code></a>:</p><pre><code class="language-julia-repl">julia&gt; trans_model = TranscriptionModel(inf_model)
A JuMP Model
Minimization problem with:
Variables: 4
Objective function type: GenericAffExpr{Float64,VariableRef}
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
`GenericQuadExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.ZeroOne`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; print(trans_model)
Min 2 z + g(support: 1) + g(support: 2) + g(support: 3)
Subject to
 g(support: 1) = 1.0
 g(support: 1)² - z ≤ 42.0
 g(support: 2)² - z ≤ 42.0
 g(support: 3)² - z ≤ 42.0
 g(support: 1) ≥ 0.0
 g(support: 2) ≥ 0.0
 g(support: 3) ≥ 0.0
 z binary</code></pre><p>Thus, we have a transcribed <code>JuMP</code> model. To be precise this actually a <code>TranscriptionModel</code> which is a <code>JuMP.Model</code> with some extra data stored in the <code>ext</code> field that retains the mapping between the transcribed variables and constraints and their infinite counterparts. Notice, that multiple finite variables have been introduced to discretize <code>g(t)</code> at supports 1, 2, and 3 which correspond to 0, 5, and 10 as can be queried by <a href="#InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}"><code>supports</code></a>:</p><pre><code class="language-julia-repl">julia&gt; supports(trans_model, g)
3-element Array{Tuple{Float64},1}:
 (0.0,)
 (5.0,)
 (10.0,)</code></pre><p>Also, notice how the constraints are transcribed in accordance with these supports except the initial condition which naturally is only invoked for the first support point. Furthermore, the transcription variable(s) of any variable associated with the infinite model can be determined via <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable"><code>transcription_variable</code></a>:</p><pre><code class="language-julia-repl">julia&gt; transcription_variable(trans_model, g)
3-element Array{VariableRef,1}:
 g(support: 1)
 g(support: 2)
 g(support: 3)

julia&gt; transcription_variable(trans_model, z)
z</code></pre><p>Similarly, the transcription constraints associated with infinite model constraints can be queried via <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint"><code>transcription_constraint</code></a> and the associated supports and infinite parameters can be found via <a href="#InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}"><code>supports</code></a> and <a href="#InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}"><code>parameter_refs</code></a>:</p><pre><code class="language-julia-repl">julia&gt; transcription_constraint(trans_model, initial)
1-element Array{ConstraintRef,1}:
 initial(Support: 1) : g(support: 1) = 1.0

julia&gt; transcription_constraint(trans_model, constr)
3-element Array{ConstraintRef,1}:
 constr(Support: 1) : g(support: 1)² - z ≤ 42.0
 constr(Support: 2) : g(support: 2)² - z ≤ 42.0
 constr(Support: 3) : g(support: 3)² - z ≤ 42.0

julia&gt; supports(trans_model, constr)
3-element Array{Tuple{Float64},1}:
 (0.0,)
 (5.0,)
 (10.0,)

julia&gt; parameter_refs(trans_model, constr)
(t,)</code></pre><p>Note the parameter reference tuple corresponds to the support tuples.</p><p>Now we have a transcribed <code>JuMP</code> model that can be optimized via traditional <code>JuMP</code> methods whose variables and constraints can be accessed using the methods mentioned above.</p><h2 id="Transcription-Theory-1"><a class="docs-heading-anchor" href="#Transcription-Theory-1">Transcription Theory</a><a class="docs-heading-anchor-permalink" href="#Transcription-Theory-1" title="Permalink"></a></h2><p>A given infinite dimensional optimization problem is parameterized according to infinite parameters following our abstraction. In general, most solution strategies transcribe the problem according to certain finite parameter values (supports) and thus represent the problem in terms of these supports (e.g., using discrete time points in dynamic optimization). This methodology can be generalized into the following steps:</p><ul><li>define supports for each infinite parameter if not already defined</li><li>expand any measures according to their underlying numerical representation</li><li>replace any remaining infinite variables with transcribed variables supported over each unique combination of the underlying parameter supports</li><li>replace any remaining infinite constraints with transcribed ones supported over all the unique support combinations stemming from the infinite parameters they depend on</li></ul><p>TO BE CONTINUED WITH AN EXAMPLE</p><h2 id="TranscriptionOpt-1"><a class="docs-heading-anchor" href="#TranscriptionOpt-1">TranscriptionOpt</a><a class="docs-heading-anchor-permalink" href="#TranscriptionOpt-1" title="Permalink"></a></h2><p><code>InfiniteOpt.TranscriptionOpt</code> is a submodule which principally implements <code>TranscriptionModel</code>s and its related access/modification methods. Thus, this section will detail what these are and how they work.</p><h3 id="TranscriptionModels-1"><a class="docs-heading-anchor" href="#TranscriptionModels-1">TranscriptionModels</a><a class="docs-heading-anchor-permalink" href="#TranscriptionModels-1" title="Permalink"></a></h3><p>A <code>TranscriptionModel</code> is simply a <code>JuMP.Model</code> whose <code>ext</code> field contains <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> which acts to map the transcribed model back to the original infinite model (e.g., map the variables and constraints). Such models are constructed via the <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}"><code>TranscriptionModel</code></a> constructors:</p><pre><code class="language-julia-repl">julia&gt; model1 = TranscriptionModel() # make an empty model
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; model2 = TranscriptionModel(inf_model) # generate from an InfiniteModel
A JuMP Model
Minimization problem with:
Variables: 4
Objective function type: GenericAffExpr{Float64,VariableRef}
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint
`GenericQuadExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 3 constraints
`VariableRef`-in-`MathOptInterface.ZeroOne`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre><p>Note that the all the normal <code>JuMP.Model</code> arguments can be used with both constructors such as specifying the optimizer. The first constructor is what <code>InfiniteOpt</code> uses to initialize the default <code>optimizer_model</code> attribute of <code>InfiniteModel</code>s. The second constructor is used to build the optimizer model when <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> is called directly or by <a href="../optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a>. Thus, second constructor serves as the principle tool for transcribing infinite models as it encapsulates all of the methods to transcribe measures, variables, and constraints.</p><h3 id="Queries-1"><a class="docs-heading-anchor" href="#Queries-1">Queries</a><a class="docs-heading-anchor-permalink" href="#Queries-1" title="Permalink"></a></h3><p>In this section we highlight a number of query methods that pertain <code>TranscriptionModel</code>s and their mappings. First, if the <code>optimizer_model</code> of an <code>InfiniteModel</code> is a <code>TranscriptionModel</code> it can be extracted via <a href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>transcription_model</code></a>:</p><pre><code class="language-julia-repl">julia&gt; transcription_model(inf_model)
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre><p>Here we observe that such a model is currently empty and hasn&#39;t been populated yet. Furthermore, we check that a <code>Model</code> is an <code>TranscriptionModel</code> via <a href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>is_transcription_model</code></a>:</p><pre><code class="language-julia-repl">julia&gt; is_transcription_model(model2)
true

julia&gt; is_transcription_model(Model())
false</code></pre><p>We can also extract the raw <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> object from a <code>TranscriptionModel</code> via <a href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>transcription_data</code></a>.</p><pre><code class="language-julia-repl">julia&gt; transcription_data(trans_model);</code></pre><p>Next we can retrieve the <code>JuMP</code> variable(s) for a particular <code>InfiniteOpt</code> variable via <a href="#InfiniteOpt.TranscriptionOpt.transcription_variable"><code>transcription_variable</code></a>. For finite variables, this will be a one to one mapping, and for infinite variables a list of supported variables will be returned in the order of the supports. Following the initial example in the basic usage section, this is done:</p><pre><code class="language-julia-repl">julia&gt; transcription_variable(trans_model, g)
3-element Array{VariableRef,1}:
 g(support: 1)
 g(support: 2)
 g(support: 3)

julia&gt; transcription_variable(trans_model, z)
z</code></pre><p>Note that if the <code>TranscriptionModel</code> is stored as the current <code>optimizer_model</code> then the first argument (specifying the <code>TranscriptionModel</code> can be omitted). However, in this case the argument is required since <code>trans_model</code> was built externally.</p><p>Similarly, the parameter supports corresponding to the transcription variables (in the case of transcribed infinite variables) can be queried via <a href="#InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}"><code>supports</code></a>:</p><pre><code class="language-julia-repl">julia&gt; supports(trans_model, g)
3-element Array{Tuple{Float64},1}:
 (0.0,)
 (5.0,)
 (10.0,)</code></pre><p>Again, the first argument can be dropped if this the <code>TranscriptionModel</code> of interest is stored in the <code>optimizer_model</code> field of the <code>InfiniteModel</code> as is the case when <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> or <a href="../optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> is invoked.</p><p>Likewise, <a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint"><code>transcription_constraint</code></a> and <a href="#InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}"><code>supports</code></a> can be used with constraints to find their transcribed equivalents in the <code>JuMP</code> model and determine their supports. In the case of infinite constraints, their parameter references can be determined <a href="#InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}"><code>parameter_refs</code></a> just like infinite variables.</p><h2 id="Datatypes-1"><a class="docs-heading-anchor" href="#Datatypes-1">Datatypes</a><a class="docs-heading-anchor-permalink" href="#Datatypes-1" title="Permalink"></a></h2><ul></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionData" href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>InfiniteOpt.TranscriptionOpt.TranscriptionData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TranscriptionData</code></pre><p>A DataType for storing the data mapping an <a href="../model/#InfiniteOpt.InfiniteModel"><code>InfiniteOpt.InfiniteModel</code></a> that has been transcribed to a regular <a href="../../JuMP/#JuMP.Model"><code>JuMP.Model</code></a> that contains the transcribed variables. This is stored in the <code>ext</code> field of a <code>JuMP.Model</code> to make what is called a <code>TranscriptionModel</code> via the <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}"><code>TranscriptionModel</code></a> constructor.</p><p><strong>Fields</strong></p><ul><li><code>infinite_to_vars::Dict{InfiniteOpt.InfiniteVariableRef,  Vector{JuMP.VariableRef}}</code>: Infinite variables to their transcribed variables.</li><li><code>hold_to_var::Dict{InfiniteOpt.HoldVariableRef, JuMP.VariableRef}</code>: Hold variables to model variables.</li><li><code>point_to_var::Dict{InfiniteOpt.PointVariableRef, JuMP.VariableRef}</code>: Point variables to model variables.</li><li><code>infvar_to_supports::Dict{InfiniteOpt.InfiniteVariableRef, Dict}</code>: Infinite variables to transcribed supports indexed by their numeric aliases.</li><li><code>infinite_to_constrs::Dict{InfiniteOpt.InfiniteConstraintRef, Vector{JuMP.ConstraintRef}}</code>: Infinite constraints to their transcribed constraints.</li><li><code>measure_to_constrs::Dict{InfiniteOpt.MeasureConstraintRef, Vector{JuMP.ConstraintRef}}</code>: Measure constraints to model constraints.</li><li><code>finite_to_constr::Dict{InfiniteOpt.FiniteConstraintRef, JuMP.ConstraintRef}</code>: Finite constraints to model constraints.</li><li><code>infconstr_to_supports::Dict{InfiniteOpt.InfiniteConstraintRef, Dict}</code>: Infinite constraints to the transcribed supports indxed by their numeric aliases.</li><li><code>measconstr_to_supports::Dict{InfiniteOpt.MeasureConstraintRef, Dict}</code>: Measure constraints to the transcribed supports indxed by their numeric aliases.</li><li><code>infconstr_to_params::Dict{InfiniteOpt.InfiniteConstraintRef, Tuple}</code>: Infinite constraints to the parameter tuples associated with each transcribed support.</li><li><code>measconstr_to_params::Dict{InfiniteOpt.MeasureConstraintRef, Tuple}</code>: Measure constraints to the parameter tuples associated with each transcribed support.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL1-L34">source</a></section></article><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{InfiniteConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{InfiniteConstraintRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>InfiniteOpt.TranscriptionOpt.is_transcription_model</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_constraint"><code>InfiniteOpt.TranscriptionOpt.transcription_constraint</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>InfiniteOpt.TranscriptionOpt.transcription_data</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>InfiniteOpt.TranscriptionOpt.transcription_model</code></a></li><li><a href="#InfiniteOpt.TranscriptionOpt.transcription_variable"><code>InfiniteOpt.TranscriptionOpt.transcription_variable</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_model" href="#InfiniteOpt.TranscriptionOpt.transcription_model"><code>InfiniteOpt.TranscriptionOpt.transcription_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_model(model::InfiniteOpt.InfiniteModel)::JuMP.Model</code></pre><p>Return the transcription model stored in <code>model</code> if that is what is stored in <code>model.optimizer_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/optimize.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}" href="#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}"><code>InfiniteOpt.build_optimizer_model!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.build_optimizer_model!(model::InfiniteOpt.InfiniteModel,
                                   key::Val{:TransData})</code></pre><p>Transcribe <code>model</code> and store it as a <code>TranscriptionModel</code> in the <code>model.optimizer_model</code> field which can be accessed with <code>transcription_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/optimize.jl#LL14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}" href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TranscriptionModel([optimizer_factory::JuMP.OptimizerFactory];
                   [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,
                    bridge_constraints::Bool = true])::JuMP.Model</code></pre><p>Return a <a href="../../JuMP/#JuMP.Model"><code>JuMP.Model</code></a> with <a href="#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>TranscriptionData</code></a> included in the <code>ext</code> data field. Accepts the same arguments as a typical JuMP <code>Model</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; TranscriptionModel()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL77-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}" href="#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TranscriptionModel(model::InfiniteModel, args...)</code></pre><p>Return a <code>TranscriptionModel</code> of <code>model</code>. This transcribes all of the variables, constraints, and objective.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; TranscriptionModel(model)
A JuMP Model
Feasibility problem with:
Variables: 130
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 25 constraints
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.GreaterThan{Float64}`: 100 constraint
`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 84 constraints
`VariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 40 constraints
`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 40 constraints
`VariableRef`-in-`MathOptInterface.LessThan{Float64}`: 25 constraints
`VariableRef`-in-`MathOptInterface.Integer`: 40 constraints
`VariableRef`-in-`MathOptInterface.ZeroOne`: 40 constraints
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/transcribe.jl#LL755-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.is_transcription_model" href="#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>InfiniteOpt.TranscriptionOpt.is_transcription_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_transcription_model(model::JuMP.Model)::Bool</code></pre><p>Return true if <code>model</code> is a <code>TranscriptionModel</code> or false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_transcription_model(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL109-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_data" href="#InfiniteOpt.TranscriptionOpt.transcription_data"><code>InfiniteOpt.TranscriptionOpt.transcription_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_data(model::JuMP.Model)::TranscriptionData</code></pre><p>Return the <code>TranscriptionData</code> from a <code>TranscriptionModel</code>. Errors if it is not a <code>TranscriptionModel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_variable" href="#InfiniteOpt.TranscriptionOpt.transcription_variable"><code>InfiniteOpt.TranscriptionOpt.transcription_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_variable(model::JuMP.Model,
                       vref::InfiniteOpt.InfOptVariableRef)</code></pre><p>Return the transcribed variable reference(s) corresponding to <code>vref</code>. Errors if no transcription variable is found.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; transcription_variable(trans_model, infvar)
2-element Array{VariableRef,1}:
 infvar(support: 1)
 infvar(support: 2)

julia&gt; transcription_variable(trans_model, gbvar)
gbvar</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL135-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}" href="#InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.supports(model::JuMP.Model,
                     vref::InfiniteOpt.InfiniteVariableRef)::Vector</code></pre><p>Return the support alias mapping associated with <code>vref</code> in the transcribed model. Errors if <code>vref</code> does not have transcribed variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL178-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{InfiniteVariableRef}" href="#InfiniteOpt.supports-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.supports(vref::InfiniteOpt.InfiniteVariableRef)::Vector</code></pre><p>Return the support alias mapping associated with <code>vref</code> in the transcription model. Errors if the infinite model does not contain a transcription model or if <code>vref</code> is not transcribed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; supports(vref)
Dict{Int64,Tuple{Float64}} with 2 entries:
  2 =&gt; (1.0,)
  1 =&gt; (0.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL193-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.TranscriptionOpt.transcription_constraint" href="#InfiniteOpt.TranscriptionOpt.transcription_constraint"><code>InfiniteOpt.TranscriptionOpt.transcription_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcription_constraint(model::JuMP.Model,
                         cref::InfiniteOpt.GeneralConstraintRef)</code></pre><p>Return the transcribed constraint reference(s) corresponding to <code>cref</code>. Errors if <code>cref</code> has not been transcribed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; transcription_constraint(trans_model, fin_con)
fin_con : x(support: 1) - y &lt;= 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL213-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}" href="#InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.supports(model::JuMP.Model,
                     cref::InfiniteOpt.GeneralConstraintRef)::Vector</code></pre><p>Return the support alias mappings associated with <code>cref</code>. Errors if <code>cref</code> is not transcribed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.supports-Tuple{InfiniteConstraintRef}" href="#InfiniteOpt.supports-Tuple{InfiniteConstraintRef}"><code>InfiniteOpt.supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.supports(cref::InfiniteOpt.GeneralConstraintRef)::Vector</code></pre><p>Return the support alias mappings associated with <code>cref</code>. Errors if <code>cref</code> is not transcribed or if the infinite model does not have a transcription model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; supports(cref)
Dict{Int64,Tuple{Float64}} with 2 entries:
  2 =&gt; (1.0,)
  1 =&gt; (0.0,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL280-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}" href="#InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.parameter_refs(model::JuMP.Model,
                           cref::InfiniteOpt.GeneralConstraintRef)::Tuple</code></pre><p>Return the a parameter reference tuple of all the parameters that parameterize <code>cref</code> and correspond to the supports. Errors if <code>cref</code> has not been transcribed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL304-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{InfiniteConstraintRef}" href="#InfiniteOpt.parameter_refs-Tuple{InfiniteConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.parameter_refs(cref::InfiniteOpt.GeneralConstraintRef)::Tuple</code></pre><p>Return the a parameter reference tuple of all the parameters that parameterize <code>cref</code> and correspond to the supports. Errors if <code>cref</code> has not been transcribed or if the infinite model does not have a transcription model associated with it.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; parameter_refs(cref)
(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/50b51e86f06e398e4ecaaeecf40df3391b1bdb13/src/TranscriptionOpt/model.jl#LL329-L341">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constraint/">« Constraints</a><a class="docs-footer-nextpage" href="../optimize/">Optimization »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 24 January 2020 23:04">Friday 24 January 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
