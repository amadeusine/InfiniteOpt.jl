<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Measures · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li class="is-active"><a class="tocitem" href>Measures</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Theoretical-Abstraction-1"><span>Theoretical Abstraction</span></a></li><li><a class="tocitem" href="#Preset-Evaluations-1"><span>Preset Evaluations</span></a></li><li><a class="tocitem" href="#Custom-Evaluations-1"><span>Custom Evaluations</span></a></li><li><a class="tocitem" href="#Expansion-1"><span>Expansion</span></a></li><li><a class="tocitem" href="#Reduced-Infinite-Variables-1"><span>Reduced Infinite Variables</span></a></li><li><a class="tocitem" href="#Datatypes-1"><span>Datatypes</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li><li><a class="tocitem" href="#MeasureEvalMethods-Methods-1"><span>MeasureEvalMethods Methods</span></a></li></ul></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li><a class="tocitem" href="../result/">Results</a></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Measures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Measures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/measure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Measures-1"><a class="docs-heading-anchor" href="#Measures-1">Measures</a><a class="docs-heading-anchor-permalink" href="#Measures-1" title="Permalink"></a></h1><p>A guide and manual for defining and using measures in <code>InfiniteOpt</code>. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  </p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><h2 id="Theoretical-Abstraction-1"><a class="docs-heading-anchor" href="#Theoretical-Abstraction-1">Theoretical Abstraction</a><a class="docs-heading-anchor-permalink" href="#Theoretical-Abstraction-1" title="Permalink"></a></h2><h2 id="Preset-Evaluations-1"><a class="docs-heading-anchor" href="#Preset-Evaluations-1">Preset Evaluations</a><a class="docs-heading-anchor-permalink" href="#Preset-Evaluations-1" title="Permalink"></a></h2><h2 id="Custom-Evaluations-1"><a class="docs-heading-anchor" href="#Custom-Evaluations-1">Custom Evaluations</a><a class="docs-heading-anchor-permalink" href="#Custom-Evaluations-1" title="Permalink"></a></h2><h2 id="Expansion-1"><a class="docs-heading-anchor" href="#Expansion-1">Expansion</a><a class="docs-heading-anchor-permalink" href="#Expansion-1" title="Permalink"></a></h2><h2 id="Reduced-Infinite-Variables-1"><a class="docs-heading-anchor" href="#Reduced-Infinite-Variables-1">Reduced Infinite Variables</a><a class="docs-heading-anchor-permalink" href="#Reduced-Infinite-Variables-1" title="Permalink"></a></h2><h2 id="Datatypes-1"><a class="docs-heading-anchor" href="#Datatypes-1">Datatypes</a><a class="docs-heading-anchor-permalink" href="#Datatypes-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a></li><li><a href="#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef,Array{#s4,1} where #s4&lt;:Number,Array{#s3,1} where #s3&lt;:AbstractArray}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s7,1} where #s7&lt;:Number,Array{#s4,1} where #s4&lt;:Number}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a></li><li><a href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a></li><li><a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a></li><li><a href="#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a></li><li><a href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractMeasureData" href="#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMeasureData</code></pre><p>An abstract type to define data for measures to define the behavior of <a href="#InfiniteOpt.Measure"><code>Measure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData" href="#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData &lt;: AbstractMeasureData</code></pre><p>A DataType for one dimensional measure abstraction data where the measure abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>parameter_ref::ParameterRef</code> The infinite parameter over which the                               integration occurs.</li><li><code>coefficients::Vector{&lt;:Number}</code> Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Vector{&lt;:Number}</code> Support points <span>$\tau_i$</span> for the above                              measure abstraction.</li><li><code>name::String</code> Name of the measure that will be implemented.</li><li><code>weight_function::Function</code> Weighting function <span>$w$</span> must map support value                             input value of type <code>Number</code> to a scalar value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL569-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MultiDiscreteMeasureData" href="#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiDiscreteMeasureData &lt;: AbstractMeasureData</code></pre><p>A DataType for multi-dimensional measure abstraction data where the measure abstraction is of the form: <span>$measure = \int_{\tau \in T} f(\tau) w(\tau) d\tau \approx \sum_{i = 1}^N \alpha_i f(\tau_i) w(\tau_i)$</span>.</p><p><strong>Fields</strong></p><ul><li><code>parameter_ref::JuMP.Containers.SparseAxisArray{&lt;:ParameterRef}</code> The infinite  parameters over which the integration occurs.</li><li><code>coefficients::Vector{&lt;:Number}</code> Coefficients <span>$\alpha_i$</span> for the above                                  measure abstraction.</li><li><code>supports::Vector{&lt;:JuMP.Containers.SparseAxisArray{&lt;:Number}}</code> Support points  <span>$\tau_i$</span> for the above measure abstraction.</li><li><code>name::String</code> Name of the measure that will be implemented.</li><li><code>weight_function::Function</code> Weighting function <span>$w$</span> must map a numerical                             support of type <code>JuMP.Containers.SparseAxisArray</code>                             to a scalar value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL612-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.Measure" href="#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Measure{T &lt;: JuMP.AbstractJuMPScalar, V &lt;: AbstractMeasureData}</code></pre><p>A DataType for measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>func::T</code> Infinite variable expression.</li><li><code>data::V</code> Data of the abstraction as described in a <code>AbstractMeasureData</code>           subtype.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureRef" href="#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeasureRef &lt;: FiniteVariableRef</code></pre><p>A DataType for referring to measure abstractions.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL375-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.AbstractReducedInfo" href="#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractReducedInfo</code></pre><p>An abstract type reduced variable information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedInfiniteInfo" href="#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedInfiniteInfo &lt;: AbstractReducedInfo</code></pre><p>A DataType for storing reduced infinite variable information.</p><p><strong>Fields</strong></p><ul><li><code>infinite_variable_ref::InfiniteVariableRef</code> The original infinite variable.</li><li><code>eval_supports::Dict{Int, Union{Number, JuMP.Containers.SparseAxisArray{&lt;:Number}}}</code> The original parameter tuple indices to the evaluation supports.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL533-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.ReducedInfiniteVariableRef" href="#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReducedInfiniteVariableRef &lt;: GeneralVariableRef</code></pre><p>A DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.</p><p><strong>Fields</strong></p><ul><li><code>model::InfiniteModel</code> Infinite model.</li><li><code>index::Int</code> Index of variable in model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/datatypes.jl#LL344-L354">source</a></section></article><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a></li><li><a href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a></li><li><a href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a></li><li><a href="#InfiniteOpt.expect"><code>InfiniteOpt.expect</code></a></li><li><a href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,AbstractMeasureData}"><code>InfiniteOpt.measure</code></a></li><li><a href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}"><code>InfiniteOpt.measure</code></a></li><li><a href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a></li><li><a href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a></li><li><a href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="#InfiniteOpt.support_sum"><code>InfiniteOpt.support_sum</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a></li><li><a href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a></li><li><a href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a></li><li><a href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a></li><li><a href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a></li><li><a href="#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expect" href="#InfiniteOpt.expect"><code>InfiniteOpt.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(expr::JuMP.AbstractJuMPScalar,
       [params::Union{ParameterRef, AbstractArray{&lt;:ParameterRef},
                      Nothing} = nothing];
       [num_supports::Int = 50,
        use_existing_supports::Bool = false])::MeasureRef</code></pre><p>Creates a measure that represents the expected value of an expression in a random parameter involved in the expression. Return the <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> of the created measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in Normal(0., 1.))
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = expect(f, num_supports = 2)
expect(f(x))

julia&gt; expand(meas)
0.5 f(0.6791074260357777) + 0.5 f(0.8284134829000359)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL572-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.support_sum" href="#InfiniteOpt.support_sum"><code>InfiniteOpt.support_sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">support_sum(expr::JuMP.AbstractJuMPScalar,
            [params::Union{ParameterRef, AbstractArray{&lt;:ParameterRef},
                           Nothing} = nothing])::MeasureRef</code></pre><p>Creates a measure that represents the sum of the expression over a parameter using its existing supports. Return the <a href="#InfiniteOpt.MeasureRef"><code>MeasureRef</code></a> of the created measure.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0, 1], supports = [0.3, 0.7])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = support_sum(f)
sum(f(x))

julia&gt; expand(meas)
f(0.3) + f(0.7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL609-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}" href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure(expr::JuMP.AbstractJuMPScalar,
        [params::Union{ParameterRef, AbstractArray{&lt;:ParameterRef},
                      Nothing} = nothing,
        lb::Union{Number, AbstractArray{&lt;:Number}, Nothing},
        ub::Union{Number, AbstractArray{&lt;:Number}, Nothing}];
        [eval_method::Function = mc_sampling, num_supports::Int = 50,
        weight_func::Function = _w, name = &quot;measure&quot;,
        use_existing_supports::Bool = false,
        call_from_expect::Bool = false])::MeasureRef</code></pre><p>Returns a measure reference that evaluates <code>expr</code> without using an object of <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> type. Similar to the main <a href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}"><code>measure</code></a> method, this function aims to implement measures of the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter (scalar or vector) and <span>$w$</span> is the weight function. This function serves as a flexible interface where users only have to provide necessary data about the integration. Instead of taking an <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> object as input, this function constructs the <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> object using some default numerical integration schemes. By default, the function will generate points by Monte Carlo sampling from the interval if the parameter is in an <a href="../parameter/#InfiniteOpt.IntervalSet"><code>IntervalSet</code></a>, or from the underlying distribution if the parameter is in a <a href="../parameter/#InfiniteOpt.DistributionSet"><code>DistributionSet</code></a>. If the expression involves multiple groups of parameters, the user needs to specify the parameter. The user can also specify lower bounds and upper bounds for the parameters, number of supports to generate, and the function to generate the supports with. The last option makes the method extendible for more schemes to generate supports.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(model, x in [0., 1.])
x

julia&gt; @infinite_variable(model, f(x))
f(x)

julia&gt; meas = measure(f, num_supports = 5)
(f(x))

julia&gt; expand(meas)
0.2 f(0.8236475079774124) + 0.2 f(0.9103565379264364) + 0.2 f(0.16456579813368521) + 0.2 f(0.17732884646626457) + 0.2 f(0.278880109331201)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL411-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s7,1} where #s7&lt;:Number,Array{#s4,1} where #s4&lt;:Number}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s7,1} where #s7&lt;:Number,Array{#s4,1} where #s4&lt;:Number}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(parameter_ref::ParameterRef,
                    coefficients::Vector{&lt;:Number},
                    supports::Vector{&lt;:Number}; name::String = &quot;measure&quot;,
                    weight_function::Function = w(t) = 1)::DiscreteMeasureData</code></pre><p>Returns a <code>DiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}"><code>measure</code></a>. This accepts input for a scalar (single) parameter. Note that <code>name</code> is used for printing purposes and a description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a>. Errors if supports are out bounds or an unequal number of supports and coefficients are given.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], name = &quot;example&quot;)
DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], &quot;example&quot;, InfiniteOpt._w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL158-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef,Array{#s4,1} where #s4&lt;:Number,Array{#s3,1} where #s3&lt;:AbstractArray}" href="#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef,Array{#s4,1} where #s4&lt;:Number,Array{#s3,1} where #s3&lt;:AbstractArray}"><code>InfiniteOpt.DiscreteMeasureData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DiscreteMeasureData(parameter_ref::AbstractArray{&lt;:ParameterRef},
                    coefficients::Vector{&lt;:Number},
                    supports::Vector{&lt;:AbstractArray{&lt;:Number}};
                    name::String = &quot;measure&quot;,
                    weight_function::Function = w(t) = 1
                    )::MultiDiscreteMeasureData</code></pre><p>Returns a <code>MultiDiscreteMeasureData</code> object that can be utilized to define measures using <a href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}"><code>measure</code></a>. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for <code>parameter_ref</code>. Note that <code>name</code> is used for printing purposes and a description of the other arguments is provided in the documentation for <a href="#InfiniteOpt.MultiDiscreteMeasureData"><code>MultiDiscreteMeasureData</code></a>. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or the parameters have different group IDs.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]], name = &quot;example&quot;);

julia&gt; typeof(data)
MultiDiscreteMeasureData</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL189-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure-Tuple{AbstractJuMPScalar,AbstractMeasureData}" href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,AbstractMeasureData}"><code>InfiniteOpt.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure(expr::JuMP.AbstractJuMPScalar, data::AbstractMeasureData)::MeasureRef</code></pre><p>Return a measure reference that evaluates <code>expr</code> using according to <code>data</code>. This is the preferred method for implementing measures which follow the form: <span>$\int_{p \in P} expr(p) w(p) dp$</span> where <span>$p$</span> is an infinite parameter (scalar or vector) and <span>$w$</span> is the weight function. The measure data <code>data</code> determines how the measure is to be evaluated. Typically, the <a href="#InfiniteOpt.DiscreteMeasureData"><code>DiscreteMeasureData</code></a> constructor can be used to for <code>data</code>. The variable expression <code>expr</code> can contain <code>InfiniteOpt</code> variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Errors if <code>expr</code> does not contain infinite variables, infinite parameters, or measure references. Also errors if the measure parameter specified in <code>data</code> is not in <code>expr</code> and is not in any the nested measure references. Typically, this is called inside of <a href="../../JuMP/#JuMP.@expression"><code>JuMP.@expression</code></a>, <a href="../../JuMP/#JuMP.@objective"><code>JuMP.@objective</code></a>, and <a href="../../JuMP/#JuMP.@constraint"><code>JuMP.@constraint</code></a> in a manner similar to <code>sum</code>. Note measures are not explicitly evaluated until <a href="../optimize/#InfiniteOpt.build_optimizer_model!"><code>build_optimizer_model!</code></a> is called or unless they are expanded via <a href="#InfiniteOpt.expand"><code>expand</code></a> or <a href="#InfiniteOpt.expand_all_measures!"><code>expand_all_measures!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2], name = &quot;name1&quot;);

julia&gt; xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]],
                                   name = &quot;name2&quot;);

julia&gt; constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)
name1(g(t) - s + 2) + s²

julia&gt; @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))
name1(g(t) - 1 + name2(T(t, x)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL356-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.add_measure" href="#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_measure(model::InfiniteModel, meas::Measure)::MeasureRef</code></pre><p>Add a measure to <code>model</code> and return the corresponding measure reference. This operates in a manner similar to <a href="../../JuMP/#JuMP.add_variable"><code>JuMP.add_variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_function" href="#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return the function associated with <code>mref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.measure_data" href="#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure_data(mref::MeasureRef)::AbstractMeasureData</code></pre><p>Return the measure data associated with <code>mref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_constraint(mref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL640-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_measure(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL655-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_objective-Tuple{MeasureRef}" href="#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_objective(vmref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used by the objective.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_objective(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL670-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.is_used-Tuple{MeasureRef}" href="#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_used(mref::MeasureRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>mref</code> is used in the model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_used(mref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL685-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, mref::MeasureRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> to return <code>Bool</code> whether <code>mref</code> is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,MeasureRef}" href="#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, mref::MeasureRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 z &gt;= 0.0
 measure(g(t)) == 0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]

julia&gt; delete(model, meas)

julia&gt; print(model)
Min z
Subject to
 z &gt;= 0.0
 0 == 0
 g(t) + z &gt;= 42.0
 g(0.5) == 0
 t in [0, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL700-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{MeasureRef}" href="#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(mref::MeasureRef)::String</code></pre><p>Extend <a href="../../JuMP/#JuMP.name-Tuple{VariableRef}"><code>JuMP.name</code></a> to return the name associated with a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.set_name-Tuple{MeasureRef,String}" href="#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.set_name(mref::MeasureRef, name::String)</code></pre><p>Extend <a href="../../JuMP/#JuMP.set_name-Tuple{VariableRef,String}"><code>JuMP.set_name</code></a> to specify the name of a measure reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measures.jl#LL15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand" href="#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar</code></pre><p>Return a JuMP scalar function containing the explicit expansion of the measure <code>mref</code>. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with <a href="#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,Union{Nothing, ParameterRef, AbstractArray{#s7,N} where N where #s7&lt;:ParameterRef},Union{Nothing, Number, AbstractArray{#s4,N} where N where #s4&lt;:Number},Union{Nothing, Number, AbstractArray{#s3,N} where N where #s3&lt;:Number}}"><code>measure</code></a> to expand measures on the fly.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending <code>InfiniteOpt._expand_measure</code> which should be of the form:</p><pre><code class="language-julia">InfiniteOpt._expand_measure(expr::AbstractJuMPScalar, data::AbstractMeasureData,
                            model::InfiniteModel, point_mapper::Function)</code></pre><p>See the source code in InfiniteOpt/src/measures.jl for examples of how to do this.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])

julia&gt; expr = expand(measure(g + z + T - h - 2, tdata))
0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measure_expansions.jl#LL353-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.expand_all_measures!" href="#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_all_measures!(model::InfiniteModel)</code></pre><p>Expand all of the measures used in the objective and/or constraints of <code>model</code>. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. Also errors if the expanded objective function is not finite.</p><p>This is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before <code>model</code> is translated into the new model. This method can also be extended to handle custom measure data types by extending <code>InfiniteOpt._expand_measure</code> which should be of the form:</p><pre><code class="language-julia">InfiniteOpt._expand_measure(expr::AbstractJuMPScalar, data::AbstractMeasureData,
                            model::InfiniteModel, point_mapper::Function)</code></pre><p>See the source code in InfiniteOpt/src/measures.jl for examples of how to do this.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(t)*t) + z
Subject to
 T(t, xi) &gt;= 0.0
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 measure(T(t, xi)) &gt;= 0.0, for all xi in [-1, 1]
 t in [0, 6]
 xi in Normal(μ=0.0, σ=1.0)

julia&gt; expand_all_measures!(model)

julia&gt; print(model)
Min 3 g(6) + z
Subject to
 T(t, xi) &gt;= 0.0
 z &gt;= 0.0
 g(t) + z &gt;= 42.0
 0.5 T(0, xi) + 0.5 T(6, xi) &gt;= 0.0, for all xi in [-1, 1]
 t in [0, 6]
 xi in Normal(μ=0.0, σ=1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/measure_expansions.jl#LL447-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infinite_variable_ref(vref::ReducedInfiniteVariableRef)::InfiniteVariableRef</code></pre><p>Return the <code>InfiniteVariableRef</code> associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; infinite_variable_ref(vref)
g(t, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL6-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_supports(vref::ReducedInfiniteVariableRef)::Dict</code></pre><p>Return the evaluation supports associated with the reduced infinite variable <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; eval_supports(vref)
Dict{Int64,Float64} with 1 entry:
  1 =&gt; 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameter_refs(vref::ReducedInfiniteVariableRef)::Tuple</code></pre><p>Return the <code>ParameterRef</code>(s) associated with the reduced infinite variable <code>vref</code>. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untracripted infinite variable except, the evaluated parameters are excluded.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; parameter_refs(vref)
(t,   [2]  =  x[2]
  [1]  =  x[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL39-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.name-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.name(vref::ReducedInfiniteVariableRef)::String</code></pre><p>Extend <code>JuMP.name</code> to return name of reduced infinite variable references. This is used when displaying measure expansions that contain such variables.</p><p><strong>Exanple</strong></p><pre><code class="language-julia">julia&gt; name(rvref)
g(1.25, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_lower_bound(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}"><code>JuMP.has_lower_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_lower_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.lower_bound(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.lower_bound-Tuple{VariableRef}"><code>JuMP.lower_bound</code></a> to return the lower bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a lower bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; lower_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL107-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.LowerBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}"><code>JuMP.LowerBoundRef</code></a> to extract a constraint reference for the lower bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = LowerBoundRef(vref)
var &gt;= 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL135-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_upper_bound(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}"><code>JuMP.has_upper_bound</code></a> to return a <code>Bool</code> whether the original infinite variable of <code>vref</code> has an upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; has_upper_bound(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL151-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.upper_bound(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.upper_bound-Tuple{VariableRef}"><code>JuMP.upper_bound</code></a> to return the upper bound of the original infinite variable of <code>vref</code>. Errors if <code>vref</code> doesn&#39;t have a upper bound.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; upper_bound(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL167-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.UpperBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}"><code>JuMP.UpperBoundRef</code></a> to extract a constraint reference for the upper bound of the original infinite variable of <code>vref</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = UpperBoundRef(vref)
var &lt;= 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL195-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_fixed(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_fixed-Tuple{VariableRef}"><code>JuMP.is_fixed</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_fixed(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL211-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.fix_value(vref::ReducedInfiniteVariableRef)::Float64</code></pre><p>Extend <a href="../../JuMP/#JuMP.fix_value-Tuple{VariableRef}"><code>JuMP.fix_value</code></a> to return the fix value of the original infinite variable of <code>vref</code>. Errors if variable is not fixed.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; fix_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL227-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.FixRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.FixRef-Tuple{VariableRef}"><code>JuMP.FixRef</code></a> to return the constraint reference of the fix constraint associated with the original infinite variable of <code>vref</code>. Errors <code>vref</code> is not fixed.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; cref = FixRef(vref)
var == 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL255-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.start_value-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.start_value(vref::ReducedInfiniteVariableRef)::Union{Nothing, Float64}</code></pre><p>Extend <a href="../../JuMP/#JuMP.start_value-Tuple{VariableRef}"><code>JuMP.start_value</code></a> to return starting value of the original infinite variable of <code>vref</code> if it has one. Returns <code>nothing</code> otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; start_value(vref)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL272-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_binary(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_binary-Tuple{VariableRef}"><code>JuMP.is_binary</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is binary.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_binary(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL288-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.BinaryRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.BinaryRef-Tuple{VariableRef}"><code>JuMP.BinaryRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be binary. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = BinaryRef(vref)
var binary</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL313-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_integer(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_integer-Tuple{VariableRef}"><code>JuMP.is_integer</code></a> to return <code>Bool</code> whether the original infinite variable of <code>vref</code> is integer.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_integer(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL330-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}" href="#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.IntegerRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef</code></pre><p>Extend <a href="../../JuMP/#JuMP.IntegerRef-Tuple{VariableRef}"><code>JuMP.IntegerRef</code></a> to return a constraint reference to the constraint constrainting the original infinite variable of <code>vref</code> to be integer. Errors if one does not exist.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cref = IntegerRef(vref)
var integer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL355-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_constraint(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a constraint.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_constraint(vref)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL372-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}" href="#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_by_measure(vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Return a <code>Bool</code> indicating if <code>vref</code> is used by a measure.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; used_by_measure(vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL387-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}" href="#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.is_valid(model::InfiniteModel, vref::ReducedInfiniteVariableRef)::Bool</code></pre><p>Extend <a href="../../JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}"><code>JuMP.is_valid</code></a> to accomodate reduced infinite variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; is_valid(model, vref)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL402-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}" href="#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.delete(model::InfiniteModel, vref::ReducedInfiniteVariableRef)</code></pre><p>Extend <a href="../../JuMP/#JuMP.delete-Tuple{Model,VariableRef}"><code>JuMP.delete</code></a> to delete reduced infinite variables and its dependencies. Errors if <code>vref</code> is invalid, meaning it has already been deleted or it belongs to another model.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; print(model)
Min measure(g(0, t)*t + g(1, t)*t) + z
Subject to
 z &gt;= 0.0
 g(0, t) + g(1, t) == 0
 g(x, t) + z &gt;= 42.0
 g(0.5, 0.5) == 0
 t in [0, 6]
 x in [0, 1]

julia&gt; delete(model, rvref1)

julia&gt; print(model)
Min measure(t + g(1, t)*t) + z
Subject to
 z &gt;= 0.0
 g(1, t) == 0
 g(x, t) + z &gt;= 42.0
 g(0.5, 0.5) == 0
 t in [0, 6]
 x in [0, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/reduced_variables.jl#LL418-L449">source</a></section></article><h2 id="MeasureEvalMethods-Methods-1"><a class="docs-heading-anchor" href="#MeasureEvalMethods-Methods-1">MeasureEvalMethods Methods</a><a class="docs-heading-anchor-permalink" href="#MeasureEvalMethods-Methods-1" title="Permalink"></a></h2><ul><li><a href="#InfiniteOpt.MeasureEvalMethods.gauss_hermite"><code>InfiniteOpt.MeasureEvalMethods.gauss_hermite</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.gauss_laguerre"><code>InfiniteOpt.MeasureEvalMethods.gauss_laguerre</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.gauss_legendre"><code>InfiniteOpt.MeasureEvalMethods.gauss_legendre</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>InfiniteOpt.MeasureEvalMethods.generate_measure_data</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.infinite_transform"><code>InfiniteOpt.MeasureEvalMethods.infinite_transform</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.mc_sampling-Tuple{Distribution{Univariate,S} where S&lt;:ValueSupport,ParameterRef,Int64}"><code>InfiniteOpt.MeasureEvalMethods.mc_sampling</code></a></li><li><a href="#InfiniteOpt.MeasureEvalMethods.mc_sampling-Tuple{Number,Number,Int64}"><code>InfiniteOpt.MeasureEvalMethods.mc_sampling</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.generate_measure_data" href="#InfiniteOpt.MeasureEvalMethods.generate_measure_data"><code>InfiniteOpt.MeasureEvalMethods.generate_measure_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_measure_data(params::Union{InfiniteOpt.ParameterRef,
                      AbstractArray{&lt;:InfiniteOpt.ParameterRef}},
                      num_supports::Int,
                      lb::Union{Number, JuMPC.SparseAxisArray, Nothing} = nothing,
                      ub::Union{Number, JuMPC.SparseAxisArray, Nothing} = nothing;
                      method::Function = mc_sampling, name::String = &quot;&quot;,
                      weight_func::Function = InfiniteOpt._w, kwargs...
                      )::InfiniteOpt.AbstractMeasureData</code></pre><p>Generate an <a href="#InfiniteOpt.AbstractMeasureData"><code>AbstractMeasureData</code></a> object that automatically generate supports based on a set of given information. The information is required to include parameters and number of supports. Other optional information to input includes lower and upper bounds, measure name, support generation method, and weight functions. The users could supply extra keyword arguments if necessary for their custom support generation methods.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; @infinite_parameter(m, x in [0., 1.])
x

julia&gt; measure_data = generate_measure_data(x, 3, 0.3, 0.7, method = gauss_legendre)
DiscreteMeasureData(x, [0.1111111111111111, 0.17777777777777776, 0.1111111111111111], [0.3450806661517033, 0.5, 0.6549193338482967], &quot;&quot;, InfiniteOpt._w)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.mc_sampling-Tuple{Number,Number,Int64}" href="#InfiniteOpt.MeasureEvalMethods.mc_sampling-Tuple{Number,Number,Int64}"><code>InfiniteOpt.MeasureEvalMethods.mc_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mc_sampling(lb::Union{JuMPC.SparseAxisArray, Number},
            ub::Union{JuMPC.SparseAxisArray, Number},
            num_supports::Int; kwargs...)::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated by Monte Carlo sampling from a uniform distribution between the lower and upper bounds provided.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (supps, coeffs) = mc_sampling(0., 1., 5)
([0.8236475079774124, 0.9103565379264364, 0.16456579813368521, 0.17732884646626457, 0.278880109331201], [0.2, 0.2, 0.2, 0.2, 0.2])

julia&gt; supps
5-element Array{Float64,1}:
 0.8236475079774124
 0.9103565379264364
 0.16456579813368521
 0.17732884646626457
 0.278880109331201</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL90-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.mc_sampling-Tuple{Distribution{Univariate,S} where S&lt;:ValueSupport,ParameterRef,Int64}" href="#InfiniteOpt.MeasureEvalMethods.mc_sampling-Tuple{Distribution{Univariate,S} where S&lt;:ValueSupport,ParameterRef,Int64}"><code>InfiniteOpt.MeasureEvalMethods.mc_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mc_sampling(dist::Distributions.NonMatrixDistribution,
            param::InfiniteOpt.ParameterRef,
            num_supports::Int; kwargs...)::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated by Monte Carlo sampling from a given distribution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dist = Normal(0., 1.)
Normal{Float64}(μ=0.0, σ=1.0)

julia&gt; @infinite_parameter(m, x in dist)
x

julia&gt; mc_sampling(dist, x, 10)
([0.6791074260357777, 0.8284134829000359, -0.3530074003005963, -0.13485387193052173, 0.5866170746331097, 0.29733585084941616, 0.06494754854834232, -0.10901738508171745, -0.514210390833322, 1.5743302021369892], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL137-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.gauss_legendre" href="#InfiniteOpt.MeasureEvalMethods.gauss_legendre"><code>InfiniteOpt.MeasureEvalMethods.gauss_legendre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_legendre(lb::Number, ub::Number, num_supports::Int; kwargs...)::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated using Gauss-Legendre quadrature method. This is useful for univariate parameter in a finite interval.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (supps, coeffs) = gauss_legendre(0., 1., 5)
([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319], [0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454])

julia&gt; supps
5-element Array{Float64,1}:
 0.04691007703066802
 0.23076534494715845
 0.5
 0.7692346550528415
 0.9530899229693319</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL183-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.gauss_hermite" href="#InfiniteOpt.MeasureEvalMethods.gauss_hermite"><code>InfiniteOpt.MeasureEvalMethods.gauss_hermite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_hermite(lb::Number, ub::Number, num_supports::Int; kwargs...)::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated using Gauss-Hermite quadrature method. This is useful for univariate parameter in an infinite interval.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (supps, coeffs) = gauss_hermite(-Inf, Inf, 5)
([-2.0201828704560856, -0.9585724646138196, -8.881784197001252e-16, 0.9585724646138196, 2.0201828704560856], [1.1814886255359844, 0.986580996751429, 0.9453087204829428, 0.986580996751429, 1.1814886255359844])

julia&gt; supps
5-element Array{Float64,1}:
 -2.0201828704560856
 -0.9585724646138196
 -8.881784197001252e-16
  0.9585724646138196
  2.0201828704560856</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL212-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.gauss_laguerre" href="#InfiniteOpt.MeasureEvalMethods.gauss_laguerre"><code>InfiniteOpt.MeasureEvalMethods.gauss_laguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_laguerre(lb::Number, ub::Number, num_supports::Int; kwargs...)::Tuple</code></pre><p>Return a tuple that contains supports and coefficients generated using Gauss-Laguerre quadrature method. This is useful for univariate parameter in a semi-infinite interval.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (supps, coeffs) = gauss_laguerre(-Inf, 0., 5)
([-0.2635603197181408, -1.413403059106515, -3.596425771040715, -7.08581000585883, -12.640800844275773], [0.6790940422077494, 1.638487873602747, 2.7694432423708255, 4.3156569009208585, 7.219186354354335])

julia&gt; supps
5-element Array{Float64,1}:
  -0.2635603197181408
  -1.413403059106515
  -3.596425771040715
  -7.08581000585883
 -12.640800844275773</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL244-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.MeasureEvalMethods.infinite_transform" href="#InfiniteOpt.MeasureEvalMethods.infinite_transform"><code>InfiniteOpt.MeasureEvalMethods.infinite_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">infinite_transform(lb::Number, ub::Number, num_supports::Int;
                   [sub_method::Function = mc_sampling,
                   transform_x::Function = _default_x,
                   transform_dx::Function = _default_dx,
                   t_lb::Number = -convert(Number, lb == -Inf &amp;&amp; ub == Inf),
                   t_ub::Number = 1., kwargs...])::Tuple</code></pre><p>Returns a tuple that contains supports and coefficients generated for a parameter in an infinite or semi-infinite interval. It works by transforming the original unbounded interval to a finite interval, on which a support generation method for finite intervals is applied. Then, the generated supports are transformed back to the original interval. The user is allowed to specify the support generation method for finite intevals to use, as well as the transform function. The default transform function is <span>$t \in [-\infty, \infty] \rightarrow x \in [-1, 1]: t(x) = \frac{t}{1-t^2}$</span> <span>$t \in [a, \infty] \rightarrow x \in [0, 1]: t(x) = a + \frac{t}{1-t}$</span> <span>$t \in [-\infty, a] \rightarrow x \in [0, 1]: t(x) = a - \frac{1-t}{t}$</span></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; (supps, coeffs) = infinite_transform(-Inf, Inf, 5, sub_method = gauss_legendre)
([-5.06704059565454, -0.7583532171678754, 0.0, 0.7583532171678754, 5.06704059565454], [13.490960583398396, 1.2245949721571516, 0.5688888888888889, 1.2245949721571516, 13.490960583398396])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/e46c83972d3b4eca05bb4628a50e53096c6b91b2/src/MeasureEvalMethods/methods.jl#LL285-L309">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../expression/">« Expressions</a><a class="docs-footer-nextpage" href="../objective/">Objectives »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 6 February 2020 03:03">Thursday 6 February 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
