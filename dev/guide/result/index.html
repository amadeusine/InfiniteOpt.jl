<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Results · InfiniteOpt.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="InfiniteOpt.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="InfiniteOpt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">InfiniteOpt.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../model/">Infinite Models</a></li><li><a class="tocitem" href="../parameter/">Infinite Parameters</a></li><li><a class="tocitem" href="../finite_parameter/">Finite Parameters</a></li><li><a class="tocitem" href="../variable/">Variables</a></li><li><a class="tocitem" href="../expression/">Expressions</a></li><li><a class="tocitem" href="../measure/">Measures</a></li><li><a class="tocitem" href="../objective/">Objectives</a></li><li><a class="tocitem" href="../constraint/">Constraints</a></li><li><a class="tocitem" href="../transcribe/">Model Transcription</a></li><li><a class="tocitem" href="../optimize/">Optimization</a></li><li class="is-active"><a class="tocitem" href>Results</a><ul class="internal"><li><a class="tocitem" href="#Overview-1"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage-1"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Termination-Queries-1"><span>Termination Queries</span></a></li><li><a class="tocitem" href="#Variable-Queries-1"><span>Variable Queries</span></a></li><li><a class="tocitem" href="#Constraint-Queries-1"><span>Constraint Queries</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><a class="tocitem" href="../../extensions/">Extensions</a></li><li><a class="tocitem" href="../../develop/">Development</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Results</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Results</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/guide/result.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Results-1"><a class="docs-heading-anchor" href="#Results-1">Results</a><a class="docs-heading-anchor-permalink" href="#Results-1" title="Permalink"></a></h1><p>A guide and manual to querying optimized <code>InfiniteOpt</code> models. The Methods section at the bottom comprises the manual and the above sections form the guide.</p><h2 id="Overview-1"><a class="docs-heading-anchor" href="#Overview-1">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-1" title="Permalink"></a></h2><p>So far we have covered defining, transforming, and optimizing <code>InfiniteModel</code>s. Now comes the point to extract information from our optimized model. This is done following extended versions of <code>JuMP</code>s querying functions in combination with the mapping information stored in the optimizer model. Thus, this page will walk through the use of these result query functions.</p><h2 id="Basic-Usage-1"><a class="docs-heading-anchor" href="#Basic-Usage-1">Basic Usage</a><a class="docs-heading-anchor-permalink" href="#Basic-Usage-1" title="Permalink"></a></h2><p>Let&#39;s revisit the example from the optimization page to get us started:</p><pre><code class="language-julia-repl">julia&gt; using InfiniteOpt, JuMP, Ipopt;

julia&gt; model = InfiniteModel(with_optimizer(Ipopt.Optimizer, print_level = 0));

julia&gt; @infinite_parameter(model, t in [0, 10], num_supports = 10);

julia&gt; @infinite_variable(model, x(t) &gt;= 0);

julia&gt; @hold_variable(model, z &gt;= 0);

julia&gt; @objective(model, Min, 2z);

julia&gt; @constraint(model, c1, z &gt;= x);

julia&gt; @BDconstraint(model, c2(t == 0), x == 42);

julia&gt; print(model)
Min 2 z
Subject to
 x(t) ≥ 0.0
 z ≥ 0.0
 z - x(t) ≥ 0.0
 x(t) = 42.0, ∀ t = 0
 t ∈ [0, 10]

julia&gt; optimize!(model)</code></pre><p>Now that the model has been optimized, let&#39;s find out what happened. To determine why the optimizer stopped, we can use <a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a> to report the corresponding <code>MathOptInterface</code> termination code (possible codes are explained <a href="http://www.juliaopt.org/JuMP.jl/stable/solutions/#MathOptInterface.TerminationStatusCode">here</a>.</p><pre><code class="language-julia-repl">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre><p>Here we see that our model was locally solved via Ipopt and that is why it stopped. Furthermore, we can query the primal and dual problem optimalities via <a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a> and <a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, respectively.</p><pre><code class="language-julia-repl">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1

julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>The possible statuses are detailed <a href="http://www.juliaopt.org/JuMP.jl/stable/solutions/#MathOptInterface.ResultStatusCode">here</a>. These results are useful in knowing if information can be drawn from the primal and/or dual and what it means. We can also verify that we indeed have answers via <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a> which indicates if our model has optimized variable values.</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>And indeed we do have values.</p><p>Now we can query the objective value via <a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a> which reports the optimal objective value.</p><pre><code class="language-julia-repl">julia&gt; objective_value(model)
83.99999998250514</code></pre><p>Great now we can inquire about variable values via <a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a>. First, let&#39;s retrieve the value of <code>z</code>:</p><pre><code class="language-julia-repl">julia&gt; value(z)
41.99999999125257</code></pre><p>We get a single value since <code>z</code> is a <code>HoldVariable</code> and therefore finite. Now let&#39;s retrieve the &quot;value&quot; of <code>x(t)</code> which is infinite with respect to <code>t</code>:</p><pre><code class="language-julia-repl">julia&gt; value(x)
10-element Array{Float64,1}:
 42.0
 20.999999995633615
 20.999999995633615
 20.999999995633615
 20.999999995633615
 20.999999995633615
 20.999999995633615
 20.999999995633615
 20.999999995633615
 20.999999995633615</code></pre><p>Notice here we obtain an array of values since these correspond to the transcribed finite (discretized) variables used to solve the problem. We obtain the corresponding support (discretized <code>t</code>) values via <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; supports(x)
10-element Array{Tuple{Float64},1}:
 (0.0,)
 (1.1111,)
 (2.2222,)
 (3.3333,)
 (4.4444,)
 (5.5556,)
 (6.6667,)
 (7.7778,)
 (8.8889,)
 (10.0,)</code></pre><p>There is 1-to-1 correspondence between these supports and the values reported above. Note that these are stored in tuples to facilitate multiple infinite parameter dependencies.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The values for an array of variables is obtained via the vectorized call of <code>value</code> following the syntax:</p><pre><code class="language-julia">value.(::AbstractArray{&lt;:GeneralVariableRef})</code></pre><p>This also holds true for many other methods in <code>InfiniteOpt</code>. For example, adding the dot also vectorizes <code>dual</code> and <code>set_binary</code>.</p></div></div><p>We can also query the dual of a constraint via <a href="#JuMP.dual-Tuple{GeneralConstraintRef}"><code>dual</code></a> if a model has duals available as indicated by <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true

julia&gt; dual(c1)
10-element Array{Float64,1}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p><code>c1</code> is an infinite constraint and thus we obtain the duals of its transcribed versions. The underlying infinite parameter(s) and support values are queried via <code>parameter_refs</code> and <code>supports</code>:</p><pre><code class="language-julia-repl">julia&gt; parameter_refs(c1)
(t,)

julia&gt; supports(c1)
10-element Array{Tuple{Float64},1}:
 (0.0,)
 (1.1111,)
 (2.2222,)
 (3.3333,)
 (4.4444,)
 (5.5556,)
 (6.6667,)
 (7.7778,)
 (8.8889,)
 (10.0,)</code></pre><p>These again all have a 1-to-1 correspondence.</p><h2 id="Termination-Queries-1"><a class="docs-heading-anchor" href="#Termination-Queries-1">Termination Queries</a><a class="docs-heading-anchor-permalink" href="#Termination-Queries-1" title="Permalink"></a></h2><p>Termination queries are those that question about how the infinite model was solved and what its optimized state entails. Programmatically, such queries on the <code>InfiniteModel</code> are simply routed to its optimizer model.</p><p>The commonly used queries include <a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>termination_status</code></a>, <a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>primal_status</code></a>, <a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>dual_status</code></a>, <a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>objective_value</code></a>, and <a href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>solve_time</code></a>. The first four are well exemplified in the Basic Usage section above and are helpful in quickly understanding the optimality status of a given model following the many possible statuses reported by <code>MathOptInterface</code> which are documented <a href="http://www.juliaopt.org/MathOptInterface.jl/stable/apimanual/#Solving-and-retrieving-the-results-1">here</a>. We use <code>solve_time</code> to determine the time in seconds used by the optimizer until it terminated its search.</p><pre><code class="language-julia-repl">julia&gt; solve_time(model)
0.004999876022338867</code></pre><p>Note that this query might not be supported with all solvers.</p><p>The above status queries are designed to report information in a consistent format irrespective of the chosen optimizer. However, <a href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>raw_status</code></a> will provide the optimality status verbatim as reported by the optimizer. Thus, following our example with Ipopt we obtain:</p><pre><code class="language-julia-repl">julia&gt; raw_status(model)
&quot;Solve_Succeeded&quot;</code></pre><p>Also, we obtain the best objective bound via <a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>objective_bound</code></a> which becomes particularly useful solutions that are suboptimal. However, this method is not supported by all optimizers and in this case Ipopt is one such optimizer.</p><h2 id="Variable-Queries-1"><a class="docs-heading-anchor" href="#Variable-Queries-1">Variable Queries</a><a class="docs-heading-anchor-permalink" href="#Variable-Queries-1" title="Permalink"></a></h2><p>Information about the optimized variables is gathered consistently in comparison to typical <code>JuMP</code> models. With <code>InfiniteModel</code>s this is done by querying the optimizer model and using its stored variable mappings to return the correct information. Thus, here the queries are extended to work with the specifics of the optimizer model to return the appropriate info.</p><p>First, we should verify that the optimized model in fact has variable values via <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>has_values</code></a>. In our example, we have:</p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre><p>So we have values readily available to be extracted.</p><p>Now <a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>value</code></a> can be used to query the values as shown above in the Basic Usage section. This works by calling the appropriate <a href="#InfiniteOpt.map_value"><code>map_value</code></a> defined by the optimizer model. For <code>TranscriptionModel</code>s <a href="#InfiniteOpt.map_value-Tuple{FiniteVariableRef,Val{:TransData}}"><code>map_value</code></a> and/or <a href="#InfiniteOpt.map_value-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>map_value</code></a> are used. Details on how to extend these methods for user-defined optimizer models is explained on the Extensions page.</p><p>Finally, the optimizer index of a variable is queried via <a href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>optimizer_index</code></a> which reports back the index of the variable as used in the <code>MathOptInterface</code> backend:</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(z)
MathOptInterface.VariableIndex(1)

julia&gt; optimizer_index(x)
10-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)
 MathOptInterface.VariableIndex(6)
 MathOptInterface.VariableIndex(7)
 MathOptInterface.VariableIndex(8)
 MathOptInterface.VariableIndex(9)
 MathOptInterface.VariableIndex(10)
 MathOptInterface.VariableIndex(11)</code></pre><p>As noted previously, an array is returned for <code>x(t)</code> in accordance with its transcription variables. In similar manner to <code>value</code>, this is enabled by appropriate versions of <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> enabled by <code>TranscriptionOpt</code>.</p><h2 id="Constraint-Queries-1"><a class="docs-heading-anchor" href="#Constraint-Queries-1">Constraint Queries</a><a class="docs-heading-anchor-permalink" href="#Constraint-Queries-1" title="Permalink"></a></h2><p>Like variables, a variety of information can be queried about constraints.</p><p>First, recall that constraints are stored in the form <code>function-in-set</code> where generally <code>function</code> contains the variables and coefficients and the set contains the relational operator and the constant value. With this understanding, we query the value of a constraint&#39;s <code>function</code> via <a href="#JuMP.value-Tuple{GeneralConstraintRef}"><code>value</code></a>:</p><pre><code class="language-julia-repl">julia&gt; constraint_object(c1).func # show the function expression of c1
z - x(t)

julia&gt; value(c1)
10-element Array{Float64,1}:
 -8.747427671096375e-9
 20.999999995618957
 20.999999995618957
 20.999999995618957
 20.999999995618957
 20.999999995618957
 20.999999995618957
 20.999999995618957
 20.999999995618957
 20.999999995618957</code></pre><p>Again, we obtain an array of values since <code>c1</code> is infinite due to its dependence on <code>x(t)</code>. Behind the scenes this is implemented via the appropriate extensions of <a href="#InfiniteOpt.map_value"><code>map_value</code></a> in <code>TranscriptionOpt</code> by default.</p><p>Next the optimizer index(es) of the transcribed constraints in the <code>MathOptInterface</code> backend provided via <a href="#JuMP.optimizer_index-Tuple{GeneralConstraintRef}"><code>optimizer_index</code></a>.</p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
10-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(5)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(6)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(7)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(8)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(9)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(10)</code></pre><p>Here 10 indices are given in accordance with the transcription constraints. The mapping between these and the original infinite constraints is managed via the appropriate extensions of <a href="#InfiniteOpt.map_optimizer_index"><code>map_optimizer_index</code></a> in <code>TranscriptionOpt</code>.</p><p>We can also query dual information from our constraints if it is available. First, we should verify that dual information is available via <a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>has_duals</code></a>:</p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true</code></pre><p>Now we can query the duals via <a href="#JuMP.dual-Tuple{GeneralConstraintRef}"><code>dual</code></a>.</p><pre><code class="language-julia-repl">julia&gt; dual(c1)
10-element Array{Float64,1}:
 1.9999999988666093
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10
 1.1930560126841273e-10</code></pre><p>Here we obtain the optimal dual values for each transcribed version of <code>c1</code>. This is enabled via the proper extensions of <a href="#InfiniteOpt.map_dual"><code>map_dual</code></a> in <code>TranscriptionOpt</code> by default.</p><p>Finally, we query the shadow price of a constraint via <a href="#JuMP.shadow_price-Tuple{GeneralConstraintRef}"><code>shadow_price</code></a>. This denotes the change in the objective value due to an infinitesimal relaxation of the constraint. For <code>c1</code> we get:</p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
10-element Array{Float64,1}:
 -1.9999999988666093
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10
 -1.1930560126841273e-10</code></pre><p>Similarly, the mapping to the transcription constraints is enabled via the appropriate version of <a href="#InfiniteOpt.map_shadow_price"><code>map_shadow_price</code></a>.</p><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><ul><li><a href="#JuMP.dual-Tuple{GeneralConstraintRef}"><code>JuMP.dual</code></a></li><li><a href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a></li><li><a href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a></li><li><a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a></li><li><a href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a></li><li><a href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a></li><li><a href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="#JuMP.optimizer_index-Tuple{GeneralConstraintRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a></li><li><a href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a></li><li><a href="#JuMP.shadow_price-Tuple{GeneralConstraintRef}"><code>JuMP.shadow_price</code></a></li><li><a href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a></li><li><a href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a></li><li><a href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a></li><li><a href="#JuMP.value-Tuple{GeneralConstraintRef}"><code>JuMP.value</code></a></li><li><a href="#InfiniteOpt.map_dual-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_dual</code></a></li><li><a href="#InfiniteOpt.map_dual-Tuple{InfiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_dual</code></a></li><li><a href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index-Tuple{FiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index-Tuple{GeneralConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="#InfiniteOpt.map_shadow_price-Tuple{InfiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="#InfiniteOpt.map_shadow_price-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="#InfiniteOpt.map_value-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="#InfiniteOpt.map_value-Tuple{GeneralConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a></li><li><a href="#InfiniteOpt.map_value-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="#InfiniteOpt.map_value-Tuple{FiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="JuMP.termination_status-Tuple{InfiniteModel}" href="#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.termination_status(model::InfiniteModel)</code></pre><p>Return the reason why the solver stopped (i.e., the MathOptInterface model attribute <code>TerminationStatus</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; termination_status(model)
LOCALLY_SOLVED::TerminationStatusCode = 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.raw_status-Tuple{InfiniteModel}" href="#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.raw_status(model::InfiniteModel)</code></pre><p>Return the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute <code>RawStatusString</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; raw_status(model) # Ipopt
&quot;Solve_Succeeded&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.primal_status-Tuple{InfiniteModel}" href="#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> JuMP.primal_status(model::InfiniteModel)</code></pre><p>Return the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute <code>PrimalStatus</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; primal_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL33-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual_status-Tuple{InfiniteModel}" href="#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual_status(model::InfiniteModel)</code></pre><p>Return the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute <code>DualStatus</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual_status(model)
FEASIBLE_POINT::ResultStatusCode = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL49-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.solve_time-Tuple{InfiniteModel}" href="#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.solve_time(model::InfiniteModel)</code></pre><p>If available, returns the solve time (in seconds) reported by the solver. Returns &quot;ArgumentError: ModelLike of type <code>Solver.Optimizer</code> does not support accessing the attribute MathOptInterface.SolveTime()&quot; if the attribute is not implemented.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; solve_time(model)
0.004999876022338867</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL65-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_values-Tuple{InfiniteModel}" href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_values(model::InfiniteModel)</code></pre><p>Return <code>true</code> if the solver has a primal solution available to query, otherwise return <code>false</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_values(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL83-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.has_duals-Tuple{InfiniteModel}" href="#JuMP.has_duals-Tuple{InfiniteModel}"><code>JuMP.has_duals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.has_duals(model::InfiniteModel)</code></pre><p>Return <code>true</code> if the solver has a dual solution available to query, otherwise return <code>false</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; has_duals(model)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL97-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_bound-Tuple{InfiniteModel}" href="#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_bound(model::InfiniteModel)::Float64</code></pre><p>Return the best known bound on the optimal objective value after a call to <code>optimize!(model)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; objective_bound(model)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL111-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.objective_value-Tuple{InfiniteModel}" href="#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.objective_value(model::InfiniteModel)::Float64</code></pre><p>Return the objective value after a call to <code>optimize!(model)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; objective_value(model)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL127-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{GeneralVariableRef}" href="#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(vref::GeneralVariableRef)</code></pre><p>Get the value of this variable in the result returned by a solver. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(z)
42.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.value-Tuple{GeneralConstraintRef}" href="#JuMP.value-Tuple{GeneralConstraintRef}"><code>JuMP.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.value(cref::GeneralConstraintRef)</code></pre><p>Get the value of this constraint in the result returned by a solver. Use <a href="#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a> to check if a result exists before asking for values. This returns the primal value of the constraint function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; value(c1)
4-element Array{Float64,1}:
 -0.0
 20.9
 20.9
 20.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL167-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value" href="#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_value(vref::GeneralVariableRef, key)</code></pre><p>Map the value of <code>vref</code> to its counterpart in the optimizer model type is distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value-Tuple{FiniteVariableRef,Val{:TransData}}" href="#InfiniteOpt.map_value-Tuple{FiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_value(fvref::InfiniteOpt.FiniteVariableRef,
                      key::Val{:TransData})</code></pre><p>Map the value of the appropriate transcription variable in the transcription model to <code>fvref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value-Tuple{InfiniteVariableRef,Val{:TransData}}" href="#InfiniteOpt.map_value-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_value(ivref::InfiniteOpt.InfiniteVariableRef,
                      key::Val{:TransData})</code></pre><p>Map the value of the appropriate transcription variables in the transcription model to <code>ivref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value-Tuple{FiniteConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_value-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_value(fcref::InfiniteOpt.FiniteConstraintRef,
                      key::Val{:TransData})</code></pre><p>Map the value of the appropriate transcription constraint function in the transcription model to <code>fcref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_value-Tuple{GeneralConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_value-Tuple{GeneralConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_value(icref::InfiniteOpt.GeneralConstraintRef,
                      key::Val{:TransData})</code></pre><p>Map the value of the appropriate transcription constraint functions in the transcription model to <code>icref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{GeneralVariableRef}" href="#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(vref::GeneralVariableRef)</code></pre><p>Return the index of the variables that corresponds to <code>vref</code> in the optimizer model. It throws <a href="../../JuMP/#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> if no optimizer is set and throws an <code>ErrorException</code> if the optimizer is set but is not attached.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(x)
4-element Array{MathOptInterface.VariableIndex,1}:
 MathOptInterface.VariableIndex(2)
 MathOptInterface.VariableIndex(3)
 MathOptInterface.VariableIndex(4)
 MathOptInterface.VariableIndex(5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL199-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimizer_index-Tuple{GeneralConstraintRef}" href="#JuMP.optimizer_index-Tuple{GeneralConstraintRef}"><code>JuMP.optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.optimizer_index(cref::GeneralConstraintRef)</code></pre><p>Return the index of the constraints that corresponds to <code>cref</code> in the optimizer model. It throws <a href="../../JuMP/#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> if no optimizer is set and throws an <code>ErrorException</code> if the optimizer is set but is not attached.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; optimizer_index(c1)
4-element Array{MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}},1}:
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(1)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(2)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(3)
 MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64},MathOptInterface.GreaterThan{Float64}}(4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL221-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index" href="#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_optimizer_index(ref, key)</code></pre><p>Map the optimizer index of <code>ref</code> to its counterpart in the optimizer model type distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>. Here <code>ref</code> need refer to methods for both variable references and constraint references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL189-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index-Tuple{FiniteVariableRef,Val{:TransData}}" href="#InfiniteOpt.map_optimizer_index-Tuple{FiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_optimizer_index(fvref::InfiniteOpt.FiniteVariableRef,
                                key::Val{:TransData})</code></pre><p>Map the optimizer model index of the appropriate transcription variable in the transcription model to <code>fvref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index-Tuple{InfiniteVariableRef,Val{:TransData}}" href="#InfiniteOpt.map_optimizer_index-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_optimizer_index(ivref::InfiniteOpt.InfiniteVariableRef,
                                key::Val{:TransData})</code></pre><p>Map the optimizer model index of the appropriate transcription variables in the transcription model to <code>ivref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index-Tuple{FiniteConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_optimizer_index-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_optimizer_index(fcref::InfiniteOpt.FiniteConstraintRef,
                                key::Val{:TransData})</code></pre><p>Map the optimizer model index of the appropriate transcription constraint in the transcription model to <code>fcref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_optimizer_index-Tuple{GeneralConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_optimizer_index-Tuple{GeneralConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_optimizer_index(cref::InfiniteOpt.GeneralConstraintRef,
                                key::Val{:TransData})</code></pre><p>Map the optimizer model index of the appropriate transcription constraints in the transcription model to <code>cref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.dual-Tuple{GeneralConstraintRef}" href="#JuMP.dual-Tuple{GeneralConstraintRef}"><code>JuMP.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.dual(cref::GeneralConstraintRef)</code></pre><p>Get the dual value of this constraint in the result returned by a solver. Use <code>has_dual</code> to check if a result exists before asking for values. See also <a href="#JuMP.shadow_price-Tuple{GeneralConstraintRef}"><code>JuMP.shadow_price</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; dual(c1)
4-element Array{Float64,1}:
 -42.0
 -42.0
 32.3
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL251-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_dual" href="#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_dual(cref::GeneralConstraintRef, key)</code></pre><p>Map the dual of <code>cref</code> to its counterpart in the optimizer model type distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_dual-Tuple{FiniteConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_dual-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_dual(fcref::InfiniteOpt.FiniteConstraintRef,
                     key::Val{:TransData})</code></pre><p>Map the dual of the appropriate transcription constraint in the transcription model to <code>fcref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_dual-Tuple{InfiniteConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_dual-Tuple{InfiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_dual(icref::InfiniteOpt.InfiniteConstraintRef,
                     key::Val{:TransData})</code></pre><p>Map the duals of the appropriate transcription constraints in the transcription model to <code>icref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.shadow_price-Tuple{GeneralConstraintRef}" href="#JuMP.shadow_price-Tuple{GeneralConstraintRef}"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JuMP.shadow_price(cref::GeneralConstraintRef)</code></pre><p>The change in the objective from an infinitesimal relaxation of the constraint. This value is computed from <a href="#JuMP.dual-Tuple{GeneralConstraintRef}"><code>JuMP.dual</code></a> and can be queried only when <code>has_duals</code> is <code>true</code> and the objective sense is <code>MIN_SENSE</code> or <code>MAX_SENSE</code> (not <code>FEASIBILITY_SENSE</code>). For linear constraints, the shadow prices differ at most in sign from the <code>dual</code> value depending on the objective sense.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; shadow_price(c1)
4-element Array{Float64,1}:
 42.0
 42.0
 -32.3
 -0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL288-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_shadow_price" href="#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_shadow_price(cref::GeneralConstraintRef, key)</code></pre><p>Map the shadow price of <code>cref</code> to its counterpart in the optimizer model type distininguished by its extension key <code>key</code> as type <code>Val{ext_key_name}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/results.jl#LL280-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_shadow_price-Tuple{FiniteConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_shadow_price-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_shadow_price(fcref::InfiniteOpt.FiniteConstraintRef,
                             key::Val{:TransData})</code></pre><p>Map the shadow price of the appropriate transcription constraint in the transcription model to <code>fcref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfiniteOpt.map_shadow_price-Tuple{InfiniteConstraintRef,Val{:TransData}}" href="#InfiniteOpt.map_shadow_price-Tuple{InfiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_shadow_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InfiniteOpt.map_shadow_price(icref::InfiniteOpt.InfiniteConstraintRef,
                             key::Val{:TransData})</code></pre><p>Map the shadow prices of the appropriate transcription constraints in the transcription model to <code>icref</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/f251b83c614cbaa0f204c808119609b226d43266/src/TranscriptionOpt/results.jl#LL144-L150">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../optimize/">« Optimization</a><a class="docs-footer-nextpage" href="../../examples/">Examples »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 10 February 2020 23:25">Monday 10 February 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
