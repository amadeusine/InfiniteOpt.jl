<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · InfiniteOpt.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="InfiniteOpt.jl logo"/></a><h1>InfiniteOpt.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../guide/install/">Installation</a></li><li><a class="toctext" href="../guide/model/">Infinite Models</a></li><li><a class="toctext" href="../guide/parameter/">Infinite Parameters</a></li><li><a class="toctext" href="../guide/variable/">Variables</a></li><li><a class="toctext" href="../guide/expression/">Expressions</a></li><li><a class="toctext" href="../guide/measure/">Measures</a></li><li><a class="toctext" href="../guide/objective/">Objectives</a></li><li><a class="toctext" href="../guide/constraint/">Constraints</a></li><li><a class="toctext" href="../guide/transcribe/">Model Transcription</a></li><li><a class="toctext" href="../guide/optimize/">Optimization</a></li><li><a class="toctext" href="../guide/result/">Results</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li class="current"><a class="toctext" href>Library</a><ul class="internal"><li><a class="toctext" href="#Method,-DataType,-and-Macro-Index-1">Method, DataType, and Macro Index</a></li><li><a class="toctext" href="#JuMP-Documentation-1">JuMP Documentation</a></li></ul></li><li><a class="toctext" href="../extensions/">Extensions</a></li><li><a class="toctext" href="../develop/">Development</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Library</a></li></ul><a class="edit-page" href="https://github.com/pulsipher/InfiniteOpt.jl/blob/master/docs/src/library.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Library</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Method,-DataType,-and-Macro-Index-1" href="#Method,-DataType,-and-Macro-Index-1">Method, DataType, and Macro Index</a></h2><ul><li><a href="../guide/parameter/#InfiniteOpt.AbstractInfiniteSet"><code>InfiniteOpt.AbstractInfiniteSet</code></a></li><li><a href="../guide/measure/#InfiniteOpt.AbstractMeasureData"><code>InfiniteOpt.AbstractMeasureData</code></a></li><li><a href="../guide/measure/#InfiniteOpt.AbstractReducedInfo"><code>InfiniteOpt.AbstractReducedInfo</code></a></li><li><a href="../guide/constraint/#InfiniteOpt.BoundedScalarConstraint"><code>InfiniteOpt.BoundedScalarConstraint</code></a></li><li><a href="../guide/measure/#InfiniteOpt.DiscreteMeasureData"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="../guide/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s4,N} where N where #s4&lt;:ParameterRef,Array{#s3,1} where #s3&lt;:Number,Array{#s5,1} where #s5&lt;:AbstractArray}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="../guide/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s4,1} where #s4&lt;:Number,Array{#s3,1} where #s3&lt;:Number}"><code>InfiniteOpt.DiscreteMeasureData</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.DistributionSet"><code>InfiniteOpt.DistributionSet</code></a></li><li><a href="../guide/constraint/#InfiniteOpt.FiniteConstraintRef"><code>InfiniteOpt.FiniteConstraintRef</code></a></li><li><a href="../guide/variable/#InfiniteOpt.FiniteVariableRef"><code>InfiniteOpt.FiniteVariableRef</code></a></li><li><a href="../guide/constraint/#InfiniteOpt.GeneralConstraintRef"><code>InfiniteOpt.GeneralConstraintRef</code></a></li><li><a href="../guide/variable/#InfiniteOpt.GeneralVariableRef"><code>InfiniteOpt.GeneralVariableRef</code></a></li><li><a href="../guide/variable/#InfiniteOpt.GlobalVariable"><code>InfiniteOpt.GlobalVariable</code></a></li><li><a href="../guide/variable/#InfiniteOpt.GlobalVariableRef"><code>InfiniteOpt.GlobalVariableRef</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.InfOptParameter"><code>InfiniteOpt.InfOptParameter</code></a></li><li><a href="../guide/variable/#InfiniteOpt.InfOptVariable"><code>InfiniteOpt.InfOptVariable</code></a></li><li><a href="../guide/constraint/#InfiniteOpt.InfiniteConstraintRef"><code>InfiniteOpt.InfiniteConstraintRef</code></a></li><li><a href="../guide/model/#InfiniteOpt.InfiniteModel-Tuple{}"><code>InfiniteOpt.InfiniteModel</code></a></li><li><a href="../guide/model/#InfiniteOpt.InfiniteModel"><code>InfiniteOpt.InfiniteModel</code></a></li><li><a href="../guide/variable/#InfiniteOpt.InfiniteVariable"><code>InfiniteOpt.InfiniteVariable</code></a></li><li><a href="../guide/variable/#InfiniteOpt.InfiniteVariableRef"><code>InfiniteOpt.InfiniteVariableRef</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.IntervalSet-Tuple{Number,Number}"><code>InfiniteOpt.IntervalSet</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.IntervalSet"><code>InfiniteOpt.IntervalSet</code></a></li><li><a href="../guide/measure/#InfiniteOpt.Measure"><code>InfiniteOpt.Measure</code></a></li><li><a href="../guide/constraint/#InfiniteOpt.MeasureConstraintRef"><code>InfiniteOpt.MeasureConstraintRef</code></a></li><li><a href="../guide/variable/#InfiniteOpt.MeasureFiniteVariableRef"><code>InfiniteOpt.MeasureFiniteVariableRef</code></a></li><li><a href="../guide/measure/#InfiniteOpt.MeasureRef"><code>InfiniteOpt.MeasureRef</code></a></li><li><a href="../guide/measure/#InfiniteOpt.MultiDiscreteMeasureData"><code>InfiniteOpt.MultiDiscreteMeasureData</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.ParameterRef"><code>InfiniteOpt.ParameterRef</code></a></li><li><a href="../guide/variable/#InfiniteOpt.PointVariable"><code>InfiniteOpt.PointVariable</code></a></li><li><a href="../guide/variable/#InfiniteOpt.PointVariableRef"><code>InfiniteOpt.PointVariableRef</code></a></li><li><a href="../guide/measure/#InfiniteOpt.ReducedInfiniteInfo"><code>InfiniteOpt.ReducedInfiniteInfo</code></a></li><li><a href="../guide/measure/#InfiniteOpt.ReducedInfiniteVariableRef"><code>InfiniteOpt.ReducedInfiniteVariableRef</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionData"><code>InfiniteOpt.TranscriptionOpt.TranscriptionData</code></a></li><li><a href="#JuMP.Model-Tuple{OptimizerFactory}"><code>JuMP.Model</code></a></li><li><a href="#JuMP.Model-Tuple{}"><code>JuMP.Model</code></a></li><li><a href="#JuMP.Model"><code>JuMP.Model</code></a></li><li><a href="#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a></li><li><a href="#JuMP.PSDCone"><code>JuMP.PSDCone</code></a></li><li><a href="#JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a></li><li><a href="#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a></li><li><a href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}"><code>InfiniteOpt.TranscriptionOpt.TranscriptionModel</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.is_transcription_model"><code>InfiniteOpt.TranscriptionOpt.is_transcription_model</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_constraint"><code>InfiniteOpt.TranscriptionOpt.transcription_constraint</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_data"><code>InfiniteOpt.TranscriptionOpt.transcription_data</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_model"><code>InfiniteOpt.TranscriptionOpt.transcription_model</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_variable"><code>InfiniteOpt.TranscriptionOpt.transcription_variable</code></a></li><li><a href="../guide/measure/#InfiniteOpt.add_measure"><code>InfiniteOpt.add_measure</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.add_parameter"><code>InfiniteOpt.add_parameter</code></a></li><li><a href="../guide/variable/#InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s4,N} where N where #s4&lt;:ParameterRef}}"><code>InfiniteOpt.add_parameter_ref</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s4,1} where #s4&lt;:Number}}"><code>InfiniteOpt.add_supports</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.all_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.all_parameters</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.build_optimizer_model!"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}"><code>InfiniteOpt.build_optimizer_model!</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.build_parameter"><code>InfiniteOpt.build_parameter</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.delete_supports-Tuple{ParameterRef}"><code>InfiniteOpt.delete_supports</code></a></li><li><a href="../guide/measure/#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.eval_supports</code></a></li><li><a href="../guide/measure/#InfiniteOpt.expand"><code>InfiniteOpt.expand</code></a></li><li><a href="../guide/measure/#InfiniteOpt.expand_all_measures!"><code>InfiniteOpt.expand_all_measures!</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.group_id-Tuple{ParameterRef}"><code>InfiniteOpt.group_id</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.group_id-Tuple{AbstractArray{#s4,N} where N where #s4&lt;:ParameterRef}"><code>InfiniteOpt.group_id</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.has_supports-Tuple{ParameterRef}"><code>InfiniteOpt.has_supports</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.infinite_set-Tuple{ParameterRef}"><code>InfiniteOpt.infinite_set</code></a></li><li><a href="../guide/variable/#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="../guide/measure/#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.infinite_variable_ref</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.is_independent-Tuple{ParameterRef}"><code>InfiniteOpt.is_independent</code></a></li><li><a href="../guide/measure/#InfiniteOpt.is_used-Tuple{MeasureRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="../guide/variable/#InfiniteOpt.is_used-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.is_used</code></a></li><li><a href="../guide/variable/#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.is_used-Tuple{ParameterRef}"><code>InfiniteOpt.is_used</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_dual-Tuple{InfiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_dual</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_dual-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_dual</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_dual"><code>InfiniteOpt.map_dual</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_optimizer_index-Tuple{FiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_optimizer_index"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_optimizer_index-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_optimizer_index-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_optimizer_index-Tuple{GeneralConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_optimizer_index</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_shadow_price"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_shadow_price-Tuple{InfiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_shadow_price-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_shadow_price</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_value"><code>InfiniteOpt.map_value</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_value-Tuple{InfiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_value-Tuple{GeneralConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_value-Tuple{FiniteConstraintRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="../guide/result/#InfiniteOpt.map_value-Tuple{FiniteVariableRef,Val{:TransData}}"><code>InfiniteOpt.map_value</code></a></li><li><a href="../guide/measure/#InfiniteOpt.measure"><code>InfiniteOpt.measure</code></a></li><li><a href="../guide/measure/#InfiniteOpt.measure_data"><code>InfiniteOpt.measure_data</code></a></li><li><a href="../guide/measure/#InfiniteOpt.measure_function"><code>InfiniteOpt.measure_function</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.num_parameters-Tuple{InfiniteModel}"><code>InfiniteOpt.num_parameters</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.num_supports-Tuple{ParameterRef}"><code>InfiniteOpt.num_supports</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.optimizer_model"><code>InfiniteOpt.optimizer_model</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.optimizer_model_key"><code>InfiniteOpt.optimizer_model_key</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.optimizer_model_ready"><code>InfiniteOpt.optimizer_model_ready</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}"><code>InfiniteOpt.parameter_by_name</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="../guide/measure/#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.parameter_refs-Tuple{InfiniteConstraintRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="../guide/variable/#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.parameter_refs</code></a></li><li><a href="../guide/variable/#InfiniteOpt.parameter_values-Tuple{PointVariableRef}"><code>InfiniteOpt.parameter_values</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.set_independent-Tuple{ParameterRef}"><code>InfiniteOpt.set_independent</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}"><code>InfiniteOpt.set_infinite_set</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.set_optimizer_model"><code>InfiniteOpt.set_optimizer_model</code></a></li><li><a href="../guide/optimize/#InfiniteOpt.set_optimizer_model_ready"><code>InfiniteOpt.set_optimizer_model_ready</code></a></li><li><a href="../guide/variable/#InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}"><code>InfiniteOpt.set_parameter_refs</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s4,1} where #s4&lt;:Number}"><code>InfiniteOpt.set_supports</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.supports-Tuple{InfiniteConstraintRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.supports-Tuple{ParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.supports-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.supports-Tuple{AbstractArray{#s4,N} where N where #s4&lt;:ParameterRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="../guide/transcribe/#InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}"><code>InfiniteOpt.supports</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.unset_independent-Tuple{ParameterRef}"><code>InfiniteOpt.unset_independent</code></a></li><li><a href="../guide/variable/#InfiniteOpt.used_by_constraint-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="../guide/measure/#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="../guide/measure/#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_constraint</code></a></li><li><a href="../guide/measure/#InfiniteOpt.used_by_measure-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.used_by_measure-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="../guide/variable/#InfiniteOpt.used_by_measure-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="../guide/measure/#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}"><code>InfiniteOpt.used_by_measure</code></a></li><li><a href="../guide/measure/#InfiniteOpt.used_by_objective-Tuple{MeasureRef}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="../guide/variable/#InfiniteOpt.used_by_objective-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>InfiniteOpt.used_by_objective</code></a></li><li><a href="../guide/variable/#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.used_by_point_variable</code></a></li><li><a href="../guide/variable/#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}"><code>InfiniteOpt.used_by_reduced_variable</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.used_by_variable-Tuple{ParameterRef}"><code>InfiniteOpt.used_by_variable</code></a></li><li><a href="../guide/variable/#JuMP.BinaryRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.BinaryRef</code></a></li><li><a href="../guide/measure/#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.BinaryRef</code></a></li><li><a href="../guide/variable/#JuMP.FixRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.FixRef</code></a></li><li><a href="../guide/measure/#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.FixRef</code></a></li><li><a href="../guide/variable/#JuMP.IntegerRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.IntegerRef</code></a></li><li><a href="../guide/measure/#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.IntegerRef</code></a></li><li><a href="../guide/variable/#JuMP.LowerBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="../guide/measure/#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.LowerBoundRef</code></a></li><li><a href="../guide/measure/#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="../guide/variable/#JuMP.UpperBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.UpperBoundRef</code></a></li><li><a href="../guide/optimize/#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:MathOptInterface.Bridges.AbstractBridge}"><code>JuMP.add_bridge</code></a></li><li><a href="../guide/constraint/#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint}"><code>JuMP.add_constraint</code></a></li><li><a href="#JuMP.add_to_expression!"><code>JuMP.add_to_expression!</code></a></li><li><a href="../guide/constraint/#JuMP.add_to_function_constant-Tuple{GeneralConstraintRef,Real}"><code>JuMP.add_to_function_constant</code></a></li><li><a href="../guide/variable/#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}"><code>JuMP.add_variable</code></a></li><li><a href="../guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:AbstractJuMPScalar}"><code>JuMP.all_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel}"><code>JuMP.all_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:AbstractJuMPScalar,Type{#s3} where #s3&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:MathOptInterface.AbstractSet}"><code>JuMP.all_constraints</code></a></li><li><a href="../guide/variable/#JuMP.all_variables-Tuple{InfiniteModel}"><code>JuMP.all_variables</code></a></li><li><a href="../guide/optimize/#JuMP.bridge_constraints-Tuple{InfiniteModel}"><code>JuMP.bridge_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}"><code>JuMP.build_constraint</code></a></li><li><a href="../guide/variable/#JuMP.build_variable-Tuple{Function,VariableInfo,Symbol}"><code>JuMP.build_variable</code></a></li><li><a href="../guide/constraint/#JuMP.constraint_by_name-Tuple{InfiniteModel,String}"><code>JuMP.constraint_by_name</code></a></li><li><a href="../guide/constraint/#JuMP.constraint_object-Tuple{GeneralConstraintRef}"><code>JuMP.constraint_object</code></a></li><li><a href="../guide/constraint/#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.delete</code></a></li><li><a href="../guide/variable/#JuMP.delete-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete</code></a></li><li><a href="../guide/parameter/#JuMP.delete-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.delete</code></a></li><li><a href="../guide/measure/#JuMP.delete-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.delete</code></a></li><li><a href="../guide/measure/#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.delete</code></a></li><li><a href="../guide/variable/#JuMP.delete_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_lower_bound</code></a></li><li><a href="../guide/variable/#JuMP.delete_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.delete_upper_bound</code></a></li><li><a href="../guide/result/#JuMP.dual-Tuple{GeneralConstraintRef}"><code>JuMP.dual</code></a></li><li><a href="../guide/result/#JuMP.dual_status-Tuple{InfiniteModel}"><code>JuMP.dual_status</code></a></li><li><a href="../guide/variable/#JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.fix</code></a></li><li><a href="../guide/measure/#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.fix_value</code></a></li><li><a href="../guide/variable/#JuMP.fix_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.fix_value</code></a></li><li><a href="../guide/measure/#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="../guide/variable/#JuMP.has_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_lower_bound</code></a></li><li><a href="../guide/parameter/#JuMP.has_lower_bound-Tuple{ParameterRef}"><code>JuMP.has_lower_bound</code></a></li><li><a href="../guide/variable/#JuMP.has_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.has_upper_bound</code></a></li><li><a href="../guide/parameter/#JuMP.has_upper_bound-Tuple{ParameterRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="../guide/measure/#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.has_upper_bound</code></a></li><li><a href="../guide/result/#JuMP.has_values-Tuple{InfiniteModel}"><code>JuMP.has_values</code></a></li><li><a href="../guide/variable/#JuMP.index-Tuple{GeneralVariableRef}"><code>JuMP.index</code></a></li><li><a href="../guide/constraint/#JuMP.index-Tuple{GeneralConstraintRef}"><code>JuMP.index</code></a></li><li><a href="../guide/variable/#JuMP.is_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_binary</code></a></li><li><a href="../guide/measure/#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_binary</code></a></li><li><a href="../guide/measure/#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_fixed</code></a></li><li><a href="../guide/variable/#JuMP.is_fixed-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_fixed</code></a></li><li><a href="../guide/measure/#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.is_integer</code></a></li><li><a href="../guide/variable/#JuMP.is_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_integer</code></a></li><li><a href="../guide/constraint/#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}"><code>JuMP.is_valid</code></a></li><li><a href="../guide/variable/#JuMP.is_valid-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.is_valid</code></a></li><li><a href="../guide/parameter/#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}"><code>JuMP.is_valid</code></a></li><li><a href="../guide/measure/#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}"><code>JuMP.is_valid</code></a></li><li><a href="../guide/measure/#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}"><code>JuMP.is_valid</code></a></li><li><a href="../guide/constraint/#JuMP.list_of_constraint_types-Tuple{InfiniteModel}"><code>JuMP.list_of_constraint_types</code></a></li><li><a href="../guide/parameter/#JuMP.lower_bound-Tuple{ParameterRef}"><code>JuMP.lower_bound</code></a></li><li><a href="../guide/measure/#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.lower_bound</code></a></li><li><a href="../guide/variable/#JuMP.lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.lower_bound</code></a></li><li><a href="../guide/parameter/#JuMP.name-Tuple{ParameterRef}"><code>JuMP.name</code></a></li><li><a href="../guide/constraint/#JuMP.name-Tuple{GeneralConstraintRef}"><code>JuMP.name</code></a></li><li><a href="../guide/measure/#JuMP.name-Tuple{MeasureRef}"><code>JuMP.name</code></a></li><li><a href="../guide/variable/#JuMP.name-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.name</code></a></li><li><a href="../guide/measure/#JuMP.name-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.name</code></a></li><li><a href="../guide/constraint/#JuMP.normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef}"><code>JuMP.normalized_coefficient</code></a></li><li><a href="../guide/constraint/#JuMP.normalized_rhs-Tuple{GeneralConstraintRef}"><code>JuMP.normalized_rhs</code></a></li><li><a href="../guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:AbstractJuMPScalar}"><code>JuMP.num_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s4} where #s4&lt;:AbstractJuMPScalar,Type{#s3} where #s3&lt;:MathOptInterface.AbstractSet}"><code>JuMP.num_constraints</code></a></li><li><a href="../guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel}"><code>JuMP.num_constraints</code></a></li><li><a href="../guide/variable/#JuMP.num_variables-Tuple{InfiniteModel}"><code>JuMP.num_variables</code></a></li><li><a href="../guide/result/#JuMP.objective_bound-Tuple{InfiniteModel}"><code>JuMP.objective_bound</code></a></li><li><a href="../guide/objective/#JuMP.objective_function-Tuple{InfiniteModel}"><code>JuMP.objective_function</code></a></li><li><a href="../guide/objective/#JuMP.objective_function_type-Tuple{InfiniteModel}"><code>JuMP.objective_function_type</code></a></li><li><a href="../guide/objective/#JuMP.objective_sense-Tuple{InfiniteModel}"><code>JuMP.objective_sense</code></a></li><li><a href="../guide/result/#JuMP.objective_value-Tuple{InfiniteModel}"><code>JuMP.objective_value</code></a></li><li><a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>JuMP.optimize!</code></a></li><li><a href="../guide/result/#JuMP.optimizer_index-Tuple{GeneralVariableRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="../guide/result/#JuMP.optimizer_index-Tuple{GeneralConstraintRef}"><code>JuMP.optimizer_index</code></a></li><li><a href="../guide/variable/#JuMP.owner_model-Tuple{GeneralVariableRef}"><code>JuMP.owner_model</code></a></li><li><a href="../guide/constraint/#JuMP.owner_model-Tuple{GeneralConstraintRef}"><code>JuMP.owner_model</code></a></li><li><a href="../guide/result/#JuMP.primal_status-Tuple{InfiniteModel}"><code>JuMP.primal_status</code></a></li><li><a href="../guide/result/#JuMP.raw_status-Tuple{InfiniteModel}"><code>JuMP.raw_status</code></a></li><li><a href="../guide/variable/#JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_binary</code></a></li><li><a href="../guide/variable/#JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.set_integer</code></a></li><li><a href="../guide/parameter/#JuMP.set_lower_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_lower_bound</code></a></li><li><a href="../guide/variable/#JuMP.set_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_lower_bound</code></a></li><li><a href="../guide/variable/#JuMP.set_name-Tuple{GlobalVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="../guide/constraint/#JuMP.set_name-Tuple{GeneralConstraintRef,String}"><code>JuMP.set_name</code></a></li><li><a href="../guide/measure/#JuMP.set_name-Tuple{MeasureRef,String}"><code>JuMP.set_name</code></a></li><li><a href="../guide/variable/#JuMP.set_name-Tuple{PointVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="../guide/variable/#JuMP.set_name-Tuple{InfiniteVariableRef,String}"><code>JuMP.set_name</code></a></li><li><a href="../guide/parameter/#JuMP.set_name-Tuple{ParameterRef,String}"><code>JuMP.set_name</code></a></li><li><a href="../guide/constraint/#JuMP.set_normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef,Real}"><code>JuMP.set_normalized_coefficient</code></a></li><li><a href="../guide/constraint/#JuMP.set_normalized_rhs-Tuple{GeneralConstraintRef,Real}"><code>JuMP.set_normalized_rhs</code></a></li><li><a href="../guide/objective/#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}"><code>JuMP.set_objective</code></a></li><li><a href="../guide/objective/#JuMP.set_objective_coefficient-Tuple{InfiniteModel,GeneralVariableRef,Real}"><code>JuMP.set_objective_coefficient</code></a></li><li><a href="../guide/objective/#JuMP.set_objective_function-Tuple{InfiniteModel,Real}"><code>JuMP.set_objective_function</code></a></li><li><a href="../guide/objective/#JuMP.set_objective_function-Tuple{InfiniteModel,AbstractJuMPScalar}"><code>JuMP.set_objective_function</code></a></li><li><a href="../guide/objective/#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}"><code>JuMP.set_objective_sense</code></a></li><li><a href="../guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,OptimizerFactory}"><code>JuMP.set_optimizer</code></a></li><li><a href="../guide/optimize/#JuMP.set_parameter-Tuple{InfiniteModel,Any,Any}"><code>JuMP.set_parameter</code></a></li><li><a href="../guide/optimize/#JuMP.set_silent-Tuple{InfiniteModel}"><code>JuMP.set_silent</code></a></li><li><a href="../guide/variable/#JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_start_value</code></a></li><li><a href="../guide/variable/#JuMP.set_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}"><code>JuMP.set_upper_bound</code></a></li><li><a href="../guide/parameter/#JuMP.set_upper_bound-Tuple{ParameterRef,Number}"><code>JuMP.set_upper_bound</code></a></li><li><a href="../guide/result/#JuMP.shadow_price-Tuple{GeneralConstraintRef}"><code>JuMP.shadow_price</code></a></li><li><a href="../guide/result/#JuMP.solve_time-Tuple{InfiniteModel}"><code>JuMP.solve_time</code></a></li><li><a href="../guide/variable/#JuMP.start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.start_value</code></a></li><li><a href="../guide/measure/#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.start_value</code></a></li><li><a href="../guide/result/#JuMP.termination_status-Tuple{InfiniteModel}"><code>JuMP.termination_status</code></a></li><li><a href="../guide/variable/#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unfix</code></a></li><li><a href="../guide/variable/#JuMP.unset_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_binary</code></a></li><li><a href="../guide/variable/#JuMP.unset_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.unset_integer</code></a></li><li><a href="../guide/optimize/#JuMP.unset_silent-Tuple{InfiniteModel}"><code>JuMP.unset_silent</code></a></li><li><a href="../guide/parameter/#JuMP.upper_bound-Tuple{ParameterRef}"><code>JuMP.upper_bound</code></a></li><li><a href="../guide/variable/#JuMP.upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}"><code>JuMP.upper_bound</code></a></li><li><a href="../guide/measure/#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}"><code>JuMP.upper_bound</code></a></li><li><a href="../guide/result/#JuMP.value-Tuple{GeneralConstraintRef}"><code>JuMP.value</code></a></li><li><a href="../guide/result/#JuMP.value-Tuple{GeneralVariableRef}"><code>JuMP.value</code></a></li><li><a href="../guide/variable/#JuMP.variable_by_name-Tuple{InfiniteModel,String}"><code>JuMP.variable_by_name</code></a></li><li><a href="#JuMP.with_optimizer"><code>JuMP.with_optimizer</code></a></li><li><a href="../guide/variable/#InfiniteOpt.@global_variable"><code>InfiniteOpt.@global_variable</code></a></li><li><a href="../guide/parameter/#InfiniteOpt.@infinite_parameter"><code>InfiniteOpt.@infinite_parameter</code></a></li><li><a href="../guide/variable/#InfiniteOpt.@infinite_variable"><code>InfiniteOpt.@infinite_variable</code></a></li><li><a href="../guide/variable/#InfiniteOpt.@point_variable"><code>InfiniteOpt.@point_variable</code></a></li><li><a href="#JuMP.@constraint"><code>JuMP.@constraint</code></a></li><li><a href="#JuMP.@expression"><code>JuMP.@expression</code></a></li><li><a href="#JuMP.@objective"><code>JuMP.@objective</code></a></li></ul><h2><a class="nav-anchor" id="JuMP-Documentation-1" href="#JuMP-Documentation-1">JuMP Documentation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.Model" href="#JuMP.Model"><code>JuMP.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Model</code></pre><p>A mathematical model of an optimization problem.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.Model-Tuple{}" href="#JuMP.Model-Tuple{}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
        bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the <code>CachingOptimizer</code> storing this cache is <code>caching_mode</code>. The optimizer can be set later in the <a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> call. If <code>bridge_constraints</code> is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the <code>MathOptInterface.Bridges</code> module or is defined in another module and is explicitely added.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.Model-Tuple{OptimizerFactory}" href="#JuMP.Model-Tuple{OptimizerFactory}"><code>JuMP.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Model(optimizer_factory::OptimizerFactory;
      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,
      bridge_constraints::Bool=true)</code></pre><p>Return a new JuMP model using the optimizer factory <code>optimizer_factory</code> to create the optimizer. The optimizer factory can be created by the <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a> function.</p><p><strong>Examples</strong></p><p>The following creates a model using the optimizer <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">model = Model(with_optimizer(Ipopt.Optimizer, print_level=0))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.with_optimizer" href="#JuMP.with_optimizer"><code>JuMP.with_optimizer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">with_optimizer(constructor, args...; kwargs...)</code></pre><p>Return an <code>OptimizerFactory</code> that creates optimizers using the constructor <code>constructor</code> with positional arguments <code>args</code> and keyword arguments <code>kwargs</code>.</p><p><strong>Examples</strong></p><p>The following returns an optimizer factory that creates <code>Ipopt.Optimizer</code>s using the constructor call <code>Ipopt.Optimizer(print_level=0)</code>:</p><pre><code class="language-julia">with_optimizer(Ipopt.Optimizer, print_level=0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@expression" href="#JuMP.@expression"><code>JuMP.@expression</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@expression(args...)</code></pre><p>Efficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:</p><pre><code class="language-julia">@expression(m, shared, sum(i*x[i] for i=1:5))
@constraint(m, shared + y &gt;= 5)
@constraint(m, shared + z &lt;= 10)</code></pre><p>The <code>ref</code> accepts index sets in the same way as <code>@variable</code>, and those indices can be used in the construction of the expressions:</p><pre><code class="language-julia">@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))</code></pre><p>Anonymous syntax is also supported:</p><pre><code class="language-julia">expr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.add_to_expression!" href="#JuMP.add_to_expression!"><code>JuMP.add_to_expression!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_to_expression!(expression, terms...)</code></pre><p>Updates <code>expression</code> <em>in place</em> to <code>expression + (*)(terms...)</code>. This is typically much more efficient than <code>expression += (*)(terms...)</code>. For example, <code>add_to_expression!(expression, a, b)</code> produces the same result as <code>expression += a*b</code>, and <code>add_to_expression!(expression, a)</code> produces the same result as <code>expression += a</code>.</p><p>Only a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) <code>expression</code> is capable of storing the result. For example, <code>add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef)</code> is not defined because a <code>GenericAffExpr</code> cannot store the product of two variables.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@objective" href="#JuMP.@objective"><code>JuMP.@objective</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@objective(model::Model, sense, func)</code></pre><p>Set the objective sense to <code>sense</code> and objective function to <code>func</code>. The objective sense can be either <code>Min</code>, <code>Max</code>, <code>MathOptInterface.MIN_SENSE</code>, <code>MathOptInterface.MAX_SENSE</code> or <code>MathOptInterface.FEASIBILITY_SENSE</code>; see <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.8/apireference.html#MathOptInterface.ObjectiveSense"><code>MathOptInterface.ObjectiveSense</code></a>. In order to set the sense programatically, i.e., when <code>sense</code> is a Julia variable whose value is the sense, one of the three <code>MathOptInterface.ObjectiveSense</code> values should be used. The function <code>func</code> can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.</p><p><strong>Examples</strong></p><p>To minimize the value of the variable <code>x</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; model = Model()
A JuMP Model
Feasibility problem with:
Variables: 0
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.

julia&gt; @variable(model, x)
x

julia&gt; @objective(model, Min, x)
x</code></pre><p>To maximize the value of the affine expression <code>2x - 1</code>, do as follows:</p><pre><code class="language-julia-repl">julia&gt; @objective(model, Max, 2x - 1)
2 x - 1</code></pre><p>To set a quadratic objective and set the objective sense programatically, do as follows:</p><pre><code class="language-julia-repl">julia&gt; sense = MOI.MIN_SENSE
MIN_SENSE::OptimizationSense = 0

julia&gt; @objective(model, sense, x^2 - 2x + 1)
x² - 2 x + 1</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.ScalarConstraint" href="#JuMP.ScalarConstraint"><code>JuMP.ScalarConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct ScalarConstraint</code></pre><p>The data for a scalar constraint. The <code>func</code> field containts a JuMP object representing the function and the <code>set</code> field contains the MOI set. See also the <a href="../guide/constraint/#Constraints-1">documentation</a> on JuMP&#39;s representation of constraints for more background.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@constraint" href="#JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@constraint(m::Model, expr)</code></pre><p>Add a constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@constraint(m::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> can either be</p><ul><li>of the form <code>func in set</code> constraining the function <code>func</code> to belong to the set <code>set</code> which is either a <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1"><code>MathOptInterface.AbstractSet</code></a> or one of the JuMP shortcuts <a href="#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>, <a href="#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> and <a href="#JuMP.PSDCone"><code>PSDCone</code></a>, e.g. <code>@constraint(model, [1, x-1, y-2] in SecondOrderCone())</code> constrains the norm of <code>[x-1, y-2]</code> be less than 1;</li><li>of the form <code>a sign b</code>, where <code>sign</code> is one of <code>==</code>, <code>≥</code>, <code>&gt;=</code>, <code>≤</code> and <code>&lt;=</code> building the single constraint enforcing the comparison to hold for the expression <code>a</code> and <code>b</code>, e.g. <code>@constraint(m, x^2 + y^2 == 1)</code> constrains <code>x</code> and <code>y</code> to lie on the unit circle;</li><li>of the form <code>a ≤ b ≤ c</code> or <code>a ≥ b ≥ c</code> (where <code>≤</code> and <code>&lt;=</code> (resp. <code>≥</code> and <code>&gt;=</code>) can be used interchangeably) constraining the paired the expression <code>b</code> to lie between <code>a</code> and <code>c</code>;</li><li>of the forms <code>@constraint(m, a .sign b)</code> or <code>@constraint(m, a .sign b .sign c)</code> which broadcast the constraint creation to each element of the vectors.</li></ul><p><strong>Note for extending the constraint macro</strong></p><p>Each constraint will be created using <code>add_constraint(m, build_constraint(_error, func, set))</code> where</p><ul><li><code>_error</code> is an error function showing the constraint call in addition to the error message given as argument,</li><li><code>func</code> is the expression that is constrained</li><li>and <code>set</code> is the set in which it is constrained to belong.</li></ul><p>For <code>expr</code> of the first type (i.e. <code>@constraint(m, func in set)</code>), <code>func</code> and <code>set</code> are passed unchanged to <code>build_constraint</code> but for the other types, they are determined from the expressions and signs. For instance, <code>@constraint(m, x^2 + y^2 == 1)</code> is transformed into <code>add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0)))</code>.</p><p>To extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to <code>build_constraint</code>. Note that this will likely mean that either <code>func</code> or <code>set</code> will be some custom type, rather than e.g. a <code>Symbol</code>, since we will likely want to dispatch on the type of the function or set appearing in the constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.SecondOrderCone" href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SecondOrderCone</code></pre><p>Second order cone object that can be used to constrain the euclidean norm of a vector <code>x</code> to be less than or equal to a nonnegative scalar <code>t</code>. This is a shortcut for the <code>MathOptInterface.SecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le t$</span> and <span>$t \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x-1, x-2] in SecondOrderCone())
[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.RotatedSecondOrderCone" href="#JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RotatedSecondOrderCone</code></pre><p>Rotated second order cone object that can be used to constrain the square of the euclidean norm of a vector <code>x</code> to be less than or equal to <span>$2tu$</span> where <code>t</code> and <code>u</code> are nonnegative scalars. This is a shortcut for the <code>MathOptInterface.RotatedSecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le 2tx$</span> and <span>$t, x \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())
[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.PSDCone" href="#JuMP.PSDCone"><code>JuMP.PSDCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PSDCone</code></pre><p>Positive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the <a href="#JuMP.@constraint"><code>@constraint</code></a> macro. If the matrix has type <code>Symmetric</code> then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the <code>MOI.PositiveSemidefiniteConeTriangle</code> set, otherwise its column vectorization is constrained to belong to the <code>MOI.PositiveSemidefiniteConeSquare</code> set.</p><p><strong>Examples</strong></p><p>Consider the following example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [ x 2x
            2x  x];

julia&gt; b = [1 2
            2 4];

julia&gt; cref = @SDconstraint(model, a ⪰ b)
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
4-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>We see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra # For Symmetric

julia&gt; cref = @constraint(model, Symmetric(a - b) in PSDCone())
[x - 1    2 x - 2;
 2 x - 2  x - 4  ] ∈ PSDCone()

julia&gt; jump_function(constraint_object(cref))
3-element Array{GenericAffExpr{Float64,VariableRef},1}:
 x - 1
 2 x - 2
 x - 4

julia&gt; moi_set(constraint_object(cref))
MathOptInterface.PositiveSemidefiniteConeTriangle(2)</code></pre><p>As we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.NoOptimizer" href="#JuMP.NoOptimizer"><code>JuMP.NoOptimizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NoOptimizer &lt;: Exception end</code></pre><p>No optimizer is set. The optimizer can be provided at the <a href="#JuMP.Model"><code>Model</code></a> constructor or at the <a href="../guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}"><code>optimize!</code></a> call with <a href="#JuMP.with_optimizer"><code>with_optimizer</code></a>.</p></div></div></section><footer><hr/><a class="previous" href="../examples/"><span class="direction">Previous</span><span class="title">Examples</span></a><a class="next" href="../extensions/"><span class="direction">Next</span><span class="title">Extensions</span></a></footer></article></body></html>
