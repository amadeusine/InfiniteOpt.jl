var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A JuMP extension for expressing and solving infinite dimensional optimization problems.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"InfiniteOpt.jl provides a mathematical interface to express and solve optimization problems that entail an infinite dimensional decision space. Such problems stem from areas such as dynamic programming, state-space models, and stochastic programming. InfiniteOpt.jl is meant to facilitate intuitive model definition, automatic transcription into solvable models, permit a wide range of user-defined extensions/behavior, and more. Currently, its capabilities include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JuMP-like macro based parameter and variable definition\nJuMP-like macro based objective and constraint definition\nExtensions to all JuMP modification methods (e.g., delete)\nMeasure abstractions and definition\nAutomatic model transcription and solution\nMuch more.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nCurrently, InfiniteOpt only accepts linear and quadratic expressions. Development is underway to allow for general nonlinear constraints.  ","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"InfiniteOpt.jl is still in its early stages of development but can be installed by entering the following in the package manager.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> add https://github.com/pulsipher/InfiniteOpt.jl","category":"page"},{"location":"#Quick-Start-1","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Below is a brief example of the high-level API.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Revise, InfiniteOpt, JuMP, Clp, Distributions\n\n# Set the problem information\nθ_nom, covar = [0.; 60.; 10.], [80. 0 0; 0 80. 0; 0 0 120.]\nn_z, n_θ, n_d = 3, 3, 3\nc = ones(n_d) / sqrt(n_d)\nnum_samples = 100\n\n# Initialize the model\nm = InfiniteModel(with_optimizer(Clp.Optimizer))\n\n# Set the uncertainty parameters\ndist = MvNormal(θ_nom, covar)\nθs = rand(dist, num_samples)\n@infinite_parameter(m, θ[i = 1:n_θ] in dist, supports = θs[i, :])\n@infinite_parameter(m, 0 <= t <= 10, supports = Vector(0:10))\n\n# Initialize the variables\n@infinite_variable(m, z[1:n_z](θ, t))\n@infinite_variable(m, 0 <= y(θ) <= 100)\n@global_variable(m, d[1:n_d] >= 0)\n\n# Set objective function\nexpect_data = DiscreteMeasureData(θ, ones(num_samples) / num_samples,\n                                  supports(θ), name = \"expect\")\n@objective(m, Min, measure(1 - y, expect_data))\n\n# Set first stage constraints\n@constraint(m, max_cost, sum(c[i] * d[i] for i = 1:n_d) <= 5)\n\n# Set the second stage constraints\n@constraint(m, f1, -z[1] - 35 - d[1] + y <= 0)\n@constraint(m, f2, z[1] - 35 - d[1] + y <= 0)\n@constraint(m, f3, -z[2] - 50 - d[2] + y <= 0)\n@constraint(m, f4, z[1] - 50 - d[2] + y <= 0)\n@constraint(m, h1, z[1] - θ[1] == 0)\n@constraint(m, h2, -z[1] -z[2] + z[3] - θ[2] == 0)\n@constraint(m, h3, z[2] - θ[3] == 0)\n\n# Solve and and obtain results\noptimize!(m)\nif has_values(m)\n    opt_y = value(y)\n    opt_d = value.(d)\n    opt_obj = objective_value(m)\nend","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We acknowledge our support from the Department of Energy under grant DE-SC0014114.","category":"page"},{"location":"library/#Method,-DataType,-and-Macro-Index-1","page":"Library","title":"Method, DataType, and Macro Index","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Method,-DataType,-and-Macro-References-1","page":"Library","title":"Method, DataType, and Macro References","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Modules = [InfiniteOpt]","category":"page"},{"location":"library/#InfiniteOpt.AbstractInfiniteSet","page":"Library","title":"InfiniteOpt.AbstractInfiniteSet","text":"AbstractInfiniteSet\n\nAn abstract type for sets that characterize infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.AbstractMeasureData","page":"Library","title":"InfiniteOpt.AbstractMeasureData","text":"AbstractMeasureData\n\nAn abstract type to define data for measures to define the behavior of Measure.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.AbstractReducedInfo","page":"Library","title":"InfiniteOpt.AbstractReducedInfo","text":"AbstractReducedInfo\n\nAn abstract type reduced variable information.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.BoundedScalarConstraint","page":"Library","title":"InfiniteOpt.BoundedScalarConstraint","text":"BoundedScalarConstraint{F <: JuMP.AbstractJuMPScalar,\n                        S <: MOI.AbstractScalarSet} <: JuMP.AbstractConstraint\n\nA DataType that stores infinite constraints defined on a subset of the infinite parameters on which they depend.\n\nFields\n\nfunc::F The JuMP object.\nset::S The MOI set.\nbounds::Dict{ParameterRef, IntervalSet} A dictionary mapping parameter                                           references to an interval set.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.DiscreteMeasureData","page":"Library","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData <: AbstractMeasureData\n\nA DataType for one dimensional measure abstraction data where the measure abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i).\n\nFields\n\nparameter_ref::ParameterRef The infinite parameter over which the                               integration occurs.\ncoefficients::Vector{<:Number} Coefficients alpha_i for the above                                  measure abstraction.\nsupports::Vector{<:Number} Support points tau_i for the above                              measure abstraction.\nname::String Name of the measure that will be implemented.\nweight_function::Function Weighting function w must map support value                             input value of type Number to a scalar value.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s43,N} where N where #s43<:ParameterRef,Array{#s42,1} where #s42<:Number,Array{#s41,1} where #s41<:AbstractArray}","page":"Library","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(parameter_ref::AbstractArray{<:ParameterRef},\n                    coefficients::Vector{<:Number},\n                    supports::Vector{<:AbstractArray{<:Number}};\n                    name::String = \"measure\",\n                    weight_function::Function = w(t) = 1\n                    )::MultiDiscreteMeasureData\n\nReturns a MultiDiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for parameter_ref. Note that name is used for printing purposes and a description of the other arguments is provided in the documentation for MultiDiscreteMeasureData. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or the parameters have different group IDs.\n\nExample ```julia julia> data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]], name = \"example\");\n\njulia> typeof(data) MultiDiscreteMeasureData\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s46,1} where #s46<:Number,Array{#s45,1} where #s45<:Number}","page":"Library","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(parameter_ref::ParameterRef,\n                    coefficients::Vector{<:Number},\n                    supports::Vector{<:Number}; name::String = \"measure\",\n                    weight_function::Function = w(t) = 1)::DiscreteMeasureData\n\nReturns a DiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for a scalar (single) parameter. Note that name is used for printing purposes and a description of the other arguments is provided in the documentation for DiscreteMeasureData. Errors if supports are out bounds or an unequal number of supports and coefficients are given.\n\nExample\n\njulia> data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], name = \"example\")\nDiscreteMeasureData(pref, [0.5, 0.5], [1, 2], \"example\", InfiniteOpt._w)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.DistributionSet","page":"Library","title":"InfiniteOpt.DistributionSet","text":"DistributionSet{T <: Distributions.NonMatrixDistribution} <: AbstractInfiniteSet\n\nA DataType that stores the distribution characterizing infinite parameters that are random.\n\nFields\n\ndistribution::T Distribution of the random parameter.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.FiniteConstraintRef","page":"Library","title":"InfiniteOpt.FiniteConstraintRef","text":"FiniteConstraintRef{S <: JuMP.AbstractShape} <: GeneralConstraintRef\n\nA DataType for constraints that contain finite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of constraint in model.\nshape::JuMP.AbstractShape Shape of constraint\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.FiniteVariableRef","page":"Library","title":"InfiniteOpt.FiniteVariableRef","text":"FiniteVariableRef <: GeneralVariableRef\n\nAn abstract type to define new finite variable references.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.GeneralConstraintRef","page":"Library","title":"InfiniteOpt.GeneralConstraintRef","text":"GeneralConstraintRef\n\nAn abstract type for constraint references unique to InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.GeneralVariableRef","page":"Library","title":"InfiniteOpt.GeneralVariableRef","text":"GeneralVariableRef <: JuMP.AbstractVariableRef\n\nAn abstract type to for variable references used with infinite models.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.GlobalVariable","page":"Library","title":"InfiniteOpt.GlobalVariable","text":"GlobalVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing global variable information.\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP variable information.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.GlobalVariableRef","page":"Library","title":"InfiniteOpt.GlobalVariableRef","text":"GlobalVariableRef <: FiniteVariableRef\n\nA DataType for finite fixed variable references (e.g., first stage variables, steady-state variables).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.InfOptParameter","page":"Library","title":"InfiniteOpt.InfOptParameter","text":"InfOptParameter{T <: AbstractInfiniteSet} <: JuMP.AbstractVariable\n\nA DataType for storing core infinite parameter information.\n\nFields\n\nset::T The infinite set that characterizes the parameter.\nsupports::Vector{<:Number} The support points used to discretize this                              parameter.\nindependent::Bool Is independent of other parameters that share its group ID                     number.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.InfOptVariable","page":"Library","title":"InfiniteOpt.InfOptVariable","text":"InfOptVariable <: JuMP.AbstractVariable\n\nAn abstract type for infinite, point, and global variables.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.InfiniteConstraintRef","page":"Library","title":"InfiniteOpt.InfiniteConstraintRef","text":"InfiniteConstraintRef{S <: JuMP.AbstractShape} <: GeneralConstraintRef\n\nA DataType for constraints that contain infinite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of constraint in model.\nshape::JuMP.AbstractShape Shape of constraint\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.InfiniteModel","page":"Library","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel <: JuMP.AbstractModel\n\nA DataType for storing all of the mathematical modeling information needed to model an optmization problem with an infinite dimensional decision space.\n\nFields\n\nnext_meas_index::Int Index - 1 of next measure.\nmeasures::Dict{Int, Measure} Measure indices to measure datatypes.\nmeas_to_name::Dict{Int, String} Measure indices to names.\nmeas_to_constrs::Dict{Int, Vector{Int}} Measure indices to dependent                                           constraint indices.\nmeas_to_meas::Dict{Int, Vector{Int}} Measure indices to dependent                                        measure indices.\nmeas_in_objective::Dict{Int, Bool} Measure indices to if used in objective.\nnext_param_index::Int Index - 1 of next infinite parameter.\nnext_param_id::Int Index - 1 of the next infinite parameter group.\nparams::Dict{Int, InfOptParameter} Infinite parameter indices to parameter                                      datatype.\nparam_to_name::Dict{Int, String} Infinite parameter indices to names.\nname_to_param::Union{Dict{String, Int}, Nothing} Names to infinite                                                    parameters.\nparam_to_group_id::Dict{Int, Int} Infinite parameter indices to group IDs.\nparam_to_constrs::Dict{Int, Vector{Int}} Infinite parameter indices to list                                            of dependent constraint indices.\nparam_to_meas::Dict{Int, Vector{Int}} Infinite parameter indices to list                                         of dependent measure indices.\nparam_to_vars::Dict{Int, Vector{Int}} Infinite parameter indices to list                                         of dependent variable indices.\nnext_var_index::Int Index - 1 of next variable index.\nvars::Dict{Int, Dict{Int, Union{InfOptVariable, ReducedVariable}} Variable                                                 indices to variable datatype.\nvar_to_name::Dict{Int, String} Variable indices to names.\nname_to_var::Union{Dict{String, Int}, Nothing} Variable names to indices.\nvar_to_lower_bound::Dict{Int, Int} Variable indices to lower bound index.\nvar_to_upper_bound::Dict{Int, Int} Variable indices to upper bound index.\nvar_to_fix::Dict{Int, Int} Variable indices to fix index.\nvar_to_zero_one::Dict{Int, Int} Variable indices to binary index.\nvar_to_integrality::Dict{Int, Int} Variable indices to integer index.\nvar_to_constrs::Dict{Int, Vector{Int}} Variable indices to dependent                                          constraint indices.\nvar_to_meas::Dict{Int, Vector{Int}} Variable indices to dependent                                       measure indices.\nvar_in_objective::Dict{Int, Bool} Variable indices to if used in objective.\ninfinite_to_points::Dict{Int, Vector{Int}} Infinite variable indices to                                              dependent point variable indices.\ninfinite_to_reduced::Dict{Int, Vector{Int}} Infinite variable indices to                                              dependent reduced variable indices.\nreduced_to_constrs::Dict{Int, Vector{Int}} Reduced variable indices to dependent                                              constraint indices.\nreduced_to_meas::Dict{Int, Vector{Int}} Reduced variable indices to dependent                                           measure indices.\nreduced_info::Dict{Int, AbstractReducedInfo} Reduced variable indices to                                                reduced variable information.\nnext_constr_index::Int Index - 1 of next constraint.\nconstrs::Dict{Int, JuMP.AbstractConstraint} Constraint indices to constraint                                               datatypes.\nconstr_to_name::Dict{Int, String} Constraint indices to names.\nname_to_constr::Union{Dict{String, Int}, Nothing} Constraint names to                                                     indices.\nconstr_in_var_info::Dict{Int, Bool} Constraint indices to if related to                                       variable information constraints.\nobjective_sense::MOI.OptimizationSense Objective sense.\nobjective_function::JuMP.AbstractJuMPScalar Finite scalar function.\nobj_dict::Dict{Symbol, Any} Store Julia symbols used with InfiniteModel\noptimizer_factory::Union{JuMP.OptimizerFactory, Nothing} Optimizer                                                            information.\noptimizer_model::JuMP.Model Model used to solve InfiniteModel\nready_to_optimize::Bool Is the optimizer_model up to date.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.InfiniteModel-Tuple{OptimizerFactory}","page":"Library","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel(optimizer_factory::JuMP.OptimizerFactory;\n              [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,\n              bridge_constraints::Bool = true])\n\nReturn a new infinite model using the optimizer factory optimizer_factory to create the optimizer. The optimizer factory can be created by the JuMP.with_optimizer function.\n\nExample\n\njulia> model = InfiniteModel(with_optimizer(Ipopt.Optimizer))\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: SolverName() attribute not implemented by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.InfiniteModel-Tuple{}","page":"Library","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel(; [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC])\n\nReturn a new infinite model where no optimizer is specified. The optimizer can later be set with the JuMP.optimizer! call. By default the optimizer_model data field is initialized with a TranscriptionModel, but a different type of model can be assigned via set_optimizer_model as can be required by extensions.\n\nExample\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.InfiniteVariable","page":"Library","title":"InfiniteOpt.InfiniteVariable","text":"InfiniteVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing core infinite variable information. Note each element of the parameter reference tuple must contain either a single ParameterRef or an AbstractArray of ParameterRefs where each ParameterRef has the same group ID number.\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP variable information.\nparameter_refs::Tuple The infinite parameters(s) that parameterize the                         variable.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.InfiniteVariableRef","page":"Library","title":"InfiniteOpt.InfiniteVariableRef","text":"InfiniteVariableRef <: GeneralVariableRef\n\nA DataType for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.IntervalSet","page":"Library","title":"InfiniteOpt.IntervalSet","text":"IntervalSet <: AbstractInfiniteSet\n\nA DataType that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval.\n\nFields\n\nlower_bound::Float64 Lower bound of the infinite parameter.\nupper_bound::Float64 Upper bound of the infinite parameter.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.IntervalSet-Tuple{Number,Number}","page":"Library","title":"InfiniteOpt.IntervalSet","text":"IntervalSet(lower_bound::Number, upper_bound::Number)\n\nA constructor for IntervalSet that converts values of type Number to values of type Float64 as required by IntervalSet.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.Measure","page":"Library","title":"InfiniteOpt.Measure","text":"Measure{T <: JuMP.AbstractJuMPScalar, V <: AbstractMeasureData}\n\nA DataType for measure abstractions.\n\nFields\n\nfunc::T Infinite variable expression.\ndata::V Data of the abstraction as described in a AbstractMeasureData           subtype.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.MeasureConstraintRef","page":"Library","title":"InfiniteOpt.MeasureConstraintRef","text":"MeasureConstraintRef{S <: JuMP.AbstractShape} <: GeneralConstraintRef\n\nA DataType for constraints that contain finite variables and measures.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of constraint in model.\nshape::JuMP.AbstractShape Shape of constraint\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.MeasureFiniteVariableRef","page":"Library","title":"InfiniteOpt.MeasureFiniteVariableRef","text":"MeasureFiniteVariableRef <: GeneralVariableRef\n\nAn abstract type to define finite variable and measure references.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.MeasureRef","page":"Library","title":"InfiniteOpt.MeasureRef","text":"MeasureRef <: FiniteVariableRef\n\nA DataType for referring to measure abstractions.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.MultiDiscreteMeasureData","page":"Library","title":"InfiniteOpt.MultiDiscreteMeasureData","text":"MultiDiscreteMeasureData <: AbstractMeasureData\n\nA DataType for multi-dimensional measure abstraction data where the measure abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i).\n\nFields\n\nparameter_ref::JuMP.Containers.SparseAxisArray{<:ParameterRef} The infinite  parameters over which the integration occurs.\ncoefficients::Vector{<:Number} Coefficients alpha_i for the above                                  measure abstraction.\nsupports::Vector{<:JuMP.Containers.SparseAxisArray{<:Number}} Support points  tau_i for the above measure abstraction.\nname::String Name of the measure that will be implemented.\nweight_function::Function Weighting function w must map a numerical                             support of type JuMP.Containers.SparseAxisArray                             to a scalar value.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.ParameterRef","page":"Library","title":"InfiniteOpt.ParameterRef","text":"ParameterRef <: GeneralVariableRef\n\nA DataType for untranscripted infinite parameters references that parameterize the infinite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.PointVariable","page":"Library","title":"InfiniteOpt.PointVariable","text":"PointVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing point variable information. Note that the elements parameter_values field must match the format of the parameter reference tuple defined in InfiniteVariable\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP Variable information.\ninfinite_variable_ref::InfiniteVariableRef The infinite variable associated                                              with the point variable.\nparameter_values::Tuple The infinite parameter values defining the point.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.PointVariableRef","page":"Library","title":"InfiniteOpt.PointVariableRef","text":"PointVariableRef <: FiniteVariableRef\n\nA DataType for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.ReducedInfiniteInfo","page":"Library","title":"InfiniteOpt.ReducedInfiniteInfo","text":"ReducedInfiniteInfo <: AbstractReducedInfo\n\nA DataType for storing reduced infinite variable information.\n\nFields\n\ninfinite_variable_ref::InfiniteVariableRef The original infinite variable.\neval_supports::Dict{Int, Union{Number, JuMP.Containers.SparseAxisArray{<:Number}}} The original parameter tuple indices to the evaluation supports.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.ReducedInfiniteVariableRef","page":"Library","title":"InfiniteOpt.ReducedInfiniteVariableRef","text":"ReducedInfiniteVariableRef <: GeneralVariableRef\n\nA DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"library/#InfiniteOpt.add_measure-Tuple{InfiniteModel,Measure}","page":"Library","title":"InfiniteOpt.add_measure","text":"add_measure(model::InfiniteModel, meas::Measure)::MeasureRef\n\nAdd a measure to model and return the corresponding measure reference. This operates in a manner similar to JuMP.add_variable.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.add_parameter","page":"Library","title":"InfiniteOpt.add_parameter","text":"add_parameter(model::InfiniteModel, p::InfOptParameter,\n              name::String=\"\")::ParameterRef\n\nReturns a ParameterRef associated with the parameter p that is added to model. This adds a parameter to the model in a manner similar to JuMP.add_variable. This can be used to add parameters with the use of @infinite_parameter. build_parameter should be used to construct p.\n\nExample\n\njulia> p = build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)\n\njulia> param_ref = add_parameter(model, p, \"name\")\nname\n\n\n\n\n\n","category":"function"},{"location":"library/#InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s52,N} where N where #s52<:ParameterRef}}","page":"Library","title":"InfiniteOpt.add_parameter_ref","text":"add_parameter_ref(vref::InfiniteVariableRef,\n                  pref::Union{ParameterRef, AbstractArray{<:ParameterRef}})\n\nAdd additional parameter reference or group of parameter references to be associated with the infinite variable vref. Errors if the parameter references are already added to the variable or if the added parameters have different group IDs.\n\njulia> name(vref)\nT(t)\n\njulia> add_parameter_ref(vref, x)\n\njulia> name(vref)\nT(t, x)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s52,1} where #s52<:Number}}","page":"Library","title":"InfiniteOpt.add_supports","text":"add_supports(pref::ParameterRef, supports::Union{Number, Vector{<:Number}})\n\nAdd additional support points for pref.\n\nExample\n\njulia> add_supports(t, 0.5)\n\njulia> supports(t)\n3-element Array{Float64,1}:\n 0.0\n 0.5\n 1.0\n\njulia> add_supports(t, [0.25, 1])\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 0.25\n 0.5\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.all_parameters-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.all_parameters","text":"all_parameters(model::InfiniteModel)::Vector{ParameterRef}\n\nReturn all of the infinite parameter references currently in model.\n\nExample\n\njulia> all_parameters(model)\n3-element Array{ParameterRef,1}:\n t\n x[1]\n x[2]\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.build_optimizer_model!","page":"Library","title":"InfiniteOpt.build_optimizer_model!","text":"build_optimizer_model!(model::InfiniteModel, key; kwargs...)\n\nBuild the optimizer model stored in model such that it can be treated as a normal JuMP model, where the Model.ext field contains a key that points to a datastructure that appropriately maps the data between the two models. The key argument should be be typed to Val{ext_key_name}.\n\n\n\n\n\n","category":"function"},{"location":"library/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.build_optimizer_model!","text":" build_optimizer_model!(model::InfiniteModel)\n\nBuild the optimizer model stored in model such that it can be  treated as a normal JuMP model. Specifically, translate the variables and  constraints stored in model into ones that are stored in the optimizer model  and can be solved. This is build generally to accomodate extensions that use  custom optimizer model types in accordance with optimizer_model_key.  Extensions will need to implement their own version of the function  build_optimizer_model!(model::InfiniteModel, key::Val{ext_key_name}).\n\nExample  ```julia julia> buildoptimizermodel!(model)\n\njulia> optimizermodelready(model) true  ```\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.build_parameter","page":"Library","title":"InfiniteOpt.build_parameter","text":"build_parameter(_error::Function, set::AbstractInfiniteSet,\n                [num_params::Int = 1;\n                supports::Union{Number, Vector{<:Number}} = Number[],\n                independent::Bool = false])::InfOptParameter\n\nReturns a InfOptParameter given the appropriate information. This is analagous to JuMP.build_variable. Errors if supports violate the bounds associated set. Also errors if set contains a multivariate distribution with a different dimension than num_params. This is meant to primarily serve as a helper method for @infinite_parameter.\n\nExample\n\njulia> build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)\n\n\n\n\n\n","category":"function"},{"location":"library/#InfiniteOpt.delete_supports-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.delete_supports","text":"delete_supports(pref::ParameterRef)\n\nDelete the support points for pref.\n\nExample\n\njulia> delete_supports(t)\n\njulia> supports(t)\nERROR: Parameter test does not have supports.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"InfiniteOpt.eval_supports","text":"eval_supports(vref::ReducedInfiniteVariableRef)::Dict\n\nReturn the evaluation supports associated with the reduced infinite variable vref.\n\nExample\n\njulia> eval_supports(vref)\nDict{Int64,Float64} with 1 entry:\n  1 => 0.5\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.expand-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.expand","text":"expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn a JuMP scalar function containing the explicit expansion of the measure mref. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with measure to expand measures on the fly.\n\nThis is useful for extensions that employ a custom optimizermodel since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending `InfiniteOpt.expandmeasurewhich should be of the formInfiniteOpt.expandmeasure(::AbstractJuMPScalar, ::AbstractMeasureData, ::InfiniteModel, pointmapper::Function)`. See the source code in InfiniteOpt/src/measures.jl for examples of how to do this.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])\n\njulia> expr = expand(measure(g + z + T - h - 2, tdata))\n0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.expand_all_measures!-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.expand_all_measures!","text":"expand_all_measures!(model::InfiniteModel)\n\nExpand all of the measures used in the objective and/or constraints of model. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. Also errors if the expanded objective function is not finite.\n\nThis is useful for extensions that employ a custom optimizermodel since it can be used evaluate measures before model is translated into the new model. This method can also be extended to handle custom measure data types by extending `InfiniteOpt.expandmeasurewhich should be of the formInfiniteOpt.expandmeasure(::AbstractJuMPScalar, ::AbstractMeasureData, ::InfiniteModel, pointmapper::Function)`. See the source code in InfiniteOpt/src/measures.jl for examples of how to do this.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n T(t, xi) >= 0.0\n z >= 0.0\n g(t) + z >= 42.0\n measure(T(t, xi)) >= 0.0, for all xi in [-1, 1]\n t in [0, 6]\n xi in Normal(μ=0.0, σ=1.0)\n\njulia> expand_all_measures!(model)\n\njulia> print(model)\nMin 3 g(6) + z\nSubject to\n T(t, xi) >= 0.0\n z >= 0.0\n g(t) + z >= 42.0\n 0.5 T(0, xi) + 0.5 T(6, xi) >= 0.0, for all xi in [-1, 1]\n t in [0, 6]\n xi in Normal(μ=0.0, σ=1.0)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.group_id-Tuple{AbstractArray{#s52,N} where N where #s52<:ParameterRef}","page":"Library","title":"InfiniteOpt.group_id","text":"group_id(prefs::AbstractArray{<:ParameterRef})::Int\n\nReturn the group ID number for a group of prefs. Error if contains multiple groups.\n\nExample\n\njulia> group_id([x[1], x[2]])\n2\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.group_id-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.group_id","text":"group_id(pref::ParameterRef)::Int\n\nReturn the group ID number for pref.\n\nExample\n\njulia> group_id(t)\n1\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.has_supports-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.has_supports","text":"has_supports(pref::ParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.infinite_set-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.infinite_set","text":"infinite_set(pref::ParameterRef)::AbstractInfiniteSet\n\nReturn the infinite set associated with pref.\n\nExample\n\njulia> infinite_set(t)\nIntervalSet(0.0, 3.0)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}","page":"Library","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::PointVariableRef)::InfiniteVariableRef\n\nReturn the InfiniteVariableRef associated with the point variable vref.\n\nExample\n\njulia> infinite_variable_ref(vref)\nT(t, x)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::ReducedInfiniteVariableRef)::InfiniteVariableRef\n\nReturn the InfiniteVariableRef associated with the reduced infinite variable vref.\n\nExample\n\njulia> infinite_variable_ref(vref)\ng(t, x)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.is_independent-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.is_independent","text":"is_independent(pref::ParameterRef)::Bool\n\nReturns true for pref if it is independent or false otherwise.\n\nExample\n\njulia> is_independent(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}","page":"Library","title":"InfiniteOpt.is_used","text":"is_used(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.is_used-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.is_used","text":"is_used(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used in the model.\n\nExample\n\njulia> is_used(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.is_used-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.is_used","text":"is_used(pref::ParameterRef)::Bool\n\nReturn true if pref is used in the model or false otherwise.\n\nExample\n\njulia> is_used(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.is_used-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"InfiniteOpt.is_used","text":"is_used(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.map_value","page":"Library","title":"InfiniteOpt.map_value","text":"map_value(vref::GeneralVariableRef, key)\n\nMap the value of vref to its counterpart in the optimizer model type distininguished by its extension key key as type Val{ext_key_name}.\n\n\n\n\n\n","category":"function"},{"location":"library/#InfiniteOpt.measure-Tuple{AbstractJuMPScalar,AbstractMeasureData}","page":"Library","title":"InfiniteOpt.measure","text":"measure(expr::JuMP.AbstractJuMPScalar, data::AbstractMeasureData)::MeasureRef\n\nReturn a measure reference that evaluates expr using according to data. This is the preferred method for implementing measures which follow the form: int_p in P expr(p) w(p) dp where p is an infinite parameter (scalar or vector) and w is the weight function. The measure data data determines how the measure is to be evaluated. Typically, the DiscreteMeasureData constructor can be used to for data. The variable expression expr can contain InfiniteOpt variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Errors if expr does not contain infinite variables, infinite parameters, or measure references. Also errors if the measure parameter specified in data is not in expr and is not in any the nested measure references. Typically, this is called inside of JuMP.@expression, JuMP.@objective, and JuMP.@constraint in a manner similar to sum. Note measures are not explicitly evaluated until build_optimizer_model! is called.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2], name = \"name1\");\n\njulia> xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]],\n                                   name = \"name2\");\n\njulia> constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)\nname1(g(t) - s + 2) + s²\n\njulia> @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))\nname1(g(t) - 1 + name2(T(t, x)))\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.measure_data-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.measure_data","text":"measure_data(mref::MeasureRef)::AbstractMeasureData\n\nReturn the measure data associated with mref.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.measure_function-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.measure_function","text":"measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn the function associated with mref.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.num_parameters-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.num_parameters","text":"num_parameters(model::InfiniteModel)::Int\n\nReturn the number of infinite parameters currently present in model.\n\nExample\n\njulia> num_parameters(model)\n1\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.num_supports-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.num_supports","text":"num_supports(pref::ParameterRef)::Int\n\nReturn the number of support points associated with pref.\n\nExample\n\njulia> num_supports(t)\n1\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.optimizer_model-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.optimizer_model","text":"optimizer_model(model::InfiniteModel)::JuMP.Model\n\nReturn the JuMP model stored in model that is used to solve it.\n\nExample\n\njulia> opt_model = optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.optimizer_model_key-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.optimizer_model_key","text":"optimizer_model_key(model::InfiniteModel)::Any\n\nReturn the extension key used in the optimizer model of model. Errors if optimizer_model.ext contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to build_optimizer_model!.\n\nExample\n\njulia> optimizer_model_key(model)\n:TransData\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.optimizer_model_ready-Tuple{InfiniteModel}","page":"Library","title":"InfiniteOpt.optimizer_model_ready","text":"optimizer_model_ready(model::InfiniteModel)::Bool\n\nReturn Bool if the optimizer model is up to date with model.\n\nExample\n\njulia> optimizer_model_ready(model)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}","page":"Library","title":"InfiniteOpt.parameter_by_name","text":"parameter_by_name(model::InfiniteModel, name::String)::Union{ParameterRef,\n                                                             Nothing}\n\nReturn the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.\n\nExample\n\njulia> parameter_by_name(model, \"t\")\nt\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}","page":"Library","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::InfiniteVariableRef)::Tuple\n\nReturn the ParameterRef(s) associated with the infinite variable vref. This is formatted as a Tuple of containing the parameter references as they inputted to define vref.\n\nExample\n\njulia> parameter_refs(vref)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::ReducedInfiniteVariableRef)::Tuple\n\nReturn the ParameterRef(s) associated with the reduced infinite variable vref. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untracripted infinite variable except, the evaluated parameters are excluded.\n\nExample\n\njulia> parameter_refs(vref)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.parameter_values-Tuple{PointVariableRef}","page":"Library","title":"InfiniteOpt.parameter_values","text":"parameter_values(vref::PointVariableRef)::Tuple\n\nReturn the support point associated with the point variable vref.\n\nExample\n\njulia> parameter_values(vref)\n(0, )\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.set_independent-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.set_independent","text":"set_independent(pref::ParameterRef)\n\nSpecify that pref be independent.\n\nExample\n\njulia> set_independent(t)\n\njulia> is_independent(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}","page":"Library","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(pref::ParameterRef, set::AbstractInfiniteSet)\n\nSpecify the infinite set of pref.\n\nExample\n\njulia> set_infinite_set(t, IntervalSet(0, 1))\n\njulia> infinite_set(t)\nIntervalSet(0.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.set_optimizer_model-Tuple{InfiniteModel,Model}","page":"Library","title":"InfiniteOpt.set_optimizer_model","text":"set_optimizer_model(inf_model::InfiniteModel, opt_model::JuMP.Model)\n\nSpecify the JuMP model that is used to solve inf_model. This is intended for internal use and extensions. Note that opt_model should contain extension data to allow it to map to inf_model in a manner similar to TranscriptionModel.\n\nExample\n\njulia> set_optimizer_model(model, TranscriptionModel())\n\njulia> optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.set_optimizer_model_ready-Tuple{InfiniteModel,Bool}","page":"Library","title":"InfiniteOpt.set_optimizer_model_ready","text":"set_optimizer_model_ready(model::InfiniteModel, status::Bool)\n\nSet the status of the optimizer model to whether it is up to date or not. Note is more intended as an internal function, but is useful for extensions.\n\nExample\n\njulia> set_optimizer_model_ready(model, true)\n\njulia> optimizer_model_ready(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}","page":"Library","title":"InfiniteOpt.set_parameter_refs","text":"set_parameter_refs(vref::InfiniteVariableRef, prefs::Tuple)\n\nSpecify a new parameter reference tuple prefs for the infinite variable vref. Note each element must contain a single parameter reference or an array of parameter references. Errors if a parameter is double specified or if an element contains parameters with different group IDs.\n\nExample\n\njulia> set_parameter_refs(vref, (t, x))\n\njulia> parameter_refs(vref)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s52,1} where #s52<:Number}","page":"Library","title":"InfiniteOpt.set_supports","text":"set_supports(pref::ParameterRef, supports::Vector{<:Number})\n\nSpecify the support points for pref. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. Note that this will overwrite existing supports.\n\nExample\n\njulia> set_supports(t, [0, 1])\n\njulia> supports(t)\n2-element Array{Int64,1}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.supports-Tuple{AbstractArray{#s42,N} where N where #s42<:ParameterRef}","page":"Library","title":"InfiniteOpt.supports","text":"supports(prefs::AbstractArray{<:ParameterRef})::Vector\n\nReturn the support points associated with an array of prefs formatted as a vector of SparseAxisArrays following the format of the input array. If the parameters are not independent then the supports of each parameter are simply spliced together. Alternatively can call supports. to more efficiently obtain an array of the same input format whose parameter references have been replaced with their supports. Errors if all the parameter references do not have the same group ID number (were intialized together as an array) or if the nonindependent parameters have support vectors of different lengths. If the parameters are independent then all the unique combinations are identified and returned as supports. Warning this operation is computationally expensive if there exist a large number of combinations.\n\nExample\n\njulia> x = @infinite_parameter(model, [i = 1:2], set = IntervalSet(-1, 1),\n                               base_name = \"x\", independent = true)\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> for i = 1:length(x)\n           set_supports(x[i], [-1, 1])\n       end\n\njulia> supports(x)\n4-element Array{JuMP.Containers.SparseAxisArray,1}:\n   [2]  =  -1\n  [1]  =  -1\n   [2]  =  1\n  [1]  =  -1\n   [2]  =  -1\n  [1]  =  1\n   [2]  =  1\n  [1]  =  1\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.supports-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.supports","text":"supports(pref::ParameterRef)::Vector\n\nReturn the support points associated with pref. Errors if there are no supports.\n\nExample\n\njulia> supports(t)\n1-element Array{Int64,1}:\n 1\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.unset_independent-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.unset_independent","text":"unset_independent(pref::ParameterRef)\n\nSpecify that pref be not independent.\n\nExample\n\njulia> unset_independent(t)\n\njulia> is_independent(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(mref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::ParameterRef)::Bool\n\nReturn true if pref is used by a constraint or false otherwise.\n\nExample\n\njulia> used_by_constraint(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::ReducedInfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_constraint-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_measure-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a measure.\n\nExample\n\njulia> used_by_measure(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_measure-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::ParameterRef)::Bool\n\nReturn true if pref is used by a measure or false otherwise.\n\nExample\n\njulia> used_by_measure(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::ReducedInfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_measure-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_objective-Tuple{MeasureRef}","page":"Library","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vmref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by the objective.\n\nExample\n\njulia> used_by_objective(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_objective-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by the objective.\n\nExample\n\njulia> used_by_objective(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}","page":"Library","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a point variable.\n\nExample\n\njulia> used_by_point_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}","page":"Library","title":"InfiniteOpt.used_by_reduced_variable","text":"used_by_reduced_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a reduced infinite variable.\n\nExample\n\njulia> used_by_reduced_variable(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.used_by_variable-Tuple{ParameterRef}","page":"Library","title":"InfiniteOpt.used_by_variable","text":"used_by_variable(pref::ParameterRef)::Bool\n\nReturn true if pref is used by an infinite variable or false otherwise.\n\nExample\n\njulia> used_by_variable(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#InfiniteOpt.@global_variable-Tuple{Any,Vararg{Any,N} where N}","page":"Library","title":"InfiniteOpt.@global_variable","text":"@global_variable(model, kw_args...)\n\nAdd an anonymous global variable to the model model described by the keyword arguments kw_args and returns the variable reference.\n\n@global_variable(model, varexpr, args..., kw_args...)\n\nAdd a global variable to model described by the expression varexpr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @global_variable(model, x)\nx\n\njulia> @global_variable(model, 0 <= y <= 4, Bin)\ny\n\njulia> y = @global_variable(model, lower_bound = 0, upper_bound = 4,\n                            binary = true, base_name = \"y\")\ny\n\njulia @global_variable(model, z[2:3] == 0)\n1-dimensional DenseAxisArray{GlobalVariableRef,1,...} with index sets:\n    Dimension 1, 2:3\nAnd data, a 2-element Array{GlobalVariableRef,1}:\n z[2]\n z[3]\n\n\n\n\n\n","category":"macro"},{"location":"library/#InfiniteOpt.@infinite_parameter-Tuple{Any,Vararg{Any,N} where N}","page":"Library","title":"InfiniteOpt.@infinite_parameter","text":"@infinite_parameter(model, kw_args...)\n\nAdd an anonymous infinite parameter to the model model described by the keyword arguments kw_args and returns the parameter reference.\n\n@infinite_parameter(model, expr, kw_args...)\n\nAdd a parameter to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. (note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, and the symbo in can be used instead of ∈) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nlb ≤ varexpr ≤ ub creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\n\nThe expression varexpr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the parameter lower bound for an interval set.\nupper_bound: Sets the value of the parameter upper bound for an interval set.\nset: The InfiniteSet characterizing the parameters see IntervalSet  and DistributionSet.\ndistribution: Sets the Distributions.jl distribution object that characterizes the parameters.\nsupports: Sets the support points for the parameters.\nindependent: Specifies if the each parameter is independent from each other or not.\ncontainer: Specify the container type.\n\nExamples  ```julia julia> @infinite_parameter(m, 0 <= x <= 1) x\n\njulia> supps = [[0, 1, 2], [-1, 1]];\n\njulia> @infinite_parameter(m, y[i = 1:2] in Normal(), supports = supps[i]) 2-element Array{ParameterRef,1}:  y[1]  y[2]\n\njulia> z = @infinite_parameter(m, [\"a\", \"b\"], distribution = Uniform(), independent = true) 2-dimensional DenseAxisArray{ParameterRef,2,...} with index sets:     Dimension 1, \"a\"     Dimension 2, \"b\" And data, a 1×1 Array{ParameterRef,2}:  noname  ```\n\n\n\n\n\n","category":"macro"},{"location":"library/#InfiniteOpt.@infinite_variable-Tuple{Any,Vararg{Any,N} where N}","page":"Library","title":"InfiniteOpt.@infinite_variable","text":"@infinte_variable(model, kw_args...)\n\nAdd an anonymous infinite variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the parameter_refs keyword is required in this case.\n\n@infinite_variable(model, varexpr, args..., kw_args...)\n\nAdd an infinite variable to model described by the expression var_expr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname(params...) creating a scalar real variable of name varname with infinite parameters params... see parameter_refs for format.\nvarname[...] or [...] creating a container of variables.\nvarname[...](params...) or [...] creating a container of variables with infinite parameters params... in the first case.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\nparameter_refs: This is mandatory if not specified in varexpr. Can be a single parameter reference, a single parameter array with parameters defined in the same call of @infinite_parameter (i.e., have same group ID), or a tuple where each element is either of the first two options listed.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. Furthermore, the parameter reference tuple is appended on the end of the name i.e., base_name(params...) or base_name[...](params...).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{ParameterRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> x = @infinite_variable(model, parameter_refs = (t, w), base_name = \"x\",\n                              lower_bound = 0)\nx(t, w)\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{InfiniteVariableRef,1}:\n y[1](t)\n y[2](t)\n\n\n\n\n\n","category":"macro"},{"location":"library/#InfiniteOpt.@point_variable-Tuple{Any,Vararg{Any,N} where N}","page":"Library","title":"InfiniteOpt.@point_variable","text":"@point_variable(model, kw_args...)\n\nAdd an anonymous point variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the infinite_variable_ref and parameter_values keywords are required in this case.\n\n@point_variable(model, infvarexpr, varexpr, args..., kw_args...)\n\nAdd a point variable to model described by the expression varexpr, the positional arguments args, and the keyword arguments kw_args and the infinite variable expr infvarexpr. The expression infvarexpr specifies the infinite variable this point variable corresponds to and the values at which the parameters are evaluated and must be of the form: infvar(param_values...) where the parameter values param_values... are listed in the same format as they are in teh definition of infvar. The expression varexpr is used to define variable specific bounds and whose name is used as an alias for the point variable which is simply the infinite variable evaluated at the values indicated. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nNote that be default a point variable inherits all of the same properties as  the infinite variable it corresponds to, but that these can be overwritten  by specifying properties such as lower bounds, fix values, etc.\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of alias name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\ninfinite_variable_ref: Sets the infinite variable reference that the point variable is associated with.\nparameter_refs: Sets the values of the infinite parameters of the infinite variable at which this poitn variable is evaluated at. Must be of the same format of that specified for the parameters in the definition of the infinite variable.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. This serves as the alias for infvarexpr (the infinite variable evaluated at particular parameter values).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{ParameterRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> @point_variable(model, x(0, [0, 0]), x0 <= 1)\nx0\n\njulia> x0 = @point_variable(model, x(0, [0, 0]), upper_bound = 1, base_name = \"x0\")\nx0\n\njulia> x0 = @point_variable(model, upper_bound = 1, base_name = \"x0\",\n                            infinite_variable_ref = x, parameter_values = (0, [0, 0]))\nx0\n\njulia> @point_variable(model, x([0, 1][i], [0, 0]), xf[i = 1:2])\n2-element Array{PointVariableRef,1}:\n xf[1]\n xf[2]\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{InfiniteVariableRef,1}:\ny[1](t)\ny[2](t)\n\njulia> @point_variable(model, y[i](0), y0[i = 1:2], Bin)\n2-element Array{PointVariableRef,1}:\n y0[1]\n y0[2]\n\n julia> y0 = @point_variable(model, [i = 1:2], binary = true, base_name = \"y0\",\n                             infinite_variable_ref = y[i], parameter_values = 0)\n 2-element Array{PointVariableRef,1}:\n  y0[1]\n  y0[2]\n\n\n\n\n\n","category":"macro"},{"location":"library/#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting the original infinite variable of vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.BinaryRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with the original infinite variable of vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar == 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.FixRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar == 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting the original infinite variable of vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.IntegerRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of the original infinite variable of vref.\n\nExample\n\njulia> cref = LowerBoundRef(vref)\nvar >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.LowerBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of vref.\n\nExample\n\njulia> cref = LowerBoundRef(vref)\nvar >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of the original infinite variable of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.UpperBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s52} where #s52<:MathOptInterface.Bridges.AbstractBridge}","page":"Library","title":"JuMP.add_bridge","text":"JuMP.add_bridge(model::Model, BridgeType::Type{<:MOI.Bridges.AbstractBridge})\n\nExtend [JuMP.add_bridge] to add BridgeType to the list of bridges that can be used by the optimizer model to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.add_constraint","page":"Library","title":"JuMP.add_constraint","text":"JuMP.add_constraint(model::InfiniteModel, c::JuMP.AbstractConstraint,\n                    [name::String = \"\"])\n\nExtend JuMP.add_constraint to add a constraint c to an infinite model model with name name. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if a vector constraint is used, the constraint only constains parameters, or if any variables do not belong to model. This is primarily used as an internal method for the cosntraint macros.\n\nExample\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42));\n\njulia> cref = add_constraint(model, constr, \"name\")\nname : g(t) + x == 42.0\n\n\n\n\n\n","category":"function"},{"location":"library/#JuMP.add_variable","page":"Library","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, v::InfOptVariable, name::String = \"\")\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt variable types. Adds a variable to an infinite model model and returns an appropriate variable reference (i.e., InfiniteVariableRef, PointVariableRef, or GlobalVariableRef). Primarily intended to be an internal function of the constructor macros @infinite_variable, @point_variable, and @global_variable. However, it can be used in combination with JuMP.build_variable to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in v.\n\nExamples\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t);\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5);\n\njulia> pvref = add_variable(m, pt_var, \"var_alias\")\nvar_alias\n\njulia> gb_var = build_variable(error, info, Global)\n\njulia> gvref = add_variable(m, gb_var, \"var_name\")\nvar_name\n\n\n\n\n\n","category":"function"},{"location":"library/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s49} where #s49<:AbstractJuMPScalar,Type{#s48} where #s48<:MathOptInterface.AbstractSet}","page":"Library","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar},\n                     set_type::Type{<:MOI.AbstractSet}\n                     )::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to return a list of all the constraints with a particular function type and set type.\n\njulia> all_constraints(model, GlobalVariableRef, MOI.LessThan)\n1-element Array{GeneralConstraintRef,1}:\n x <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51<:AbstractJuMPScalar}","page":"Library","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar}\n                     )::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to search by function types for all MOI sets and return a list of all constraints use a particular function type.\n\njulia> all_constraints(model, GlobalVariableRef)\n3-element Array{GeneralConstraintRef,1}:\n x >= 0.0\n x <= 3.0\n x integer\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s51} where #s51<:MathOptInterface.AbstractSet}","page":"Library","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     set_type::Type{<:MOI.AbstractSet}\n                     )::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to search by MOI set type for all function types and return a list of all constraints that use a particular set type.\n\njulia> all_constraints(model, MOI.GreaterThan)\n3-element Array{GeneralConstraintRef,1}:\n x >= 0.0\n g(t) >= 0.0\n g(0.5) >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.all_constraints-Tuple{InfiniteModel}","page":"Library","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel)::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to return all a list of all the constraints in an infinite model model.\n\njulia> all_constraints(model)\n5-element Array{GeneralConstraintRef,1}:\n x >= 0.0\n x <= 3.0\n x integer\n g(t) >= 0.0\n g(0.5) >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.all_variables-Tuple{InfiniteModel}","page":"Library","title":"JuMP.all_variables","text":"JuMP.all_variables(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nExtend JuMP.all_variables to return a list of all the variable references associated with model.\n\nExamples\n\njulia> all_variables(m)\n4-element Array{GeneralVariableRef,1}:\n ivar(test, θ)\n ivar2(test, x)\n name\n z\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.bridge_constraints-Tuple{InfiniteModel}","page":"Library","title":"JuMP.bridge_constraints","text":"JuMP.bridge_constraints(model::InfiniteModel)::Bool\n\nExtend JuMP.bridge_constraints to return if an infinite model model has an optimizer model where the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\nExample\n\njulia> bridge_constraints(model)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, MeasureRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,MeasureFiniteVariableRef}, GenericAffExpr{Float64,MeasureRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,MeasureFiniteVariableRef}, GenericQuadExpr{Float64,MeasureRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}","page":"Library","title":"JuMP.build_constraint","text":"JuMP.build_constraint(_error::Function, expr::InfiniteExpr,\n                      set::MOI.AbstractScalarSet;\n                      [parameter_bounds::Dict{ParameterRef, IntervalSet} = Dict()])\n\nExtend JuMP.build_constraint to accept the parameterbounds argument and return a BoundedScalarConstraint if the `parameterboundskeyword argument is specifed or return a [ScalarConstraint`](@ref) otherwise. This is primarily intended to work as an internal function for constraint macros.\n\nExample\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42.0),\n                               parameter_bounds = Dict(t => IntervalSet(0, 1)));\n\njulia> isa(constr, BoundedScalarConstraint)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.build_variable-Tuple{Function,VariableInfo,Symbol}","page":"Library","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::JuMP.VariableInfo,\n                    var_type::Symbol;\n                    parameter_refs::Union{ParameterRef,\n                                          AbstractArray{<:ParameterRef},\n                                          Tuple, Nothing} = nothing,\n                    infinite_variable_ref::Union{InfiniteVariableRef,\n                                                 Nothing} = nothing,\n                    parameter_values::Union{Number, AbstractArray{<:Number},\n                                            Tuple, Nothing} = nothing,\n                    error::Union{Function, Nothing} = nothing,\n                    extra_kw_args...)\n\nExtend the JuMP.build_variable function to accomodate InfiniteOpt variable types. Returns the appropriate variable Datatype (i.e., InfiniteVariable, PointVariable, and GlobalVariable). Primarily this method is to be used internally by the appropriate constructor macros @infinite_variable, @point_variable, and @global_variable. However, it can be called manually to build InfiniteOpt variables. Errors if an unneeded keyword argument is given or if the keywoard arguments are formatted incorrectly (e.g., parameter_refs contains repeated parameter references when an infinite variable is defined). Also errors if needed kewword arguments are negated.\n\nExamples\n\njulia> @infinite_parameter(m, 0 <= t <= 1)\nt\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t)\nInfiniteVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}\n(false, 0, false, 0, false, 0, false, 0, false, false), (t,))\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5)\nPointVariable{Int64,Int64,Int64,Float64}(VariableInfo{Int64,Int64,Int64,Float64}\n(false, 0, false, 0, false, 0, true, 0.0, false, false), var_name(t), (0.5,))\n\njulia> gb_var = build_variable(error, info, Global)\nGlobalVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}\n(false, 0, false, 0, false, 0, false, 0, false, false))\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.constraint_by_name-Tuple{InfiniteModel,String}","page":"Library","title":"JuMP.constraint_by_name","text":"JuMP.constraint_by_name(model::InfiniteModel,\n                        name::String)::Union{GeneralConstraintRef, Nothing}\n\nExtend JuMP.constraint_by_name to return the constraint reference associated with name if one exists or returns nothing. Errors if more than one constraint uses the same name.\n\nExample\n\njulia> constraint_by_name(model, \"constr_name\")\nconstr_name : x + pt == 3.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.constraint_object-Tuple{GeneralConstraintRef}","page":"Library","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::GeneralConstraintRef)::JuMP.AbstractConstraint\n\nExtend JuMP.constraint_object to return the constraint object associated with cref.\n\nExample\n\njulia> obj = constraint_object(cref)\nScalarConstraint{GlobalVariableRef,MathOptInterface.LessThan{Float64}}(x,\nMathOptInterface.LessThan{Float64}(1.0))\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}","page":"Library","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, cref::GeneralConstraintRef)\n\nExtend JuMP.delete to delete an InfiniteOpt constraint and all associated information. Errors if cref is invalid.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n g(t) + z >= 42.0\n t in [0, 6]\n\njulia> delete(model, cref)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete-Tuple{InfiniteModel,MeasureRef}","page":"Library","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, mref::MeasureRef)\n\nExtend JuMP.delete to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n measure(g(t)) == 0\n g(t) + z >= 42.0\n g(0.5) == 0\n t in [0, 6]\n\njulia> delete(model, meas)\n\njulia> print(model)\nMin z\nSubject to\n z >= 0.0\n 0 == 0\n g(t) + z >= 42.0\n g(0.5) == 0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete-Tuple{InfiniteModel,ParameterRef}","page":"Library","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, pref::ParameterRef)\n\nExtend JuMP.delete to delete infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on pref are updated to exclude it. Errors if the parameter is contained in an AbstractMeasureData datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that _check_param_in_data(pref, measure_data) needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used.\n\nExample\n\njulia> print(model)\nMin measure(g(t, x)*t + x) + z\nSubject to\n z >= 0.0\n g(t, x) + z >= 42.0\n g(0.5, x) == 0\n t in [0, 6]\n x in [0, 1]\n\njulia> delete(model, x)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n g(t) + z >= 42.0\n g(0.5) == 0\n z >= 0.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::ReducedInfiniteVariableRef)\n\nExtend JuMP.delete to delete reduced infinite variables and its dependencies. Errors if vref is invalid, meaning it has already been deleted or it belongs to another model.\n\nExample ``julia julia> print(model) Min measure(g(0, t)t + g(1, t)t) + z Subject to  z >= 0.0  g(0, t) + g(1, t) == 0  g(x, t) + z >= 42.0  g(0.5, 0.5) == 0  t in [0, 6]  x in [0, 1]\n\njulia> delete(model, rvref1)\n\njulia> print(model) Min measure(t + g(1, t)*t) + z Subject to  z >= 0.0  g(1, t) == 0  g(x, t) + z >= 42.0  g(0.5, 0.5) == 0  t in [0, 6]  x in [0, 1] ```\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::InfOptVariableRef)\n\nExtend JuMP.delete to delete InfiniteOpt variables and their dependencies. Errors if variable is invalid, meaning it has already been deleted or it belongs to another model.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n g(t) + z >= 42.0\n g(0.5) == 0\n t in [0, 6]\n\njulia> delete(model, g)\n\njulia> print(model)\nMin measure(t) + z\nSubject to\n z >= 0.0\n z >= 42.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.delete_lower_bound","text":"JuMP.delete_lower_bound(vref::InfOptVariableRef)\n\nExtend JuMP.delete_lower_bound to delete lower bound of vref. Errors if it doesn't have a lower bound.\n\nExample\n\njulia> delete_lower_bound(vref)\n\njulia> has_lower_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.delete_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.delete_upper_bound","text":"JuMP.delete_upper_bound(vref::InfOptVariableRef)\n\nExtend JuMP.delete_upper_bound to delete the upper bound of vref. Errors if it doesn't have an upper bound.\n\nExample\n\njulia> delete_upper_bound(vref)\n\njulia> has_upper_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.dual_status-Tuple{InfiniteModel}","page":"Library","title":"JuMP.dual_status","text":"JuMP.dual_status(model::InfiniteModel)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus).\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Library","title":"JuMP.fix","text":"JuMP.fix(vref::InfOptVariableRef, value::Number; force::Bool = false)\n\nExtend JuMP.fix to fix the value of an InfiniteOpt variable. Errors if variable has lower/upper bound unless force = true.\n\nExamples\n\njulia> fix(vref, 3)\n\njulia> fix_value(vref)\n3.0\n\njulia> fix(vref2, 2, force = true)\n\njulia> fix_value(vref2)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::ReducedInfiniteVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of the original infinite variable of vref. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.fix_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of an InfiniteOpt variable. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_lower_bound-Tuple{ParameterRef}","page":"Library","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::ParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined lower bound or if a lower bound can be found.\n\nExample\n\njulia> has_lower_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether the original infinite variable of vref has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether an InfiniteOpt variable has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_upper_bound-Tuple{ParameterRef}","page":"Library","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::ParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined upper bound or if a upper bound can be found.\n\nExample\n\njulia> has_upper_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether the original infinite variable of vref has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether an InfiniteOpt variable has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.has_values-Tuple{InfiniteModel}","page":"Library","title":"JuMP.has_values","text":"has_values(model::InfiniteModel)\n\nReturn true if the solver has a primal solution available to query, otherwise return false. See also value.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.index-Tuple{GeneralConstraintRef}","page":"Library","title":"JuMP.index","text":"JuMP.index(cref::GeneralConstraintRef)::Int\n\nExtend JuMP.index to return the index of an InfiniteOpt constraint cref.\n\nExample\n\njulia> index(cref)\n2\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.index-Tuple{GeneralVariableRef}","page":"Library","title":"JuMP.index","text":"JuMP.index(v::GeneralVariableRef::Int\n\nExtent JuMP.index to return the index of a InfiniteOpt variable.\n\nExample\n\njulia> index(vref)\n1\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether the original infinite variable of vref is binary.\n\nExample\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether an InfiniteOpt variable is binary.\n\nExample\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether the original infinite variable of vref is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_fixed-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether an InfiniteOpt variable is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether the original infinite variable of vref is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether an InfiniteOpt variable is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}","page":"Library","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, cref::GeneralConstraintRef)::Bool\n\nExtend JuMP.is_valid to return Bool whether an InfiniteOpt constraint reference is valid.\n\nExample\n\njulia> is_valid(model, cref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}","page":"Library","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, mref::MeasureRef)::Bool\n\nExtend JuMP.is_valid to return Bool whether mref is valid.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}","page":"Library","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, pref::ParameterRef)::Bool\n\nExtend the JuMP.is_valid function to accomodate infinite parameters. Returns true if the InfiniteModel stored in pref matches model and if the parameter index is used by model. It returns false otherwise.\n\nExample\n\njulia> is_valid(model, t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_valid to accomodate reduced infinite variables.\n\nExample\n\njulia> is_valid(model, vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.is_valid-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_valid to accomodate InfiniteOpt variables.\n\nExample\n\njulia> is_valid(model, ivref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.list_of_constraint_types-Tuple{InfiniteModel}","page":"Library","title":"JuMP.list_of_constraint_types","text":"JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple)\n\nExtend JuMP.list_of_constraint_types to return a list of tuples that contain all the used combinations of function types and set types in the model.\n\njulia> all_constraints(model)\n5-element Array{Tuple{DataType,DataType},1}:\n (GlobalVariableRef, MathOptInterface.LessThan{Float64})\n (PointVariableRef, MathOptInterface.GreaterThan{Float64})\n (GlobalVariableRef, MathOptInterface.GreaterThan{Float64})\n (GlobalVariableRef, MathOptInterface.Integer)\n (InfiniteVariableRef, MathOptInterface.GreaterThan{Float64})\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.lower_bound-Tuple{ParameterRef}","page":"Library","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::ParameterRef)::Number\n\nExtend the JuMP.lower_bound function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(t)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::ReducedInfiniteVariableRef::Float64\n\nExtend JuMP.lower_bound to return the lower bound of the original infinite variable of vref. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.lower_bound to return the lower bound of an InfiniteOpt variable. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.name-Tuple{GeneralConstraintRef}","page":"Library","title":"JuMP.name","text":"JuMP.name(cref::GeneralConstraintRef)::String\n\nExtend JuMP.name to return the name of an InfiniteOpt constraint.\n\nExample\n\njulia> name(cref)\nconstr_name\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.name-Tuple{MeasureRef}","page":"Library","title":"JuMP.name","text":"JuMP.name(mref::MeasureRef)::String\n\nExtend JuMP.name to return the name associated with a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.name-Tuple{ParameterRef}","page":"Library","title":"JuMP.name","text":"JuMP.name(pref::ParameterRef)::String\n\nExtend the JuMP.name function to accomodate infinite parameters. Returns the name string associated with pref.\n\nExample\n\njulia> name(t)\n\"t\"\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.name-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.name","text":"JuMP.name(vref::ReducedInfiniteVariableRef)::String\n\nExtend JuMP.name to return name of reduced infinite variable references. This is used when displaying measure expansions that contain such variables.\n\nExanple\n\njulia> name(rvref)\ng(1.25, x)\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.name-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.name","text":"JuMP.name(vref::InfOptVariableRef)::String\n\nExtend JuMP.name to return the names of InfiniteOpt variables.\n\nExample\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s49} where #s49<:AbstractJuMPScalar,Type{#s48} where #s48<:MathOptInterface.AbstractSet}","page":"Library","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar},\n                     set_type::Type{<:MOI.AbstractSet})::Int\n\nExtend JuMP.num_constraints to return the number of constraints with a partiuclar function type and set type.\n\nExample\n\njulia> num_constraints(model, GlobalVariableRef, MOI.LessThan)\n1\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52<:AbstractJuMPScalar}","page":"Library","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar})::Int\n\nExtend JuMP.num_constraints to search by function types for all MOI sets and return the total number of constraints with a particular function type.\n\njulia> num_constraints(model, GlobalVariableRef)\n3\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s52} where #s52<:MathOptInterface.AbstractSet}","page":"Library","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:MOI.AbstractSet})::Int\n\nExtend JuMP.num_constraints to search by MOI set type for all function types and return the total number of constraints that use a particular MOI set type.\n\njulia> num_constraints(model, MOI.LessThan)\n2\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.num_constraints-Tuple{InfiniteModel}","page":"Library","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel)::Int\n\nExtend JuMP.num_constraints to return the total number of constraints in an infinite model model.\n\njulia> num_constraints(model)\n4\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.num_variables-Tuple{InfiniteModel}","page":"Library","title":"JuMP.num_variables","text":"JuMP.num_variables(model::InfiniteModel)::Int\n\nExtend JuMP.num_variables to return the number of InfiniteOpt variables assigned to model.\n\nExample\n\njulia> num_variables(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.objective_bound-Tuple{InfiniteModel}","page":"Library","title":"JuMP.objective_bound","text":"JuMP.objective_bound(model::InfiniteModel)::Float64\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.objective_function-Tuple{InfiniteModel}","page":"Library","title":"JuMP.objective_function","text":"JuMP.objective_function(model::InfiniteModel)::JuMP.AbstractJuMPScalar\n\nExtend JuMP.objective_function to return the objective of infinite model model.\n\nExample\n\njulia> objective_function(model)\nx + measure(g(t))\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.objective_function_type-Tuple{InfiniteModel}","page":"Library","title":"JuMP.objective_function_type","text":"JuMP.objective_function_type(model::InfiniteModel)::Type{<:JuMP.AbstractJuMPScalar}\n\nExtend JuMP.objective_function_type to return the objective function type of infinite model model.\n\nExample\n\njulia> objective_function_type(model)\nGenericAffExpr{Float64, FiniteVariableRef}\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.objective_sense-Tuple{InfiniteModel}","page":"Library","title":"JuMP.objective_sense","text":"JuMP.objective_sense(model::InfiniteModel)::MOI.OptimizationSense\n\nExtend JuMP.objective_sense to return the objective sense of the infinite model model.\n\nExample\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.objective_value-Tuple{InfiniteModel}","page":"Library","title":"JuMP.objective_value","text":"JuMP.objective_value(model::InfiniteModel)::Float64\n\nReturn the objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.optimize!","page":"Library","title":"JuMP.optimize!","text":"JuMP.optimize!(model::InfiniteModel,\n               optimizer_factory::Union{Nothing, OptimizerFactory} = nothing;\n               bridge_constraints::Bool=true, kwargs...)\n\nExtend JuMP.optimize! to optimize infinite models using the internal optimizer model. Will call build_optimizer_model! if the optimizer model isn't up to date. The kwargs correspond to keyword arguments passed to build_optimizer_model! if any are defined.\n\nExample\n\njulia> optimize!(model, with_optimizer(Clp.Optimizer))\n\njulia> has_values(model)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/#JuMP.owner_model-Tuple{GeneralConstraintRef}","page":"Library","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::GeneralConstraintRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the infinite model associated with cref.\n\nExample\n\njulia> model = owner_model(cref)\nAn InfiniteOpt Model\nMinimization problem with:\nVariables: 3\nObjective function type: GlobalVariableRef\n`GenericAffExpr{Float64,FiniteVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\nNames registered in the model: g, t, h, x\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.owner_model-Tuple{GeneralVariableRef}","page":"Library","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::GeneralVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model function for InfiniteOpt variables. Returns the infinite model associated with vref.\n\nExample\n\njulia> owner_model(vref)\nAn InfiniteOpt Model\nFeasibility problem with:\nVariable: 1\n`GlobalVariableRef`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\n`GlobalVariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`GlobalVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\nNames registered in the model: vref\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.primal_status-Tuple{InfiniteModel}","page":"Library","title":"JuMP.primal_status","text":" JuMP.primal_status(model::InfiniteModel)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus).\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.set_binary","text":"JuMP.set_binary(vref::InfOptVariableRef)\n\nExtend JuMP.set_binary to specify an InfiniteOpt variable as a binary variable. Errors if vref is an integer variable.\n\nExample\n\njulia> set_binary(vref)\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.set_integer","text":"JuMP.set_integer(vref::InfOptVariableRef)\n\nExtend JuMP.set_integer to specify an InfiniteOpt variable as a integer variable. Errors if vref is an binary variable.\n\nExample\n\njulia> set_integery(vref)\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_lower_bound-Tuple{ParameterRef,Number}","page":"Library","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::ParameterRef, lower::Number)\n\nExtend the JuMP.set_lower_bound function to accomodate infinite parameters. Updates the infinite set lower bound if and only if it is an IntervalSet. Errors otherwise.\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Library","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(vref::InfOptVariableRef, lower::Number)\n\nExtend JuMP.set_lower_bound to specify the lower bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_lower_bound(vref, -1)\n\njulia> lower_bound(vref)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_name-Tuple{GeneralConstraintRef,String}","page":"Library","title":"JuMP.set_name","text":"JuMP.set_name(cref::GeneralConstraintRef, name::String)\n\nExtend JuMP.set_name to specify the name of a constraint cref.\n\nExample\n\njulia> set_name(cref, \"new_name\")\n\njulia> name(cref)\nnew_name\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_name-Tuple{GlobalVariableRef,String}","page":"Library","title":"JuMP.set_name","text":"JuMP.set_name(vref::GlobalVariableRef, name::String)\n\nExtend JuMP.set_name to set names of global variables.\n\nExample\n\njulia> set_name(gvref, \"var_name\")\n\njulia> name(t)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_name-Tuple{InfiniteVariableRef,String}","page":"Library","title":"JuMP.set_name","text":"JuMP.set_name(vref::InfiniteVariableRef, root_name::String)\n\nExtend JuMP.set_name to set names of infinite variables. Adds on to root_name the ending (prefs...) where the parameter reference names are listed in the same format as input in the parameter reference tuple.\n\nExample\n\njulia> name(vref)\nold_name(t, x)\n\njulia> set_name(vref, \"new_name\")\n\njulia> name(vref)\nnew_name(t, x)\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_name-Tuple{MeasureRef,String}","page":"Library","title":"JuMP.set_name","text":"JuMP.set_name(mref::MeasureRef, name::String)\n\nExtend JuMP.set_name to specify the name of a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_name-Tuple{ParameterRef,String}","page":"Library","title":"JuMP.set_name","text":"JuMP.set_name(pref::ParameterRef, name::String)\n\nExtend the JuMP.set_name function to accomodate infinite parameters. Set a new base name to be associated with pref.\n\nExample\n\njulia> set_name(t, \"time\")\n\njulia> name(t)\n\"time\"\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_name-Tuple{PointVariableRef,String}","page":"Library","title":"JuMP.set_name","text":"JuMP.set_name(vref::PointVariableRef, name::String)\n\nExtend JuMP.set_name to set the names of point variables.\n\nExample\n\njulia> name(vref)\nold_name\n\njulia> set_name(vref, \"new_name\")\n\njulia> name(vref)\nnew_name\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}","page":"Library","title":"JuMP.set_objective","text":"JuMP.set_objective(model::InfiniteModel, sense::MOI.OptimizationSense,\n                   func::Union{JuMP.AbstractJuMPScalar, Real})\n\nExtend JuMP.set_objective to set the objective of infinite model model. Errors if func contains infinite variables and/or parameters, or if it does not belong to the model.\n\nExample\n\njulia> set_objective(model, MOI.MIN_SENSE, x + measure(g + 2, tdata))\n\njulia> objective_function(model)\nx + measure(g(t) + 2)\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_objective_function-Tuple{InfiniteModel,AbstractJuMPScalar}","page":"Library","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel,\n                            func::JuMP.AbstractJuMPScalar)\n\nExtend JuMP.set_objective_function to set the objective expression of infinite model model. Errors if func contains infinite variables and/or parameters. Also errors if func contains invalid variables.\n\nExample\n\njulia> set_objective_function(model, x + measure(g + 2, tdata))\n\njulia> objective_function(model)\nx + measure(g(t) + 2)\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_objective_function-Tuple{InfiniteModel,Real}","page":"Library","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel, func::Real)\n\nExtend JuMP.set_objective_function to set the objective expression of model with a number.\n\nExample\n\njulia> set_objective_function(model, 3)\n\njulia> objective_function(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}","page":"Library","title":"JuMP.set_objective_sense","text":"JuMP.set_objective_sense(model::InfiniteModel, sense::MOI.OptimizationSense)\n\nExtend JuMP.set_objective_sense to set the objective sense of infinite model model.\n\nExample\n\njulia> set_objective_sense(model, MOI.MIN_SENSE)\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_optimizer-Tuple{InfiniteModel,OptimizerFactory}","page":"Library","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(model::InfiniteModel,\n                   optimizer_factory::JuMP.OptimizerFactory;\n                   bridge_constraints::Bool=true)\n\nExtend JuMP.set_optimizer to set optimizer of infinite models. Specifically, the optimizer of the optimizer model is modified.\n\nExample\n\njulia> set_optimizer(model, with_optimizer(Clp.Optimizer))\n\njulia> optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: SolverName() attribute not implemented by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_silent-Tuple{InfiniteModel}","page":"Library","title":"JuMP.set_silent","text":"JuMP.set_silent(model::InfiniteModel)\n\nExtend JuMP.set_silent for infinite models to take precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Library","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::InfOptVariableRef, value::Number)\n\nExtend JuMP.set_start_value to specify the start value of InfiniteOpt variables.\n\nExample\n\njulia> set_start_value(vref, 1)\n\njulia> start_value(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_upper_bound-Tuple{ParameterRef,Number}","page":"Library","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::ParameterRef, lower::Number)\n\nExtend the JuMP.set_upper_bound function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise.\n\nExample\n\njulia> set_upper_bound(t, 2)\n\njulia> upper_bound(t)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.set_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Library","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(vref::InfOptVariableRef, upper::Number)\n\nExtend JuMP.set_upper_bound to specify the upper bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_upper_bound(vref, 1)\n\njulia> upper_bound(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.start_value","text":"JuMP.start_value(vref::ReducedInfiniteVariableRef)::Union{Nothing, Float64}\n\nExtend JuMP.start_value to return starting value of the original infinite variable of vref if it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.start_value","text":"JuMP.start_value(vref::InfOptVariableRef)::Union{Nothing, Float64}\n\nExtend JuMP.start_value to return starting value of InfiniteOpt variable if it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.termination_status-Tuple{InfiniteModel}","page":"Library","title":"JuMP.termination_status","text":"JuMP.termination_status(model::InfiniteModel)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.unfix","text":"JuMP.unfix(vref::InfOptVariableRef)\n\nExtend JuMP.unfix to unfix vref. Errors if it is not fixed.\n\nExample\n\njulia> unfix(vref)\n\njulia> is_fixed(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.unset_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.unset_binary","text":"JuMP.unset_binary(vref::InfOptVariableRef)\n\nExtend JuMP.unset_binary to unset vref as a binary variable. Errors if it is not binary.\n\njulia> unset_binary(vref)\n\njulia> is_binary(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.unset_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.unset_integer","text":"JuMP.unset_integer(vref::InfOptVariableRef)\n\nExtend JuMP.unset_integer to unset vref as an integer variable. Errors if it is not an integer variable.\n\njulia> unset_integer(vref)\n\njulia> is_integer(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.unset_silent-Tuple{InfiniteModel}","page":"Library","title":"JuMP.unset_silent","text":"JuMP.unset_silent(model::InfiniteModel)\n\nExtend JuMP.unset_silent for infinite models to Neutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.upper_bound-Tuple{ParameterRef}","page":"Library","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::ParameterRef)::Number\n\nExtend the JuMP.upper_bound function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> upper_bound(t)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}","page":"Library","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::ReducedInfiniteVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of the original infinite variable of vref. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Library","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of an InfiniteOpt variable. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.value-Tuple{GeneralVariableRef}","page":"Library","title":"JuMP.value","text":"JuMP.value(vref::GeneralVariableRef)\n\nGet the value of this variable in the result returned by a solver. Use JuMP.has_values to check if a result exists before asking for values.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.variable_by_name-Tuple{InfiniteModel,String}","page":"Library","title":"JuMP.variable_by_name","text":"JuMP.variable_by_name(model::InfiniteModel,\n                      name::String)::Union{GeneralVariableRef, Nothing}\n\nExtend JuMP.variable_by_name for InfiniteModel objects. Return the varaible reference assoociated with a variable name. Errors if multiple variables have the same name. Returns nothing if no such name exists.\n\nExamples\n\njulia> variable_by_name(m, \"var_name\")\nvar_name\n\njulia> variable_by_name(m, \"fake_name\")\n\n\n\n\n\n\n","category":"method"}]
}
