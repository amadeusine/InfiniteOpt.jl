var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A JuMP extension for expressing and solving infinite dimensional optimization problems.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"InfiniteOpt.jl provides a mathematical interface to express and solve optimization problems that entail an infinite dimensional decision space. Such problems stem from areas such as dynamic programming, state-space models, and stochastic programming. InfiniteOpt.jl is meant to facilitate intuitive model definition, automatic transcription into solvable models, permit a wide range of user-defined extensions/behavior, and more. Currently, its capabilities include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JuMP-like macro based parameter and variable definition\nJuMP-like macro based objective and constraint definition\nExtensions to all JuMP modification methods (e.g., delete)\nMeasure abstractions and definition\nAutomatic model transcription and solution\nMuch more.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nCurrently, InfiniteOpt only accepts linear and quadratic expressions. Development is underway to allow for general nonlinear constraints.  ","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"InfiniteOpt.jl is still in its early stages of development but can be installed by entering the following in the package manager.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.1) pkg> add https://github.com/pulsipher/InfiniteOpt.jl","category":"page"},{"location":"#Quick-Start-1","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Below is a brief example of the high-level API.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Revise, InfiniteOpt, JuMP, Clp, Distributions\n\n# Set the problem information\nθ_nom, covar = [0.; 60.; 10.], [80. 0 0; 0 80. 0; 0 0 120.]\nn_z, n_θ, n_d = 3, 3, 3\nc = ones(n_d) / sqrt(n_d)\nnum_samples = 100\n\n# Initialize the model\nm = InfiniteModel(with_optimizer(Clp.Optimizer))\n\n# Set the uncertainty parameters\ndist = MvNormal(θ_nom, covar)\nθs = rand(dist, num_samples)\n@infinite_parameter(m, θ[i = 1:n_θ] in dist, supports = θs[i, :])\n@infinite_parameter(m, 0 <= t <= 10, supports = Vector(0:10))\n\n# Initialize the variables\n@infinite_variable(m, z[1:n_z](θ, t))\n@infinite_variable(m, 0 <= y(θ) <= 100)\n@global_variable(m, d[1:n_d] >= 0)\n\n# Set objective function\nexpect_data = DiscreteMeasureData(θ, ones(num_samples) / num_samples,\n                                  supports(θ), name = \"expect\")\n@objective(m, Min, measure(1 - y, expect_data))\n\n# Set first stage constraints\n@constraint(m, max_cost, sum(c[i] * d[i] for i = 1:n_d) <= 5)\n\n# Set the second stage constraints\n@constraint(m, f1, -z[1] - 35 - d[1] + y <= 0)\n@constraint(m, f2, z[1] - 35 - d[1] + y <= 0)\n@constraint(m, f3, -z[2] - 50 - d[2] + y <= 0)\n@constraint(m, f4, z[1] - 50 - d[2] + y <= 0)\n@constraint(m, h1, z[1] - θ[1] == 0)\n@constraint(m, h2, -z[1] -z[2] + z[3] - θ[2] == 0)\n@constraint(m, h3, z[2] - θ[3] == 0)\n\n# Solve and and obtain results\noptimize!(m)\nif has_values(m)\n    opt_y = value(y)\n    opt_d = value.(d)\n    opt_obj = objective_value(m)\nend","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We acknowledge our support from the Department of Energy under grant DE-SC0014114.","category":"page"},{"location":"guide/install/#Installation-Guide-1","page":"Installation","title":"Installation Guide","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"A complete guide to installing all that is necessary to use InfiniteOpt.jl.","category":"page"},{"location":"guide/install/#Install-Julia-1","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"InfiniteOpt is a Julia package. Thus, we first need have an installation of Julia to get started. An appropriate download can be found here. Alternatively, users with a limited programming background might find it easier to install and use JuliaPro.","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"note: Note\nThis version of InfiniteOpt requires that Julia 1.0 or newer be used.","category":"page"},{"location":"guide/install/#Install-Packages-1","page":"Installation","title":"Install Packages","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Now that Julia has been installed we can add the needed packages. Open up a Julia terminal and enter the package manager:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"julia> ]\n\n(v1.2) pkg>","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Use the add command in the package to manager to add the following packages:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"JuMP\nDistributions","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"For example, to install JuMP we would enter:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add JuMP","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Now let's install InfiniteOpt, because it is not yet a registered Julia package we have to specify the GitHub repository address:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add https://github.com/pulsipher/InfiniteOpt.jl","category":"page"},{"location":"guide/install/#Install-Optimization-Solvers-1","page":"Installation","title":"Install Optimization Solvers","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"InfiniteOpt relies on solvers to solve optimization problems. Many solvers are not native to Julia and might require commercial licenses. A list of currently supported solvers and their corresponding Julia packages is provided in Supported Optimizers.","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"For example, we can install Ipopt which is an open-source nonlinear solver:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add Ipopt","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Now Ipopt can be used as the optimizer (solver) for an infinite model by running:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"julia> using InfiniteOpt, JuMP, Ipopt\n\njulia> model = InfiniteModel(with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Most solver packages follow the ModuleName.Optimizer naming convention, but this may not always be the case. See Infinite Models for more information on defining infinite models and specifying solvers.","category":"page"},{"location":"guide/model/#Infinite-Models-1","page":"Infinite Models","title":"Infinite Models","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"A guide and manual for initializing infinite models and understanding how they work.","category":"page"},{"location":"guide/model/#Overview-1","page":"Infinite Models","title":"Overview","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Infinite models are expressed via the InfiniteModel datatype which is at the core of InfiniteOpt. These model objects are designed to emulate the behavior of Model objects in JuMP. These data objects store the parameters, variables, measures, objective, constraints, and all other data used in InfiniteOpt. This differs from JuMP models which store such information in a MathOptInterface model backend.","category":"page"},{"location":"guide/model/#Basic-Usage-1","page":"Infinite Models","title":"Basic Usage","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Infinite models can be initialized with no arguments by default:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"The optimizer that will be used to solve the model can also be specified at model definition using JuMP's with_optimizer constructor:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Gurobi\n\njulia> model = InfiniteModel(with_optimizer(Gurobi.Optimizer, OutputFlag = 0))\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Gurobi","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Note that any optimizer currently supported by JuMP v0.19.0 or newer is supported for use in InfiniteOpt. For completeness, the table of currently supported optimizers is provided below in Supported Optimizers.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Now you have an initialized InfiniteModel that is ready for your mathematical model to be defined and optimized!","category":"page"},{"location":"guide/model/#Advanced-Definition-Information-1","page":"Infinite Models","title":"Advanced Definition Information","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"As you may have noticed in the above examples, InfiniteModels contain an optimizer model backend which simply corresponds to a JuMP Model that will be used to store and optimize the reformulation of the infinite mathematical model stored in InfiniteModel. It also will contain a mapping between its optimization model and that of the InfiniteModel (e.g., a mapping between the variables and constraints). By default, InfiniteModels use a TranscriptionModel optimizer model backend which will store a transcribed (discretized) version of the infinite model. More information on the internal use of TranscriptionModels is provided in Model Transcription.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"All the arguments used with the InfiniteModel constructor (e.g., the optimizer) are simply passed on and stored in the optimizer model backend. Thus, any argument supported by JuMP.Model can be passed on to the optimizer model by including it in the InfiniteModel constructor. For example, we can specify the caching_mode keyword argument in the InfiniteModel call to use in the definition of the optimizer model:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Gurobi, MathOptInterface\n\njulia> const MOIU = MathOptInterface.Utilities\n\njulia> model = InfiniteModel(with_optimizer(Gurobi.Optimizer),\n                             caching_mode = MOIU.MANUAL)\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: MANUAL\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Gurobi","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Notice that the model mode of the optimizer model is now MANUAL.","category":"page"},{"location":"guide/model/#Supported-Optimizers-1","page":"Infinite Models","title":"Supported Optimizers","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"InfiniteOpt can use any optimizer that is supported by JuMP v0.19.0 or newer. In spirit of providing complete documentation, the table of optimizers currently supported by JuMP.jl is provided below. This information comes directly from their documentation pages. Please refer to JuMP documentation for additional optimizer information on installation and use.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Solver Julia Package License Supports\nArtelys Knitro KNITRO.jl Comm. LP, MILP, SOCP, MISOCP, NLP, MINLP\nCbc Cbc.jl EPL MILP\nCDCS CDCS.jl GPL LP, SOCP, SDP\nClp Clp.jl EPL LP\nCOSMO COSMO.jl Apache LP, QP, SOCP, SDP\nCPLEX CPLEX.jl Comm. LP, MILP, SOCP, MISOCP\nCSDP CSDP.jl EPL LP, SDP\nECOS ECOS.jl GPL LP, SOCP\nFICO Xpress Xpress.jl Comm. LP, MILP, SOCP, MISOCP\nGLPK GLPK.jl GPL LP, MILP\nGurobi Gurobi.jl Comm. LP, MILP, SOCP, MISOCP\nIpopt Ipopt.jl EPL LP, QP, NLP\nJuniper Juniper.jl MIT MISOCP, MINLP\nMOSEK MosekTools.jl Comm. LP, MILP, SOCP, MISOCP, SDP\nOSQP OSQP.jl Apache LP, QP\nProxSDP ProxSDP.jl MIT LP, SOCP, SDP\nSCIP SCIP.jl ZIB MILP, MINLP\nSCS SCS.jl MIT LP, SOCP, SDP\nSDPA SDPA.jl GPL LP, SDP\nSeDuMi SeDuMi.jl GPL LP, SOCP, SDP","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Where:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex   quadratic constraints and/or objective)\nMILP = Mixed-integer linear programming\nNLP = Nonlinear programming\nMINLP = Mixed-integer nonlinear programming\nSDP = Semidefinite programming\nMISDP = Mixed-integer semidefinite programming","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"You may also use AmplNLWriter to access solvers that support the nl format. Such solvers include Bonmin and Couenne. See a more complete list here.","category":"page"},{"location":"guide/model/#Datatypes-1","page":"Infinite Models","title":"Datatypes","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"InfiniteModel","category":"page"},{"location":"guide/model/#InfiniteOpt.InfiniteModel","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel <: JuMP.AbstractModel\n\nA DataType for storing all of the mathematical modeling information needed to model an optmization problem with an infinite dimensional decision space.\n\nFields\n\nnext_meas_index::Int Index - 1 of next measure.\nmeasures::Dict{Int, Measure} Measure indices to measure datatypes.\nmeas_to_name::Dict{Int, String} Measure indices to names.\nmeas_to_constrs::Dict{Int, Vector{Int}} Measure indices to dependent                                           constraint indices.\nmeas_to_meas::Dict{Int, Vector{Int}} Measure indices to dependent                                        measure indices.\nmeas_in_objective::Dict{Int, Bool} Measure indices to if used in objective.\nnext_param_index::Int Index - 1 of next infinite parameter.\nnext_param_id::Int Index - 1 of the next infinite parameter group.\nparams::Dict{Int, InfOptParameter} Infinite parameter indices to parameter                                      datatype.\nparam_to_name::Dict{Int, String} Infinite parameter indices to names.\nname_to_param::Union{Dict{String, Int}, Nothing} Names to infinite                                                    parameters.\nparam_to_group_id::Dict{Int, Int} Infinite parameter indices to group IDs.\nparam_to_constrs::Dict{Int, Vector{Int}} Infinite parameter indices to list                                            of dependent constraint indices.\nparam_to_meas::Dict{Int, Vector{Int}} Infinite parameter indices to list                                         of dependent measure indices.\nparam_to_vars::Dict{Int, Vector{Int}} Infinite parameter indices to list                                         of dependent variable indices.\nnext_var_index::Int Index - 1 of next variable index.\nvars::Dict{Int, Dict{Int, Union{InfOptVariable, ReducedVariable}} Variable                                                 indices to variable datatype.\nvar_to_name::Dict{Int, String} Variable indices to names.\nname_to_var::Union{Dict{String, Int}, Nothing} Variable names to indices.\nvar_to_lower_bound::Dict{Int, Int} Variable indices to lower bound index.\nvar_to_upper_bound::Dict{Int, Int} Variable indices to upper bound index.\nvar_to_fix::Dict{Int, Int} Variable indices to fix index.\nvar_to_zero_one::Dict{Int, Int} Variable indices to binary index.\nvar_to_integrality::Dict{Int, Int} Variable indices to integer index.\nvar_to_constrs::Dict{Int, Vector{Int}} Variable indices to dependent                                          constraint indices.\nvar_to_meas::Dict{Int, Vector{Int}} Variable indices to dependent                                       measure indices.\nvar_in_objective::Dict{Int, Bool} Variable indices to if used in objective.\ninfinite_to_points::Dict{Int, Vector{Int}} Infinite variable indices to                                              dependent point variable indices.\ninfinite_to_reduced::Dict{Int, Vector{Int}} Infinite variable indices to                                              dependent reduced variable indices.\nreduced_to_constrs::Dict{Int, Vector{Int}} Reduced variable indices to dependent                                              constraint indices.\nreduced_to_meas::Dict{Int, Vector{Int}} Reduced variable indices to dependent                                           measure indices.\nreduced_info::Dict{Int, AbstractReducedInfo} Reduced variable indices to                                                reduced variable information.\nnext_constr_index::Int Index - 1 of next constraint.\nconstrs::Dict{Int, JuMP.AbstractConstraint} Constraint indices to constraint                                               datatypes.\nconstr_to_name::Dict{Int, String} Constraint indices to names.\nname_to_constr::Union{Dict{String, Int}, Nothing} Constraint names to                                                     indices.\nconstr_in_var_info::Dict{Int, Bool} Constraint indices to if related to                                       variable information constraints.\nobjective_sense::MOI.OptimizationSense Objective sense.\nobjective_function::JuMP.AbstractJuMPScalar Finite scalar function.\nobj_dict::Dict{Symbol, Any} Store Julia symbols used with InfiniteModel\noptimizer_factory::Union{JuMP.OptimizerFactory, Nothing} Optimizer                                                            information.\noptimizer_model::JuMP.Model Model used to solve InfiniteModel\nready_to_optimize::Bool Is the optimizer_model up to date.\n\n\n\n\n\n","category":"type"},{"location":"guide/model/#Methods-1","page":"Infinite Models","title":"Methods","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"InfiniteModel()","category":"page"},{"location":"guide/model/#InfiniteOpt.InfiniteModel-Tuple{}","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel([optimizer_factory::JuMP.OptimizerFactory];\n              [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,\n              bridge_constraints::Bool = true])\n\nReturn a new infinite model where an optimizer is specified if an optimizer_factory is given via JuMP.with_optimizer. The optimizer can also later be set with the JuMP.optimize! call. By default the optimizer_model data field is initialized with a TranscriptionModel, but a different type of model can be assigned via set_optimizer_model as can be required by extensions.\n\nExample\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> model = InfiniteModel(with_optimizer(Gurobi.Optimizer))\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Gurobi\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#Infinite-Parameters-1","page":"Infinite Parameters","title":"Infinite Parameters","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"A guide and manual to the definition and use of infinite parameters in InfiniteOpt.","category":"page"},{"location":"guide/parameter/#Overview-1","page":"Infinite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/parameter/#Basic-Usage-1","page":"Infinite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/parameter/#Infinite-Sets-1","page":"Infinite Parameters","title":"Infinite Sets","text":"","category":"section"},{"location":"guide/parameter/#Parameter-Definition-1","page":"Infinite Parameters","title":"Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/#Parameter-Use-1","page":"Infinite Parameters","title":"Parameter Use","text":"","category":"section"},{"location":"guide/parameter/#Datatypes-1","page":"Infinite Parameters","title":"Datatypes","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Pages   = [\"parameter.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"AbstractInfiniteSet\nIntervalSet\nDistributionSet\nInfOptParameter\nParameterRef","category":"page"},{"location":"guide/parameter/#InfiniteOpt.AbstractInfiniteSet","page":"Infinite Parameters","title":"InfiniteOpt.AbstractInfiniteSet","text":"AbstractInfiniteSet\n\nAn abstract type for sets that characterize infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.IntervalSet","page":"Infinite Parameters","title":"InfiniteOpt.IntervalSet","text":"IntervalSet <: AbstractInfiniteSet\n\nA DataType that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval.\n\nFields\n\nlower_bound::Float64 Lower bound of the infinite parameter.\nupper_bound::Float64 Upper bound of the infinite parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.DistributionSet","page":"Infinite Parameters","title":"InfiniteOpt.DistributionSet","text":"DistributionSet{T <: Distributions.NonMatrixDistribution} <: AbstractInfiniteSet\n\nA DataType that stores the distribution characterizing infinite parameters that are random.\n\nFields\n\ndistribution::T Distribution of the random parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.InfOptParameter","page":"Infinite Parameters","title":"InfiniteOpt.InfOptParameter","text":"InfOptParameter{T <: AbstractInfiniteSet} <: JuMP.AbstractVariable\n\nA DataType for storing core infinite parameter information.\n\nFields\n\nset::T The infinite set that characterizes the parameter.\nsupports::Vector{<:Number} The support points used to discretize this                              parameter.\nindependent::Bool Is independent of other parameters that share its group ID                     number.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.ParameterRef","page":"Infinite Parameters","title":"InfiniteOpt.ParameterRef","text":"ParameterRef <: GeneralVariableRef\n\nA DataType for untranscripted infinite parameters references that parameterize the infinite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#Methods-1","page":"Infinite Parameters","title":"Methods","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Pages   = [\"parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"IntervalSet(::Number, ::Number)\nadd_parameter\nbuild_parameter\n@infinite_parameter\nused_by_constraint(::ParameterRef)\nused_by_measure(::ParameterRef)\nused_by_variable(::ParameterRef)\nis_used(::ParameterRef)\nJuMP.delete(::InfiniteModel, ::ParameterRef)\nJuMP.is_valid(::InfiniteModel, ::ParameterRef)\nJuMP.name(::ParameterRef)\nJuMP.set_name(::ParameterRef, ::String)\nnum_parameters(::InfiniteModel)\ninfinite_set(::ParameterRef)\nset_infinite_set(::ParameterRef, ::AbstractInfiniteSet)\nJuMP.has_lower_bound(::ParameterRef)\nJuMP.lower_bound(::ParameterRef)\nJuMP.set_lower_bound(::ParameterRef, ::Number)\nJuMP.has_upper_bound(::ParameterRef)\nJuMP.upper_bound(::ParameterRef)\nJuMP.set_upper_bound(::ParameterRef, ::Number)\nnum_supports(::ParameterRef)\nhas_supports(::ParameterRef)\nsupports(::ParameterRef)\nsupports(::AbstractArray{<:ParameterRef})\nset_supports(::ParameterRef, ::Vector{<:Number})\nadd_supports(::ParameterRef, ::Union{Number, Vector{<:Number}})\ndelete_supports(::ParameterRef)\ngroup_id(::ParameterRef)\ngroup_id(::AbstractArray{<:ParameterRef})\nis_independent(::ParameterRef)\nset_independent(::ParameterRef)\nunset_independent(::ParameterRef)\nparameter_by_name(::InfiniteModel, ::String)\nall_parameters(::InfiniteModel)","category":"page"},{"location":"guide/parameter/#InfiniteOpt.IntervalSet-Tuple{Number,Number}","page":"Infinite Parameters","title":"InfiniteOpt.IntervalSet","text":"IntervalSet(lower_bound::Number, upper_bound::Number)\n\nA constructor for IntervalSet that converts values of type Number to values of type Float64 as required by IntervalSet.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_parameter","page":"Infinite Parameters","title":"InfiniteOpt.add_parameter","text":"add_parameter(model::InfiniteModel, p::InfOptParameter,\n              name::String=\"\")::ParameterRef\n\nReturns a ParameterRef associated with the parameter p that is added to model. This adds a parameter to the model in a manner similar to JuMP.add_variable. This can be used to add parameters with the use of @infinite_parameter. build_parameter should be used to construct p.\n\nExample\n\njulia> p = build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)\n\njulia> param_ref = add_parameter(model, p, \"name\")\nname\n\n\n\n\n\n","category":"function"},{"location":"guide/parameter/#InfiniteOpt.build_parameter","page":"Infinite Parameters","title":"InfiniteOpt.build_parameter","text":"build_parameter(_error::Function, set::AbstractInfiniteSet,\n                [num_params::Int = 1;\n                supports::Union{Number, Vector{<:Number}} = Number[],\n                independent::Bool = false])::InfOptParameter\n\nReturns a InfOptParameter given the appropriate information. This is analagous to JuMP.build_variable. Errors if supports violate the bounds associated set. Also errors if set contains a multivariate distribution with a different dimension than num_params. This is meant to primarily serve as a helper method for @infinite_parameter.\n\nExample\n\njulia> build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)\n\n\n\n\n\n","category":"function"},{"location":"guide/parameter/#InfiniteOpt.@infinite_parameter","page":"Infinite Parameters","title":"InfiniteOpt.@infinite_parameter","text":"@infinite_parameter(model, kw_args...)\n\nAdd an anonymous infinite parameter to the model model described by the keyword arguments kw_args and returns the parameter reference.\n\n@infinite_parameter(model, expr, kw_args...)\n\nAdd a parameter to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. (note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, and the symbo in can be used instead of ∈) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nlb ≤ varexpr ≤ ub creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\n\nThe expression varexpr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the parameter lower bound for an interval set.\nupper_bound: Sets the value of the parameter upper bound for an interval set.\nset: The InfiniteSet characterizing the parameters see IntervalSet  and DistributionSet.\ndistribution: Sets the Distributions.jl distribution object that characterizes the parameters.\nsupports: Sets the support points for the parameters.\nindependent: Specifies if the each parameter is independent from each other or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(m, 0 <= x <= 1)\nx\n\njulia> supps = [[0, 1, 2], [-1, 1]];\n\njulia> @infinite_parameter(m, y[i = 1:2] in Normal(), supports = supps[i])\n2-element Array{ParameterRef,1}:\n y[1]\n y[2]\n\njulia> z = @infinite_parameter(m, [\"a\", \"b\"], distribution = Uniform(), independent = true)\n2-dimensional DenseAxisArray{ParameterRef,2,...} with index sets:\n    Dimension 1, \"a\"\n    Dimension 2, \"b\"\nAnd data, a 1×1 Array{ParameterRef,2}:\n noname\n\n\n\n\n\n","category":"macro"},{"location":"guide/parameter/#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::ParameterRef)::Bool\n\nReturn true if pref is used by a constraint or false otherwise.\n\nExample\n\njulia> used_by_constraint(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_measure-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::ParameterRef)::Bool\n\nReturn true if pref is used by a measure or false otherwise.\n\nExample\n\njulia> used_by_measure(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_variable-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_variable","text":"used_by_variable(pref::ParameterRef)::Bool\n\nReturn true if pref is used by an infinite variable or false otherwise.\n\nExample\n\njulia> used_by_variable(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.is_used-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_used","text":"is_used(pref::ParameterRef)::Bool\n\nReturn true if pref is used in the model or false otherwise.\n\nExample\n\njulia> is_used(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.delete-Tuple{InfiniteModel,ParameterRef}","page":"Infinite Parameters","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, pref::ParameterRef)\n\nExtend JuMP.delete to delete infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on pref are updated to exclude it. Errors if the parameter is contained in an AbstractMeasureData datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that _check_param_in_data(pref, measure_data) needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used.\n\nExample\n\njulia> print(model)\nMin measure(g(t, x)*t + x) + z\nSubject to\n z >= 0.0\n g(t, x) + z >= 42.0\n g(0.5, x) == 0\n t in [0, 6]\n x in [0, 1]\n\njulia> delete(model, x)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n g(t) + z >= 42.0\n g(0.5) == 0\n z >= 0.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}","page":"Infinite Parameters","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, pref::ParameterRef)::Bool\n\nExtend the JuMP.is_valid function to accomodate infinite parameters. Returns true if the InfiniteModel stored in pref matches model and if the parameter index is used by model. It returns false otherwise.\n\nExample\n\njulia> is_valid(model, t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.name-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.name","text":"JuMP.name(pref::ParameterRef)::String\n\nExtend the JuMP.name function to accomodate infinite parameters. Returns the name string associated with pref.\n\nExample\n\njulia> name(t)\n\"t\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_name-Tuple{ParameterRef,String}","page":"Infinite Parameters","title":"JuMP.set_name","text":"JuMP.set_name(pref::ParameterRef, name::String)\n\nExtend the JuMP.set_name function to accomodate infinite parameters. Set a new base name to be associated with pref.\n\nExample\n\njulia> set_name(t, \"time\")\n\njulia> name(t)\n\"time\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_parameters-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.num_parameters","text":"num_parameters(model::InfiniteModel)::Int\n\nReturn the number of infinite parameters currently present in model.\n\nExample\n\njulia> num_parameters(model)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.infinite_set-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_set","text":"infinite_set(pref::ParameterRef)::AbstractInfiniteSet\n\nReturn the infinite set associated with pref.\n\nExample\n\njulia> infinite_set(t)\nIntervalSet(0.0, 3.0)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(pref::ParameterRef, set::AbstractInfiniteSet)\n\nSpecify the infinite set of pref.\n\nExample\n\njulia> set_infinite_set(t, IntervalSet(0, 1))\n\njulia> infinite_set(t)\nIntervalSet(0.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_lower_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::ParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined lower bound or if a lower bound can be found.\n\nExample\n\njulia> has_lower_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.lower_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::ParameterRef)::Number\n\nExtend the JuMP.lower_bound function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(t)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_lower_bound-Tuple{ParameterRef,Number}","page":"Infinite Parameters","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::ParameterRef, lower::Number)\n\nExtend the JuMP.set_lower_bound function to accomodate infinite parameters. Updates the infinite set lower bound if and only if it is an IntervalSet. Errors otherwise.\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_upper_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::ParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined upper bound or if a upper bound can be found.\n\nExample\n\njulia> has_upper_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.upper_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::ParameterRef)::Number\n\nExtend the JuMP.upper_bound function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> upper_bound(t)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_upper_bound-Tuple{ParameterRef,Number}","page":"Infinite Parameters","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::ParameterRef, lower::Number)\n\nExtend the JuMP.set_upper_bound function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise.\n\nExample\n\njulia> set_upper_bound(t, 2)\n\njulia> upper_bound(t)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(pref::ParameterRef)::Int\n\nReturn the number of support points associated with pref.\n\nExample\n\njulia> num_supports(t)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.has_supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(pref::ParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(pref::ParameterRef)::Vector\n\nReturn the support points associated with pref. Errors if there are no supports.\n\nExample\n\njulia> supports(t)\n1-element Array{Int64,1}:\n 1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{AbstractArray{#s4,N} where N where #s4<:ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(prefs::AbstractArray{<:ParameterRef})::Vector\n\nReturn the support points associated with an array of prefs formatted as a vector of SparseAxisArrays following the format of the input array. If the parameters are not independent then the supports of each parameter are simply spliced together. Alternatively can call supports. to more efficiently obtain an array of the same input format whose parameter references have been replaced with their supports. Errors if all the parameter references do not have the same group ID number (were intialized together as an array) or if the nonindependent parameters have support vectors of different lengths. If the parameters are independent then all the unique combinations are identified and returned as supports. Warning this operation is computationally expensive if there exist a large number of combinations.\n\nExample\n\njulia> x = @infinite_parameter(model, [i = 1:2], set = IntervalSet(-1, 1),\n                               base_name = \"x\", independent = true)\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> for i = 1:length(x)\n           set_supports(x[i], [-1, 1])\n       end\n\njulia> supports(x)\n4-element Array{JuMP.Containers.SparseAxisArray,1}:\n   [2]  =  -1\n  [1]  =  -1\n   [2]  =  1\n  [1]  =  -1\n   [2]  =  -1\n  [1]  =  1\n   [2]  =  1\n  [1]  =  1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s4,1} where #s4<:Number}","page":"Infinite Parameters","title":"InfiniteOpt.set_supports","text":"set_supports(pref::ParameterRef, supports::Vector{<:Number})\n\nSpecify the support points for pref. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. Note that this will overwrite existing supports.\n\nExample\n\njulia> set_supports(t, [0, 1])\n\njulia> supports(t)\n2-element Array{Int64,1}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s4,1} where #s4<:Number}}","page":"Infinite Parameters","title":"InfiniteOpt.add_supports","text":"add_supports(pref::ParameterRef, supports::Union{Number, Vector{<:Number}})\n\nAdd additional support points for pref.\n\nExample\n\njulia> add_supports(t, 0.5)\n\njulia> supports(t)\n3-element Array{Float64,1}:\n 0.0\n 0.5\n 1.0\n\njulia> add_supports(t, [0.25, 1])\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 0.25\n 0.5\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.delete_supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.delete_supports","text":"delete_supports(pref::ParameterRef)\n\nDelete the support points for pref.\n\nExample\n\njulia> delete_supports(t)\n\njulia> supports(t)\nERROR: Parameter test does not have supports.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.group_id-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.group_id","text":"group_id(pref::ParameterRef)::Int\n\nReturn the group ID number for pref.\n\nExample\n\njulia> group_id(t)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.group_id-Tuple{AbstractArray{#s4,N} where N where #s4<:ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.group_id","text":"group_id(prefs::AbstractArray{<:ParameterRef})::Int\n\nReturn the group ID number for a group of prefs. Error if contains multiple groups.\n\nExample\n\njulia> group_id([x[1], x[2]])\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.is_independent-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_independent","text":"is_independent(pref::ParameterRef)::Bool\n\nReturns true for pref if it is independent or false otherwise.\n\nExample\n\njulia> is_independent(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_independent-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.set_independent","text":"set_independent(pref::ParameterRef)\n\nSpecify that pref be independent.\n\nExample\n\njulia> set_independent(t)\n\njulia> is_independent(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.unset_independent-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.unset_independent","text":"unset_independent(pref::ParameterRef)\n\nSpecify that pref be not independent.\n\nExample\n\njulia> unset_independent(t)\n\njulia> is_independent(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}","page":"Infinite Parameters","title":"InfiniteOpt.parameter_by_name","text":"parameter_by_name(model::InfiniteModel, name::String)::Union{ParameterRef,\n                                                             Nothing}\n\nReturn the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.\n\nExample\n\njulia> parameter_by_name(model, \"t\")\nt\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.all_parameters-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.all_parameters","text":"all_parameters(model::InfiniteModel)::Vector{ParameterRef}\n\nReturn all of the infinite parameter references currently in model.\n\nExample\n\njulia> all_parameters(model)\n3-element Array{ParameterRef,1}:\n t\n x[1]\n x[2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#Variables-1","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"A guide and manual for the definition and use of variables in InfiniteOpt.","category":"page"},{"location":"guide/variable/#Overview-1","page":"Variables","title":"Overview","text":"","category":"section"},{"location":"guide/variable/#Basic-Usage-1","page":"Variables","title":"Basic Usage","text":"","category":"section"},{"location":"guide/variable/#Infinite-Variable-Definition-1","page":"Variables","title":"Infinite Variable Definition","text":"","category":"section"},{"location":"guide/variable/#Point-Variable-Definition-1","page":"Variables","title":"Point Variable Definition","text":"","category":"section"},{"location":"guide/variable/#Global-Variable-Definition-1","page":"Variables","title":"Global Variable Definition","text":"","category":"section"},{"location":"guide/variable/#Manipulation-1","page":"Variables","title":"Manipulation","text":"","category":"section"},{"location":"guide/variable/#Datatypes-1","page":"Variables","title":"Datatypes","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Pages   = [\"variable.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"InfOptVariable\nInfiniteVariable\nPointVariable\nGlobalVariable\nGeneralVariableRef\nMeasureFiniteVariableRef\nFiniteVariableRef\nInfiniteVariableRef\nPointVariableRef\nGlobalVariableRef","category":"page"},{"location":"guide/variable/#InfiniteOpt.InfOptVariable","page":"Variables","title":"InfiniteOpt.InfOptVariable","text":"InfOptVariable <: JuMP.AbstractVariable\n\nAn abstract type for infinite, point, and global variables.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariable","page":"Variables","title":"InfiniteOpt.InfiniteVariable","text":"InfiniteVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing core infinite variable information. Note each element of the parameter reference tuple must contain either a single ParameterRef or an AbstractArray of ParameterRefs where each ParameterRef has the same group ID number.\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP variable information.\nparameter_refs::Tuple The infinite parameters(s) that parameterize the                         variable.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariable","page":"Variables","title":"InfiniteOpt.PointVariable","text":"PointVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing point variable information. Note that the elements parameter_values field must match the format of the parameter reference tuple defined in InfiniteVariable\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP Variable information.\ninfinite_variable_ref::InfiniteVariableRef The infinite variable associated                                              with the point variable.\nparameter_values::Tuple The infinite parameter values defining the point.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.GlobalVariable","page":"Variables","title":"InfiniteOpt.GlobalVariable","text":"GlobalVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing global variable information.\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP variable information.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.GeneralVariableRef","page":"Variables","title":"InfiniteOpt.GeneralVariableRef","text":"GeneralVariableRef <: JuMP.AbstractVariableRef\n\nAn abstract type to for variable references used with infinite models.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.MeasureFiniteVariableRef","page":"Variables","title":"InfiniteOpt.MeasureFiniteVariableRef","text":"MeasureFiniteVariableRef <: GeneralVariableRef\n\nAn abstract type to define finite variable and measure references.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.FiniteVariableRef","page":"Variables","title":"InfiniteOpt.FiniteVariableRef","text":"FiniteVariableRef <: GeneralVariableRef\n\nAn abstract type to define new finite variable references.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariableRef","page":"Variables","title":"InfiniteOpt.InfiniteVariableRef","text":"InfiniteVariableRef <: GeneralVariableRef\n\nA DataType for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariableRef","page":"Variables","title":"InfiniteOpt.PointVariableRef","text":"PointVariableRef <: FiniteVariableRef\n\nA DataType for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.GlobalVariableRef","page":"Variables","title":"InfiniteOpt.GlobalVariableRef","text":"GlobalVariableRef <: FiniteVariableRef\n\nA DataType for finite fixed variable references (e.g., first stage variables, steady-state variables).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#Methods-1","page":"Variables","title":"Methods","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Pages   = [\"variable.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"JuMP.build_variable(::Function, ::JuMP.VariableInfo, ::Symbol)\nJuMP.add_variable(::InfiniteModel, ::InfOptVariable, ::String)\n@infinite_variable\n@point_variable\n@global_variable\nJuMP.owner_model(::GeneralVariableRef)\nJuMP.index(::GeneralVariableRef)\nused_by_constraint(::InfOptVariableRef)\nused_by_measure(::InfOptVariableRef)\nused_by_objective(::InfOptVariableRef)\nis_used(::InfOptVariableRef)\nused_by_point_variable(::InfiniteVariableRef)\nused_by_reduced_variable(::InfiniteVariableRef)\nis_used(::InfiniteVariableRef)\nJuMP.delete(::InfiniteModel, ::InfOptVariableRef)\nJuMP.is_valid(::InfiniteModel, ::InfOptVariableRef)\nJuMP.num_variables(::InfiniteModel)\nJuMP.has_lower_bound(::InfOptVariableRef)\nJuMP.lower_bound(::InfOptVariableRef)\nJuMP.set_lower_bound(::InfOptVariableRef, ::Number)\nJuMP.LowerBoundRef(::InfOptVariableRef)\nJuMP.delete_lower_bound(::InfOptVariableRef)\nJuMP.has_upper_bound(::InfOptVariableRef)\nJuMP.upper_bound(::InfOptVariableRef)\nJuMP.set_upper_bound(::InfOptVariableRef, ::Number)\nJuMP.UpperBoundRef(::InfOptVariableRef)\nJuMP.delete_upper_bound(::InfOptVariableRef)\nJuMP.is_fixed(::InfOptVariableRef)\nJuMP.fix_value(::InfOptVariableRef)\nJuMP.fix(::InfOptVariableRef, ::Number; ::Bool)\nJuMP.FixRef(::InfOptVariableRef)\nJuMP.unfix(::InfOptVariableRef)\nJuMP.start_value(::InfOptVariableRef)\nJuMP.set_start_value(::InfOptVariableRef, ::Number)\nJuMP.is_binary(::InfOptVariableRef)\nJuMP.set_binary(::InfOptVariableRef)\nJuMP.BinaryRef(::InfOptVariableRef)\nJuMP.unset_binary(::InfOptVariableRef)\nJuMP.is_integer(::InfOptVariableRef)\nJuMP.set_integer(::InfOptVariableRef)\nJuMP.IntegerRef(::InfOptVariableRef)\nJuMP.unset_integer(::InfOptVariableRef)\nJuMP.name(::InfOptVariableRef)\nJuMP.set_name(::InfiniteVariableRef, ::String)\nJuMP.set_name(::PointVariableRef, ::String)\nJuMP.set_name(::GlobalVariableRef, ::String)\nparameter_refs(::InfiniteVariableRef)\nset_parameter_refs(::InfiniteVariableRef, ::Tuple)\nadd_parameter_ref(::InfiniteVariableRef,::Union{ParameterRef, AbstractArray{<:ParameterRef}})\ninfinite_variable_ref(::PointVariableRef)\nparameter_values(::PointVariableRef)\nJuMP.variable_by_name(::InfiniteModel, ::String)\nJuMP.all_variables(::InfiniteModel)","category":"page"},{"location":"guide/variable/#JuMP.build_variable-Tuple{Function,VariableInfo,Symbol}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::JuMP.VariableInfo,\n                    var_type::Symbol;\n                    parameter_refs::Union{ParameterRef,\n                                          AbstractArray{<:ParameterRef},\n                                          Tuple, Nothing} = nothing,\n                    infinite_variable_ref::Union{InfiniteVariableRef,\n                                                 Nothing} = nothing,\n                    parameter_values::Union{Number, AbstractArray{<:Number},\n                                            Tuple, Nothing} = nothing,\n                    error::Union{Function, Nothing} = nothing,\n                    extra_kw_args...)\n\nExtend the JuMP.build_variable function to accomodate InfiniteOpt variable types. Returns the appropriate variable Datatype (i.e., InfiniteVariable, PointVariable, and GlobalVariable). Primarily this method is to be used internally by the appropriate constructor macros @infinite_variable, @point_variable, and @global_variable. However, it can be called manually to build InfiniteOpt variables. Errors if an unneeded keyword argument is given or if the keywoard arguments are formatted incorrectly (e.g., parameter_refs contains repeated parameter references when an infinite variable is defined). Also errors if needed kewword arguments are negated.\n\nExamples\n\njulia> @infinite_parameter(m, 0 <= t <= 1)\nt\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t)\nInfiniteVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}\n(false, 0, false, 0, false, 0, false, 0, false, false), (t,))\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5)\nPointVariable{Int64,Int64,Int64,Float64}(VariableInfo{Int64,Int64,Int64,Float64}\n(false, 0, false, 0, false, 0, true, 0.0, false, false), var_name(t), (0.5,))\n\njulia> gb_var = build_variable(error, info, Global)\nGlobalVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}\n(false, 0, false, 0, false, 0, false, 0, false, false))\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, v::InfOptVariable, name::String = \"\")\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt variable types. Adds a variable to an infinite model model and returns an appropriate variable reference (i.e., InfiniteVariableRef, PointVariableRef, or GlobalVariableRef). Primarily intended to be an internal function of the constructor macros @infinite_variable, @point_variable, and @global_variable. However, it can be used in combination with JuMP.build_variable to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in v.\n\nExamples\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t);\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5);\n\njulia> pvref = add_variable(m, pt_var, \"var_alias\")\nvar_alias\n\njulia> gb_var = build_variable(error, info, Global)\n\njulia> gvref = add_variable(m, gb_var, \"var_name\")\nvar_name\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.@infinite_variable","page":"Variables","title":"InfiniteOpt.@infinite_variable","text":"@infinte_variable(model, kw_args...)\n\nAdd an anonymous infinite variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the parameter_refs keyword is required in this case.\n\n@infinite_variable(model, varexpr, args..., kw_args...)\n\nAdd an infinite variable to model described by the expression var_expr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname(params...) creating a scalar real variable of name varname with infinite parameters params... see parameter_refs for format.\nvarname[...] or [...] creating a container of variables.\nvarname[...](params...) or [...] creating a container of variables with infinite parameters params... in the first case.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\nparameter_refs: This is mandatory if not specified in varexpr. Can be a single parameter reference, a single parameter array with parameters defined in the same call of @infinite_parameter (i.e., have same group ID), or a tuple where each element is either of the first two options listed.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. Furthermore, the parameter reference tuple is appended on the end of the name i.e., base_name(params...) or base_name[...](params...).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{ParameterRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> x = @infinite_variable(model, parameter_refs = (t, w), base_name = \"x\",\n                              lower_bound = 0)\nx(t, w)\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{InfiniteVariableRef,1}:\n y[1](t)\n y[2](t)\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@point_variable","page":"Variables","title":"InfiniteOpt.@point_variable","text":"@point_variable(model, kw_args...)\n\nAdd an anonymous point variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the infinite_variable_ref and parameter_values keywords are required in this case.\n\n@point_variable(model, infvarexpr, varexpr, args..., kw_args...)\n\nAdd a point variable to model described by the expression varexpr, the positional arguments args, and the keyword arguments kw_args and the infinite variable expr infvarexpr. The expression infvarexpr specifies the infinite variable this point variable corresponds to and the values at which the parameters are evaluated and must be of the form: infvar(param_values...) where the parameter values param_values... are listed in the same format as they are in teh definition of infvar. The expression varexpr is used to define variable specific bounds and whose name is used as an alias for the point variable which is simply the infinite variable evaluated at the values indicated. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nNote that be default a point variable inherits all of the same properties as  the infinite variable it corresponds to, but that these can be overwritten  by specifying properties such as lower bounds, fix values, etc.\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of alias name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\ninfinite_variable_ref: Sets the infinite variable reference that the point variable is associated with.\nparameter_refs: Sets the values of the infinite parameters of the infinite variable at which this poitn variable is evaluated at. Must be of the same format of that specified for the parameters in the definition of the infinite variable.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. This serves as the alias for infvarexpr (the infinite variable evaluated at particular parameter values).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{ParameterRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> @point_variable(model, x(0, [0, 0]), x0 <= 1)\nx0\n\njulia> x0 = @point_variable(model, x(0, [0, 0]), upper_bound = 1, base_name = \"x0\")\nx0\n\njulia> x0 = @point_variable(model, upper_bound = 1, base_name = \"x0\",\n                            infinite_variable_ref = x, parameter_values = (0, [0, 0]))\nx0\n\njulia> @point_variable(model, x([0, 1][i], [0, 0]), xf[i = 1:2])\n2-element Array{PointVariableRef,1}:\n xf[1]\n xf[2]\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{InfiniteVariableRef,1}:\ny[1](t)\ny[2](t)\n\njulia> @point_variable(model, y[i](0), y0[i = 1:2], Bin)\n2-element Array{PointVariableRef,1}:\n y0[1]\n y0[2]\n\n julia> y0 = @point_variable(model, [i = 1:2], binary = true, base_name = \"y0\",\n                             infinite_variable_ref = y[i], parameter_values = 0)\n 2-element Array{PointVariableRef,1}:\n  y0[1]\n  y0[2]\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@global_variable","page":"Variables","title":"InfiniteOpt.@global_variable","text":"@global_variable(model, kw_args...)\n\nAdd an anonymous global variable to the model model described by the keyword arguments kw_args and returns the variable reference.\n\n@global_variable(model, varexpr, args..., kw_args...)\n\nAdd a global variable to model described by the expression varexpr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @global_variable(model, x)\nx\n\njulia> @global_variable(model, 0 <= y <= 4, Bin)\ny\n\njulia> y = @global_variable(model, lower_bound = 0, upper_bound = 4,\n                            binary = true, base_name = \"y\")\ny\n\njulia @global_variable(model, z[2:3] == 0)\n1-dimensional DenseAxisArray{GlobalVariableRef,1,...} with index sets:\n    Dimension 1, 2:3\nAnd data, a 2-element Array{GlobalVariableRef,1}:\n z[2]\n z[3]\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#JuMP.owner_model-Tuple{GeneralVariableRef}","page":"Variables","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::GeneralVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model function for InfiniteOpt variables. Returns the infinite model associated with vref.\n\nExample\n\njulia> owner_model(vref)\nAn InfiniteOpt Model\nFeasibility problem with:\nVariable: 1\n`GlobalVariableRef`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\n`GlobalVariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`GlobalVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\nNames registered in the model: vref\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.index-Tuple{GeneralVariableRef}","page":"Variables","title":"JuMP.index","text":"JuMP.index(v::GeneralVariableRef)::Int\n\nExtent JuMP.index to return the index of a InfiniteOpt variable.\n\nExample\n\njulia> index(vref)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_constraint-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_measure-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_objective-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by the objective.\n\nExample\n\njulia> used_by_objective(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.is_used-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a point variable.\n\nExample\n\njulia> used_by_point_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_reduced_variable","text":"used_by_reduced_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a reduced infinite variable.\n\nExample\n\njulia> used_by_reduced_variable(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::InfOptVariableRef)\n\nExtend JuMP.delete to delete InfiniteOpt variables and their dependencies. Errors if variable is invalid, meaning it has already been deleted or it belongs to another model.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n g(t) + z >= 42.0\n g(0.5) == 0\n t in [0, 6]\n\njulia> delete(model, g)\n\njulia> print(model)\nMin measure(t) + z\nSubject to\n z >= 0.0\n z >= 42.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_valid-Tuple{InfiniteModel,Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_valid to accomodate InfiniteOpt variables.\n\nExample\n\njulia> is_valid(model, ivref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.num_variables-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.num_variables","text":"JuMP.num_variables(model::InfiniteModel)::Int\n\nExtend JuMP.num_variables to return the number of InfiniteOpt variables assigned to model.\n\nExample\n\njulia> num_variables(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.has_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether an InfiniteOpt variable has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.lower_bound to return the lower bound of an InfiniteOpt variable. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(vref::InfOptVariableRef, lower::Number)\n\nExtend JuMP.set_lower_bound to specify the lower bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_lower_bound(vref, -1)\n\njulia> lower_bound(vref)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.LowerBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of vref.\n\nExample\n\njulia> cref = LowerBoundRef(vref)\nvar >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete_lower_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete_lower_bound","text":"JuMP.delete_lower_bound(vref::InfOptVariableRef)\n\nExtend JuMP.delete_lower_bound to delete lower bound of vref. Errors if it doesn't have a lower bound.\n\nExample\n\njulia> delete_lower_bound(vref)\n\njulia> has_lower_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.has_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether an InfiniteOpt variable has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of an InfiniteOpt variable. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(vref::InfOptVariableRef, upper::Number)\n\nExtend JuMP.set_upper_bound to specify the upper bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_upper_bound(vref, 1)\n\njulia> upper_bound(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.UpperBoundRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete_upper_bound-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete_upper_bound","text":"JuMP.delete_upper_bound(vref::InfOptVariableRef)\n\nExtend JuMP.delete_upper_bound to delete the upper bound of vref. Errors if it doesn't have an upper bound.\n\nExample\n\njulia> delete_upper_bound(vref)\n\njulia> has_upper_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_fixed-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether an InfiniteOpt variable is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.fix_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of an InfiniteOpt variable. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.fix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.fix","text":"JuMP.fix(vref::InfOptVariableRef, value::Number; force::Bool = false)\n\nExtend JuMP.fix to fix the value of an InfiniteOpt variable. Errors if variable has lower/upper bound unless force = true.\n\nExamples\n\njulia> fix(vref, 3)\n\njulia> fix_value(vref)\n3.0\n\njulia> fix(vref2, 2, force = true)\n\njulia> fix_value(vref2)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.FixRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar == 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unfix-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unfix","text":"JuMP.unfix(vref::InfOptVariableRef)\n\nExtend JuMP.unfix to unfix vref. Errors if it is not fixed.\n\nExample\n\njulia> unfix(vref)\n\njulia> is_fixed(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.start_value","text":"JuMP.start_value(vref::InfOptVariableRef)::Union{Nothing, Float64}\n\nExtend JuMP.start_value to return starting value of InfiniteOpt variable if it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_start_value-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::InfOptVariableRef, value::Number)\n\nExtend JuMP.set_start_value to specify the start value of InfiniteOpt variables.\n\nExample\n\njulia> set_start_value(vref, 1)\n\njulia> start_value(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether an InfiniteOpt variable is binary.\n\nExample\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.set_binary","text":"JuMP.set_binary(vref::InfOptVariableRef)\n\nExtend JuMP.set_binary to specify an InfiniteOpt variable as a binary variable. Errors if vref is an integer variable.\n\nExample\n\njulia> set_binary(vref)\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.BinaryRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unset_binary-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unset_binary","text":"JuMP.unset_binary(vref::InfOptVariableRef)\n\nExtend JuMP.unset_binary to unset vref as a binary variable. Errors if it is not binary.\n\njulia> unset_binary(vref)\n\njulia> is_binary(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether an InfiniteOpt variable is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.set_integer","text":"JuMP.set_integer(vref::InfOptVariableRef)\n\nExtend JuMP.set_integer to specify an InfiniteOpt variable as a integer variable. Errors if vref is an binary variable.\n\nExample\n\njulia> set_integery(vref)\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.IntegerRef-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unset_integer-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unset_integer","text":"JuMP.unset_integer(vref::InfOptVariableRef)\n\nExtend JuMP.unset_integer to unset vref as an integer variable. Errors if it is not an integer variable.\n\njulia> unset_integer(vref)\n\njulia> is_integer(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.name-Tuple{Union{GlobalVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.name","text":"JuMP.name(vref::InfOptVariableRef)::String\n\nExtend JuMP.name to return the names of InfiniteOpt variables.\n\nExample\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{InfiniteVariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::InfiniteVariableRef, root_name::String)\n\nExtend JuMP.set_name to set names of infinite variables. Adds on to root_name the ending (prefs...) where the parameter reference names are listed in the same format as input in the parameter reference tuple.\n\nExample\n\njulia> name(vref)\nold_name(t, x)\n\njulia> set_name(vref, \"new_name\")\n\njulia> name(vref)\nnew_name(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{PointVariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::PointVariableRef, name::String)\n\nExtend JuMP.set_name to set the names of point variables.\n\nExample\n\njulia> name(vref)\nold_name\n\njulia> set_name(vref, \"new_name\")\n\njulia> name(vref)\nnew_name\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{GlobalVariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::GlobalVariableRef, name::String)\n\nExtend JuMP.set_name to set names of global variables.\n\nExample\n\njulia> set_name(gvref, \"var_name\")\n\njulia> name(t)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::InfiniteVariableRef)::Tuple\n\nReturn the ParameterRef(s) associated with the infinite variable vref. This is formatted as a Tuple of containing the parameter references as they inputted to define vref.\n\nExample\n\njulia> parameter_refs(vref)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}","page":"Variables","title":"InfiniteOpt.set_parameter_refs","text":"set_parameter_refs(vref::InfiniteVariableRef, prefs::Tuple)\n\nSpecify a new parameter reference tuple prefs for the infinite variable vref. Note each element must contain a single parameter reference or an array of parameter references. Errors if a parameter is double specified or if an element contains parameters with different group IDs.\n\nExample\n\njulia> set_parameter_refs(vref, (t, x))\n\njulia> parameter_refs(vref)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s4,N} where N where #s4<:ParameterRef}}","page":"Variables","title":"InfiniteOpt.add_parameter_ref","text":"add_parameter_ref(vref::InfiniteVariableRef,\n                  pref::Union{ParameterRef, AbstractArray{<:ParameterRef}})\n\nAdd additional parameter reference or group of parameter references to be associated with the infinite variable vref. Errors if the parameter references are already added to the variable or if the added parameters have different group IDs.\n\njulia> name(vref)\nT(t)\n\njulia> add_parameter_ref(vref, x)\n\njulia> name(vref)\nT(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::PointVariableRef)::InfiniteVariableRef\n\nReturn the InfiniteVariableRef associated with the point variable vref.\n\nExample\n\njulia> infinite_variable_ref(vref)\nT(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_values-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_values","text":"parameter_values(vref::PointVariableRef)::Tuple\n\nReturn the support point associated with the point variable vref.\n\nExample\n\njulia> parameter_values(vref)\n(0, )\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.variable_by_name-Tuple{InfiniteModel,String}","page":"Variables","title":"JuMP.variable_by_name","text":"JuMP.variable_by_name(model::InfiniteModel,\n                      name::String)::Union{GeneralVariableRef, Nothing}\n\nExtend JuMP.variable_by_name for InfiniteModel objects. Return the varaible reference assoociated with a variable name. Errors if multiple variables have the same name. Returns nothing if no such name exists.\n\nExamples\n\njulia> variable_by_name(m, \"var_name\")\nvar_name\n\njulia> variable_by_name(m, \"fake_name\")\n\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.all_variables-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.all_variables","text":"JuMP.all_variables(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nExtend JuMP.all_variables to return a list of all the variable references associated with model.\n\nExamples\n\njulia> all_variables(m)\n4-element Array{GeneralVariableRef,1}:\n ivar(test, θ)\n ivar2(test, x)\n name\n z\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#Measure-Definition-and-Use-1","page":"Measures","title":"Measure Definition and Use","text":"","category":"section"},{"location":"guide/measure/#","page":"Measures","title":"Measures","text":"Here we explain the ins and outs of setting up InfiniteOpt measures.","category":"page"},{"location":"guide/measure/#Overview-1","page":"Measures","title":"Overview","text":"","category":"section"},{"location":"guide/measure/#Methods-1","page":"Measures","title":"Methods","text":"","category":"section"},{"location":"guide/objective/#Objective-Definition-and-Manipulation-1","page":"Objectives","title":"Objective Definition and Manipulation","text":"","category":"section"},{"location":"guide/objective/#","page":"Objectives","title":"Objectives","text":"Here we explain the ins and outs of setting up InfiniteOpt objectives.","category":"page"},{"location":"guide/objective/#Overview-1","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"guide/objective/#Methods-1","page":"Objectives","title":"Methods","text":"","category":"section"},{"location":"guide/constraint/#Constraint-Definition-and-Manipulation-1","page":"Constraints","title":"Constraint Definition and Manipulation","text":"","category":"section"},{"location":"guide/constraint/#","page":"Constraints","title":"Constraints","text":"Here we explain the ins and outs of setting up InfiniteOpt constraints.","category":"page"},{"location":"guide/constraint/#Overview-1","page":"Constraints","title":"Overview","text":"","category":"section"},{"location":"guide/constraint/#Methods-1","page":"Constraints","title":"Methods","text":"","category":"section"},{"location":"guide/transcribe/#Model-Transcription-1","page":"Model Transcription","title":"Model Transcription","text":"","category":"section"},{"location":"guide/transcribe/#","page":"Model Transcription","title":"Model Transcription","text":"Here we explain the ins and outs of transcribing InfiniteOpt models.","category":"page"},{"location":"guide/transcribe/#Overview-1","page":"Model Transcription","title":"Overview","text":"","category":"section"},{"location":"guide/transcribe/#Methods-1","page":"Model Transcription","title":"Methods","text":"","category":"section"},{"location":"guide/optimize/#Model-Optimization-1","page":"Optimization","title":"Model Optimization","text":"","category":"section"},{"location":"guide/optimize/#","page":"Optimization","title":"Optimization","text":"Here we explain the ins and outs of optimizing (solving) InfiniteOpt models.","category":"page"},{"location":"guide/optimize/#Overview-1","page":"Optimization","title":"Overview","text":"","category":"section"},{"location":"guide/optimize/#Methods-1","page":"Optimization","title":"Methods","text":"","category":"section"},{"location":"guide/result/#Result-Queries-1","page":"Results","title":"Result Queries","text":"","category":"section"},{"location":"guide/result/#","page":"Results","title":"Results","text":"Here we explain the ins and outs of querying optimized InfiniteOpt models.","category":"page"},{"location":"guide/result/#Overview-1","page":"Results","title":"Overview","text":"","category":"section"},{"location":"guide/result/#Methods-1","page":"Results","title":"Methods","text":"","category":"section"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"library/#Method,-DataType,-and-Macro-Index-1","page":"Library","title":"Method, DataType, and Macro Index","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#JuMP-Documentation-1","page":"Library","title":"JuMP Documentation","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"Model\nModel()\nModel(::OptimizerFactory)\nwith_optimizer","category":"page"},{"location":"library/#JuMP.Model","page":"Library","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"library/#JuMP.Model-Tuple{}","page":"Library","title":"JuMP.Model","text":"Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,\n        bridge_constraints::Bool=true)\n\nReturn a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the CachingOptimizer storing this cache is caching_mode. The optimizer can be set later in the optimize! call. If bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitely added.\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.Model-Tuple{OptimizerFactory}","page":"Library","title":"JuMP.Model","text":"Model(optimizer_factory::OptimizerFactory;\n      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,\n      bridge_constraints::Bool=true)\n\nReturn a new JuMP model using the optimizer factory optimizer_factory to create the optimizer. The optimizer factory can be created by the with_optimizer function.\n\nExamples\n\nThe following creates a model using the optimizer Ipopt.Optimizer(print_level=0):\n\nmodel = Model(with_optimizer(Ipopt.Optimizer, print_level=0))\n\n\n\n\n\n","category":"method"},{"location":"library/#JuMP.with_optimizer","page":"Library","title":"JuMP.with_optimizer","text":"with_optimizer(constructor, args...; kwargs...)\n\nReturn an OptimizerFactory that creates optimizers using the constructor constructor with positional arguments args and keyword arguments kwargs.\n\nExamples\n\nThe following returns an optimizer factory that creates Ipopt.Optimizers using the constructor call Ipopt.Optimizer(print_level=0):\n\nwith_optimizer(Ipopt.Optimizer, print_level=0)\n\n\n\n\n\n","category":"function"},{"location":"extensions/#Writing-Extensions-1","page":"Extensions","title":"Writing Extensions","text":"","category":"section"},{"location":"develop/#Developers-Guide-1","page":"Development","title":"Developers Guide","text":"","category":"section"}]
}
