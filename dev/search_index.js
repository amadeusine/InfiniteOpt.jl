var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"(Image: Logo)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A JuMP extension for expressing and solving infinite dimensional optimization problems.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"InfiniteOpt.jl provides a mathematical interface to express and solve optimization problems that entail an infinite dimensional decision space. Such problems stem from areas such as dynamic programming, state-space models, and stochastic programming. InfiniteOpt.jl is meant to facilitate intuitive model definition, automatic transcription into solvable models, permit a wide range of user-defined extensions/behavior, and more. Currently, its capabilities include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JuMP-like symbolic macro interface\nInfinite parameter support and parameterization of variables/constraints\nFinite parameters support(similar to ParameterJuMP)\nDirect support of infinite, point, and hold variables\nSymbolic measure (integral) expression\nInfinite/finite constraint definition\nOrdinary differential equation support (coming soon)\nAutomated model transcription/reformulation and solution\nReadily extendable to accommodate user defined abstractions and solution techniques","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nCurrently, InfiniteOpt only accepts linear and quadratic expressions. Development is underway to allow for general nonlinear constraints.  ","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"InfiniteOpt.jl is still under development but can be installed by entering the following in the package manager.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.3) pkg> add https://github.com/pulsipher/InfiniteOpt.jl","category":"page"},{"location":"#Quick-Start-1","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Below is a brief example of the high-level API.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Revise, InfiniteOpt, JuMP, Ipopt, Distributions\n\n# Set the problem information\nθ_nom, covar = [0.; 60.; 10.], [80. 0 0; 0 80. 0; 0 0 120.]\nn_z, n_θ, n_d = 3, 3, 3\n\n# Initialize the model\nm = InfiniteModel(with_optimizer(Ipopt.Optimizer))\n\n# Set the uncertainty parameters\ndist = MvNormal(θ_nom, covar)\n@infinite_parameter(m, θ[i = 1:n_θ] in dist, num_supports = 100)\n@infinite_parameter(m, 0 <= t <= 10)\n\n# Initialize the variables\n@infinite_variable(m, z[1:n_z](θ, t))\n@infinite_variable(m, 0 <= y(θ) <= 100)\n@hold_variable(m, d[1:n_d] >= 0)\n\n# Set objective function\n@objective(m, Min, expect(1 - y, θ))\n\n# Set first stage constraints\n@constraint(m, max_cost, sum(1 / 3 * d[i] for i = 1:n_d) <= 5)\n\n# Set the second stage constraints\n@constraint(m, f1, -z[1] - 35 - d[1] + y <= 0)\n@constraint(m, f2, z[1] - 35 - d[1] + y <= 0)\n@constraint(m, f3, -z[2] - 50 - d[2] + y <= 0)\n@constraint(m, f4, z[1] - 50 - d[2] + y <= 0)\n@constraint(m, h1, z[1] - θ[1] == 0)\n@constraint(m, h2, -z[1] -z[2] + z[3] - θ[2] == 0)\n@constraint(m, h3, z[2] - θ[3] == 0)\n\n# Solve and and obtain results\noptimize!(m)\nif has_values(m)\n    opt_y = value(y)\n    opt_d = value.(d)\n    opt_obj = objective_value(m)\nend","category":"page"},{"location":"#Acknowledgements-1","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We acknowledge our support from the Department of Energy under grant DE-SC0014114.","category":"page"},{"location":"guide/install/#Installation-Guide-1","page":"Installation","title":"Installation Guide","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"A complete guide to installing all that is necessary to use InfiniteOpt.jl.","category":"page"},{"location":"guide/install/#Install-Julia-1","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"InfiniteOpt is a Julia package. Thus, we first need have an installation of Julia to get started. An appropriate download can be found here. Alternatively, users with a limited programming background might find it easier to install and use JuliaPro.","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"note: Note\nThis version of InfiniteOpt requires that Julia 1.0 or newer be used.","category":"page"},{"location":"guide/install/#Install-Packages-1","page":"Installation","title":"Install Packages","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Now that Julia has been installed we can add the needed packages. Open up a Julia terminal and enter the package manager:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"julia> ]\n\n(v1.2) pkg>","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Use the add command in the package to manager to add the following packages:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"JuMP\nDistributions","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"For example, to install JuMP we would enter:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add JuMP","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Now let's install InfiniteOpt, because it is not yet a registered Julia package we have to specify the GitHub repository address:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add https://github.com/pulsipher/InfiniteOpt.jl","category":"page"},{"location":"guide/install/#Install-Optimization-Solvers-1","page":"Installation","title":"Install Optimization Solvers","text":"","category":"section"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"InfiniteOpt relies on solvers to solve optimization problems. Many solvers are not native to Julia and might require commercial licenses. A list of currently supported solvers and their corresponding Julia packages is provided in Supported Optimizers.","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"For example, we can install Ipopt which is an open-source nonlinear solver:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"(v1.2) pkg> add Ipopt","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Now Ipopt can be used as the optimizer (solver) for an infinite model by running:","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"julia> using InfiniteOpt, JuMP, Ipopt\n\njulia> model = InfiniteModel(with_optimizer(Ipopt.Optimizer))","category":"page"},{"location":"guide/install/#","page":"Installation","title":"Installation","text":"Most solver packages follow the ModuleName.Optimizer naming convention, but this may not always be the case. See Infinite Models for more information on defining infinite models and specifying solvers.","category":"page"},{"location":"guide/model/#Infinite-Models-1","page":"Infinite Models","title":"Infinite Models","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"A guide and manual for initializing infinite models and understanding how they work. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/model/#Overview-1","page":"Infinite Models","title":"Overview","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Infinite models are expressed via the InfiniteModel datatype which is at the core of InfiniteOpt. These model objects are designed to emulate the behavior of Model objects in JuMP. These data objects store the parameters, variables, measures, objective, constraints, and all other data used in InfiniteOpt. This differs from JuMP models which store such information in a MathOptInterface model backend.","category":"page"},{"location":"guide/model/#Basic-Usage-1","page":"Infinite Models","title":"Basic Usage","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Infinite models can be initialized with no arguments by default:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"The optimizer that will be used to solve the model can also be specified at model definition using JuMP's with_optimizer constructor:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Ipopt\n\njulia> model = InfiniteModel(with_optimizer(Ipopt.Optimizer))\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Note that any optimizer currently supported by JuMP v0.19.0 or newer is supported for use in InfiniteOpt. For completeness, the table of currently supported optimizers is provided below in Supported Optimizers.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Now you have an initialized InfiniteModel that is ready for your mathematical model to be defined and optimized!","category":"page"},{"location":"guide/model/#Advanced-Definition-Information-1","page":"Infinite Models","title":"Advanced Definition Information","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"As you may have noticed in the above examples, InfiniteModels contain an optimizer model backend which simply corresponds to a JuMP Model that will be used to store and optimize the reformulation of the infinite mathematical model stored in InfiniteModel. It also will contain a mapping between its optimization model and that of the InfiniteModel (e.g., a mapping between the variables and constraints). By default, InfiniteModels use a TranscriptionModel optimizer model backend which will store a transcribed (discretized) version of the infinite model. More information on the internal use of TranscriptionModels is provided in Model Transcription.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"All the arguments used with the InfiniteModel constructor (e.g., the optimizer) are simply passed on and stored in the optimizer model backend. Thus, any argument supported by JuMP.Model can be passed on to the optimizer model by including it in the InfiniteModel constructor. For example, we can specify the caching_mode keyword argument in the InfiniteModel call to use in the definition of the optimizer model:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"julia> using InfiniteOpt, JuMP, Ipopt, MathOptInterface\n\njulia> const MOIU = MathOptInterface.Utilities;\n\njulia> model = InfiniteModel(with_optimizer(Ipopt.Optimizer),\n                             caching_mode = MOIU.MANUAL)\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: MANUAL\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Notice that the model mode of the optimizer model is now MANUAL.","category":"page"},{"location":"guide/model/#Supported-Optimizers-1","page":"Infinite Models","title":"Supported Optimizers","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"InfiniteOpt can use any optimizer that is supported by JuMP v0.19.0 or newer. In spirit of providing complete documentation, the table of optimizers currently supported by JuMP.jl is provided below. This information comes directly from their documentation pages. Please refer to JuMP documentation for additional optimizer information on installation and use.","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Solver Julia Package License Supports\nArtelys Knitro KNITRO.jl Comm. LP, MILP, SOCP, MISOCP, NLP, MINLP\nCbc Cbc.jl EPL MILP\nCDCS CDCS.jl GPL LP, SOCP, SDP\nClp Clp.jl EPL LP\nCOSMO COSMO.jl Apache LP, QP, SOCP, SDP\nCPLEX CPLEX.jl Comm. LP, MILP, SOCP, MISOCP\nCSDP CSDP.jl EPL LP, SDP\nECOS ECOS.jl GPL LP, SOCP\nFICO Xpress Xpress.jl Comm. LP, MILP, SOCP, MISOCP\nGLPK GLPK.jl GPL LP, MILP\nGurobi Gurobi.jl Comm. LP, MILP, SOCP, MISOCP\nIpopt Ipopt.jl EPL LP, QP, NLP\nJuniper Juniper.jl MIT MISOCP, MINLP\nMOSEK MosekTools.jl Comm. LP, MILP, SOCP, MISOCP, SDP\nOSQP OSQP.jl Apache LP, QP\nProxSDP ProxSDP.jl MIT LP, SOCP, SDP\nSCIP SCIP.jl ZIB MILP, MINLP\nSCS SCS.jl MIT LP, SOCP, SDP\nSDPA SDPA.jl GPL LP, SDP\nSeDuMi SeDuMi.jl GPL LP, SOCP, SDP","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"Where:","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"LP = Linear programming\nQP = Quadratic programming\nSOCP = Second-order conic programming (including problems with convex   quadratic constraints and/or objective)\nMILP = Mixed-integer linear programming\nNLP = Nonlinear programming\nMINLP = Mixed-integer nonlinear programming\nSDP = Semidefinite programming\nMISDP = Mixed-integer semidefinite programming","category":"page"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"You may also use AmplNLWriter to access solvers that support the nl format. Such solvers include Bonmin and Couenne. See a more complete list here.","category":"page"},{"location":"guide/model/#Datatypes-1","page":"Infinite Models","title":"Datatypes","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"InfiniteModel","category":"page"},{"location":"guide/model/#InfiniteOpt.InfiniteModel","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel <: JuMP.AbstractModel\n\nA DataType for storing all of the mathematical modeling information needed to model an optmization problem with an infinite dimensional decision space.\n\nFields\n\nnext_meas_index::Int Index - 1 of next measure.\nmeasures::Dict{Int, Measure} Measure indices to measure datatypes.\nmeas_to_name::Dict{Int, String} Measure indices to names.\nmeas_to_constrs::Dict{Int, Vector{Int}} Measure indices to dependent                                           constraint indices.\nmeas_to_meas::Dict{Int, Vector{Int}} Measure indices to dependent                                        measure indices.\nmeas_in_objective::Dict{Int, Bool} Measure indices to if used in objective.\nnext_param_index::Int Index - 1 of next infinite parameter.\nnext_param_id::Int Index - 1 of the next infinite parameter group.\nparams::Dict{Int, InfOptParameter} Infinite parameter indices to parameter                                      datatype.\nparam_to_name::Dict{Int, String} Infinite parameter indices to names.\nname_to_param::Union{Dict{String, Int}, Nothing} Names to infinite                                                    parameters.\nparam_to_group_id::Dict{Int, Int} Infinite parameter indices to group IDs.\nparam_to_constrs::Dict{Int, Vector{Int}} Infinite parameter indices to list                                            of dependent constraint indices.\nparam_to_meas::Dict{Int, Vector{Int}} Infinite parameter indices to list                                         of dependent measure indices.\nparam_to_vars::Dict{Int, Vector{Int}} Infinite parameter indices to list                                         of dependent variable indices.\nnext_var_index::Int Index - 1 of next variable index.\nvars::Dict{Int, Dict{Int, Union{InfOptVariable, ReducedVariable}} Variable                                                 indices to variable datatype.\nvar_to_name::Dict{Int, String} Variable indices to names.\nname_to_var::Union{Dict{String, Int}, Nothing} Variable names to indices.\nvar_to_lower_bound::Dict{Int, Int} Variable indices to lower bound index.\nvar_to_upper_bound::Dict{Int, Int} Variable indices to upper bound index.\nvar_to_fix::Dict{Int, Int} Variable indices to fix index.\nvar_to_zero_one::Dict{Int, Int} Variable indices to binary index.\nvar_to_integrality::Dict{Int, Int} Variable indices to integer index.\nvar_to_constrs::Dict{Int, Vector{Int}} Variable indices to dependent                                          constraint indices.\nvar_to_meas::Dict{Int, Vector{Int}} Variable indices to dependent                                       measure indices.\nvar_in_objective::Dict{Int, Bool} Variable indices to if used in objective.\ninfinite_to_points::Dict{Int, Vector{Int}} Infinite variable indices to                                              dependent point variable indices.\ninfinite_to_reduced::Dict{Int, Vector{Int}} Infinite variable indices to                                              dependent reduced variable indices.\nhas_hold_bounds::Bool Have hold variables with bounds been added to the model\nreduced_to_constrs::Dict{Int, Vector{Int}} Reduced variable indices to dependent                                              constraint indices.\nreduced_to_meas::Dict{Int, Vector{Int}} Reduced variable indices to dependent                                           measure indices.\nreduced_info::Dict{Int, AbstractReducedInfo} Reduced variable indices to                                                reduced variable information.\nnext_constr_index::Int Index - 1 of next constraint.\nconstrs::Dict{Int, JuMP.AbstractConstraint} Constraint indices to constraint                                               datatypes.\nconstr_to_name::Dict{Int, String} Constraint indices to names.\nname_to_constr::Union{Dict{String, Int}, Nothing} Constraint names to                                                     indices.\nconstr_in_var_info::Dict{Int, Bool} Constraint indices to if related to                                       variable information constraints.\nobjective_sense::MOI.OptimizationSense Objective sense.\nobjective_function::JuMP.AbstractJuMPScalar Finite scalar function.\nobj_dict::Dict{Symbol, Any} Store Julia symbols used with InfiniteModel\noptimizer_factory::Union{JuMP.OptimizerFactory, Nothing} Optimizer                                                            information.\noptimizer_model::JuMP.Model Model used to solve InfiniteModel\nready_to_optimize::Bool Is the optimizer_model up to date.\n\n\n\n\n\n","category":"type"},{"location":"guide/model/#Methods-1","page":"Infinite Models","title":"Methods","text":"","category":"section"},{"location":"guide/model/#","page":"Infinite Models","title":"Infinite Models","text":"InfiniteModel()","category":"page"},{"location":"guide/model/#InfiniteOpt.InfiniteModel-Tuple{}","page":"Infinite Models","title":"InfiniteOpt.InfiniteModel","text":"InfiniteModel([optimizer_factory::JuMP.OptimizerFactory];\n              [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,\n              bridge_constraints::Bool = true])\n\nReturn a new infinite model where an optimizer is specified if an optimizer_factory is given via JuMP.with_optimizer. The optimizer can also later be set with the JuMP.optimize! call. By default the optimizer_model data field is initialized with a TranscriptionModel, but a different type of model can be assigned via set_optimizer_model as can be required by extensions.\n\nExample\n\njulia> using InfiniteOpt, JuMP, Ipopt;\n\njulia> model = InfiniteModel()\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> model = InfiniteModel(with_optimizer(Ipopt.Optimizer))\nAn InfiniteOpt Model\nFeasibility problem with:\nVariables: 0\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Ipopt\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#Infinite-Parameters-1","page":"Infinite Parameters","title":"Infinite Parameters","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"A guide and manual to the definition and use of infinite parameters in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/parameter/#Overview-1","page":"Infinite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Infinite parameters are what parameterize the infinite decision spaces for infinite dimensional mathematical programs. In dynamic optimization this corresponds to time and in stochastic optimization this to uncertain parameters that follow a certain underlying statistical distribution. InfiniteOpt considers principally two kinds of infinite parameters, ones defined over continuous intervals and ones characterized by a distribution (others can be added by defining a user-defined type). These can be used to parameterize infinite variables, point variables, measures, and can be used directly inside constraints.","category":"page"},{"location":"guide/parameter/#Basic-Usage-1","page":"Infinite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"First, we need to initialize and add infinite parameters to our InfiniteModel. This can be accomplished using @infinite_parameter. For example, let's define a parameter for time in a time interval from 0 to 10:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now t is a Julia variable that stores a ParameterRef which points to where the time parameter is stored in model. It can now be used with infinite variables, measures, and constraints as described in the appropriate sections.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"When the model is optimized, t will be transcribed (discretized) over its domain following its support points. If none are specified by the user than 50 support points are generated that are equidistant over the interval. However, users may wish to employ their own support scheme. This can be done by using the num_supports or supports keyword arguments. For example, if we desire to have only 10 equidistant supports then we could have instead defined t:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], num_supports = 10)\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"More complex support schemes can be specified via supports such as:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0; 2; 7; 10])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Where we specified t to use 4 supports: 0, 2, 7, and 10.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also add supports after t has been initialized. This can be accomplished with add_supports. For example, consider the initial case where t has no supports and we now wish to add 4 supports:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> add_supports(t, [0., 2.5, 7.5, 10.])\n\njulia> supports(t)\n4-element Array{Number,1}:\n  0.0\n  2.5\n  7.5\n 10.0","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Here only 4 supports are specified for the sake of example. Alternatively, we could have initialized the parameter and added supports in just one step using the supports keyword argument:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0., 2.5, 7.5, 10.])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We could also define a random parameter described by a statistical distribution. This can be accomplished using @infinite_parameter in combination with a distribution from Distributions.jl. For example let's define a vector of random parameters described by a Normal distribution:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> using Distributions\n\njulia> @infinite_parameter(model, xi[i = 1:3] in Normal())\n3-element Array{ParameterRef,1}:\n xi[1]\n xi[2]\n xi[3]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that we could have used i as an index to assign a different distribution to each parameter. Supports can also be specified for each parameter as shown above. The key difference is that by default 50 supports are generated randomly following the distribution. Similarly, the num_supports keyword is used to generate random supports. Now we have infinite parameters t and xi that are ready to be used in defining infinite variables and constraints. We also mention here that the @infinite_parameter macro is designed to closely emulate JuMP.@variable and thus handles arrays and keyword arguments in the same way. This is described in more detail below.","category":"page"},{"location":"guide/parameter/#Infinite-Sets-1","page":"Infinite Parameters","title":"Infinite Sets","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The domain of a given infinite parameter is described by an infinite set inherited from AbstractInfiniteSet. InfiniteOpt natively supports two such sets. The first is IntervalSet which describes a continuous interval from some lower bound up to some upper bound. Typically, this range is inclusive of the bounds. Such sets often arise for parameters that pertain to time and/or spatial position. For example, to define a position interval -2 2 we would use:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set = IntervalSet(-2, 2)\nIntervalSet(-2.0, 2.0)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In principle infinite bounds are acceptable, but are not actively supported at the moment.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The second kind of set is that of DistributionSet which contains distribution from Distributions.jl that characterizes an infinite parameter. Univariate and multivariate distributions can be used, but multivariate distributions are only valid when defining an array of parameters with equivalent dimensions. For example, let's make a DistributionSet that depends on a Beta distribution:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set = DistributionSet(Beta(2,2))\nDistributionSet{Beta{Float64}}(Distributions.Beta{Float64}(α=2.0, β=2.0))","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"User-defined distributions are also permissible so long as they are created in accordance with Distributions.jl.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Furthermore, custom infinite sets that inherit AbstractInfiniteSet can also be defined. See Extensions for more information.","category":"page"},{"location":"guide/parameter/#Parameter-Definition-1","page":"Infinite Parameters","title":"Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Defining/initializing an infinite parameter principally involves the following steps:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Define an AbstractInfiniteSet\nDefine support points within the set to later discretize the parameter\nSpecify if parameter is independent (only for multi-dimensional parameter groups)\nConstruct an InfOptParameter to store this information\nAdd the InfOptParameter object to an InfiniteModel and assign a name\nCreate a ParameterRef that points to the parameter object","category":"page"},{"location":"guide/parameter/#Manual-Definition-1","page":"Infinite Parameters","title":"Manual Definition","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Infinite set definition is described above in Infinite Sets. The supports should be a vector of finite numbers that are drawn from the domain of the infinite set. These supports will be used to transcribe the InfiniteModel in preparation for it to be optimized. If desired, the supports can be specified after the parameter is defined and an empty vector will be used to construct the infinite parameter. We'll discuss independence a little further below. The build_parameter function is used to construct the InfOptParameter. For example, let's create a time parameter t in 0 10 with supports [0, 2, 5, 7, 10]:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set = IntervalSet(0, 10)\nIntervalSet(0.0, 10.0)\n\njulia> t_param = build_parameter(error, set, supports = [0, 2, 5, 7, 10])\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 10.0), [0, 2, 5, 7, 10], false)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now we have a InfOptParameter that contains an IntervalSet and supports. Note that the num_params and independent arguments are primarily meant to be used by @infinite_parameter to define array parameters and specify if they are correlated or independent.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Let's now add t_param to our InfiniteModel using add_parameter and assign it the name of t:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t_ref = add_parameter(model, t_param, \"t\")\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also create an anonymous infinite parameter by dropping the name from the add_parameter function call. For example:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t_ref_noname = add_parameter(model, t_param)\nnoname","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now suppose we want to create an infinite parameter that is a random variable with a given distribution. We follow the same procedure as above, except we use distributions from Distributions.jl to define DistributionSet. For example, let's consider a random variable x in mathcalN(01) with supports [-0.5, 0.5]:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = Normal(0., 1.)\nDistributions.Normal{Float64}(μ=0.0, σ=1.0)\n\njulia> set = DistributionSet(dist)\nDistributionSet{Normal{Float64}}(Distributions.Normal{Float64}(μ=0.0, σ=1.0))\n\njulia> x_param = build_parameter(error, set, supports = [-0.5, 0.5])\nInfOptParameter{DistributionSet{Normal{Float64}}}(DistributionSet{Normal{Float64}}(Distributions.Normal{Float64}(μ=0.0, σ=1.0)), [-0.5, 0.5], false)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Again, we use add_parameter to add x_param to the InfiniteModel and assign it the name x:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> x_ref = add_parameter(model, x_param, \"x\")\nx","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that add_parameter does not register the name of the parameters into the model that it adds to. As shown in Macro Definition, the macro definition does not allow for multiple parameters sharing the same name and will throw an error if it happens.","category":"page"},{"location":"guide/parameter/#Macro-Definition-1","page":"Infinite Parameters","title":"Macro Definition","text":"","category":"section"},{"location":"guide/parameter/#One-Dimensional-Parameters-1","page":"Infinite Parameters","title":"One-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"One user-friendly way of defining infinite parameters is by macro @infinite_parameter. The macro executes the same process as the manual definition (steps listed in Parameter Definition), but allows the users to manipulate several features of the defined infinite parameters. Again, let's consider a time parameter t in 0 10 with supports [0, 2, 5, 7, 10]. Similar to JuMP.@variable, we can use comparison operators to set lower bounds and upper bounds for the infinite parameter:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, 0 <= t <= 10, supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"More generally, we use in to define the set that an infinite parameter is subject to. The set could be an interval set, or a distribution set. For example, we can define the same parameter t as above in the following way:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t in [0, 10], supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In a similar way, we can define a random infinite parameter subject to some distribution. For example, a Gaussian infinite parameter with mean 0 and standard deviation 1 can be defined by","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = Normal(0., 1.)\nDistributions.Normal{Float64}(μ=0.0, σ=1.0)\n\njulia> @infinite_parameter(model, x in dist, supports = [-0.5, 0.5])\nx","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Additional ways of defining infinite parameters are provided using keyword arguments. For example, we can use lower_bound and upper_bound to define an infinite parameter in an interval set:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t, lower_bound = 0, upper_bound = 10, supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"A bit more generally, we can also use set to directly input the AbstractInfiniteSet that the parameter is in. For example:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, t, set = IntervalSet(0, 10), supports = [0, 2, 5, 7, 10])\nt","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The parameter definition methods using keyword arguments will be useful later when we introduce how to define anonymous parameters. See the part for anonymous parameter definition for more details.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"All the definitions above return a ParameterRef that refer to the defined parameter. Note that we can also ignore the supports keyword argument and the macro will define an empty array of supports for that parameter.","category":"page"},{"location":"guide/parameter/#Multi-Dimensional-Parameter-1","page":"Infinite Parameters","title":"Multi-Dimensional Parameter","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Using macro definition, we can also define multi-dimensional infinite parameters in a concise way. For example, consider a position parameter x in a 3-dimensional space constrained in a unit cube (i.e. in the interval [0, 1]   for all dimensions). This parameter can be defined in one line as follows:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], supports = [0.3, 0.7])\n3-element Array{ParameterRef,1}:\n x[1]\n x[2]\n x[3]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multi-dimensional parameters, the macro calls for build_parameter and add_parameter and creates looped codes that construct separate parameters and references for each dimension. If an array of supports is provided, the macro will assign that array of supports to all dimensions. Otherwise, the indexed syntax can be used to feed in different array of supports to each dimension, similar to JuMP.@variable. For example:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> points = [0.2 0.8; 0.3 0.7]\n2×2 Array{Float64,2}:\n 0.2  0.8\n 0.3  0.7\n\njulia> @infinite_parameter(model, a[i = 1:2] in [0, 1], supports = points[i, :])\n2-element Array{ParameterRef,1}:\n a[1]\n a[2]\n\njulia> supports(a[1])\n2-element Array{Float64,1}:\n 0.2\n 0.8\n\njulia> supports(a[2])\n2-element Array{Float64,1}:\n 0.3\n 0.7","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In a similar way we can define an infinite parameter subject to a multivariate distribution. For example, a 2-dimensional parameter xi subject to a 2-D normal distribution can be created as follows:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.])\nFullNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.0; 0.0 2.0]\n)\n\njulia> @infinite_parameter(model, xi[1:2] in dist)\n2-element Array{ParameterRef,1}:\n xi[1]\n xi[2]","category":"page"},{"location":"guide/parameter/#Containers-for-Multi-Dimensional-Parameters-1","page":"Infinite Parameters","title":"Containers for Multi-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that for all the cases of multi-dimensional parameter definition above, the macro always returns an Array of ParameterRef. For most cases this is true. However, we can explicitly dictate the kind of containers we want to hold the defined parameters using the keyword container. For example, we use SparseAxisArray from the JuMP package for the space parameter x:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], container = SparseAxisArray)\nJuMP.Containers.SparseAxisArray{ParameterRef,1,Tuple{Any}} with 3 entries:\n  [3]  =  x[3]\n  [2]  =  x[2]\n  [1]  =  x[1]","category":"page"},{"location":"guide/parameter/#independent-for-Multi-Dimensional-Parameters-1","page":"Infinite Parameters","title":"independent for Multi-Dimensional Parameters","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For examples up to now we did not specify the value for the keyword independent, which is set as false by default. The keyword independent applies to multi-dimensional infinite parameters and dictates whether the supports for different dimensions are independent. Setting independent as true would be useful if the users want to generate a grid of supports for a multi-dimensional parameter. For example, consider the position parameter x in a 3D space. Say x is bounded in [0, 1] in all three dimensions, and the user wants to generate grid points with interval 0.5 in all three dimensions. In this case, we can define x in the following way:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pts = collect(range(0, stop = 1, length = 3))\n3-element Array{Float64,1}:\n 0.0\n 0.5\n 1.0\n\njulia> @infinite_parameter(model, x[1:3] in [0, 1], supports = pts, independent = true)\n3-element Array{ParameterRef,1}:\n x[1]\n x[2]\n x[3]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"If independent is set as false, the transcription step will generate JuMP variables for values of any variable parameterized by x at [0.0, 0.0, 0.0], [0.5, 0.5, 0.5] and [1.0, 1.0, 1.0], a total of 3 transcribed variables. Instead, if independent is set as true, the transcription step will obtain a unique permutation of these supports and each transcribe parameterized variable accordingly, leading to a total of 27 transcribed variables in this case.","category":"page"},{"location":"guide/parameter/#Anonymous-Parameter-Definition-and-base_name-1","page":"Infinite Parameters","title":"Anonymous Parameter Definition and base_name","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"As mentioned above, we can define anonymous parameters using keyword arguments in the macro @infinite_parameter. For instance, we can create an anonymous position parameter in a 3D space, referred to by a list of ParameterRef called x:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> x = @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1)\n3-element Array{ParameterRef,1}:\n noname\n noname\n noname\n\njulia> typeof(x)\nArray{ParameterRef,1}\n\njulia> name(x[1])\n\"\"","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"This syntax creates a 1D parameter if the part [1:3] is neglected.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that this macro definition automatically assigns an empty string to the base_name. We can also assign a nontrivial base name to an anonymous parameter using the keyword argument base_name. For example,","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, [1:3], lower_bound = 0, upper_bound = 1, base_name = \"x\")\n3-element Array{ParameterRef,1}:\n x[1]\n x[2]\n x[3]\n\njulia> @infinite_parameter(model, [1:3], lower_bound = -1, upper_bound = 0, base_name = \"x\")\n3-element Array{ParameterRef,1}:\n x[1]\n x[2]\n x[3]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can see that anonymous parameter definition allows for multiple parameters sharing the same base name. This is not permitted with non-anonymous parameter definition. In fact, in anonymous parameter definition, the macro does not register the name of the parameters in the model, so when the model checks for repeated names it will not detect the x. Refer to Detailed Mechanism of Macro Definition if more details are desired.","category":"page"},{"location":"guide/parameter/#Detailed-Mechanism-of-Macro-Definition-1","page":"Infinite Parameters","title":"Detailed Mechanism of Macro Definition","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"This section is for people who wish to know more about how the macro @infinite_parameter works in the backend. Users who only want to learn about the setting up the model can skip over this part.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In general, the macro @infinite_parameter follows the same steps as the manual definition. First, it parses the arguments and identifies any recognizable keyword arguments. Specifically, the first argument must be the model, and the second argument, if exists, must be an expression that declares the parameter or simply specify the dimension of the parameter if users choose to define it anonymously. If the information in the keyword arguments is not sufficient to define the set the parameter is in, the users also need to specify the sets in the second argument using expressions like a <= x <= b or x in set.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The keyword arguments give users flexibility in how to define their parameters. As mentioned above, the users can choose to specify the set either in the second argument (nonanonymous parameter definition only), or in the keyword arguments. However, the users cannot do both at the same time. The macro will check this behavior and throw an error if this happens. For example,","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model,  y in [0, 1], lower_bound = 0, upper_bound = 1)\nERROR: LoadError\n\njulia> @infinite_parameter(model,  y in [0, 1], set = IntervalSet(0, 1))\nERROR: LoadError","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once the check on arguments and keyword arguments is done, the macro will create the AbstractInfiniteSet based on given information, and create the infinite parameter accordingly. If the users create a multi-dimensional parameter, the macro will create looped code to define individual infinite parameter for each dimension. The looped code will also incorporate different supports for different dimensions.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In the end, if the created parameter is not anonymous, the macro will register the name to the model. In this way, we prevent parameters created by @infinite_parameter non-anonymously to share the same name.","category":"page"},{"location":"guide/parameter/#Supports-1","page":"Infinite Parameters","title":"Supports","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter, its supports are a finite set of points that the parameter will take (or possibly take, if the parameter is random). During the transcription stage, the supports specified will become part of the grid points that approximate all functions parameterized by the infinite parameter.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once an infinite parameter is defined, users can access the supports using supports function:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, 0 <= t <= 10, supports = [0, 2, 5, 7, 10])\nt\n\njulia> supports(t)\n5-element Array{Int64,1}:\n  0\n  2\n  5\n  7\n 10","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We also provide functions that access other related information about the supports. For example, has_supports checks whether a parameter has supports, while num_supports gives the number of supports associated with a parameter:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> has_supports(t)\ntrue\n\njulia> num_supports(t)\n5","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now suppose we want to add more supports to the t, which is already assigned with some supports. We can use add_supports function to achieve this goal:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> add_supports(t, [3, 8])\n\njulia> supports(t)\n7-element Array{Int64,1}:\n  0\n  2\n  5\n  7\n 10\n  3\n  8","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"At times we might want to change the supports completely. In those cases, the function set_supports resets the supports for a certain parameter with new supports provided:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set_supports(t, [0,3,5,8,10], force = true)\n\njulia> supports(t)\n5-element Array{Int64,1}:\n  0\n  3\n  5\n  8\n 10","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the keyword argument [force] must be set as [true] if the parameter has been assigned with supports. Users can also delete all the supports of a parameter with delete_supports.","category":"page"},{"location":"guide/parameter/#Automatic-Support-Generation-During-Parameter-Definition-1","page":"Infinite Parameters","title":"Automatic Support Generation During Parameter Definition","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For the examples in the Parameter Definition, we have seen how to manually add supports to an infinite parameter. For a quick automatic generation of support points, though, users do not have to input the support points. Instead, the number of support points generated is supplied.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter subject to an IntervalSet, uniformly spaced supports including both ends are generated across the interval. For example, defining a time parameter t in 0 10 with 4 supports using build_parameter gives","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set = IntervalSet(0, 10)\nIntervalSet(0.0, 10.0)\n\njulia> t_param = build_parameter(error, set, num_supports = 4, sig_fig = 3)\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 10.0), [0.0, 3.33, 6.67, 10.0], false)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Using macro definition we have","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, 0 <= t <= 10, num_supports = 4, sig_fig = 3)\nt\n\njulia> supports(t)\n4-element Array{Float64,1}:\n  0.0   \n  3.33\n  6.67\n 10.0   \n","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the user can use the keyword argument sig_fig to dictate the significant figures for the supports. The default value of sig_fig is 5.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For an infinite parameter that follows a univariate distribution, supports are sampled from the underlying distribution. For example, we can define an infinite parameter subject to a normal distribution with mean 0 and variance 1:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x in dist, num_supports = 4)\nx\n\njulia> supports(x)\n4-element Array{Float64,1}:\n  0.67911\n  0.82841\n -0.35301\n -0.13485\n","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multivariate distributions, though, we require support points are provided in the definition. However, we can use fill_in_supports! to generate supports for parameters following multivariate distributions. See Automatic Support Generation For Defined Parameters for details.","category":"page"},{"location":"guide/parameter/#Automatic-Support-Generation-For-Defined-Parameters-1","page":"Infinite Parameters","title":"Automatic Support Generation For Defined Parameters","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"So far, we have seen that in both definition methods it is allowed to initialize a parameter with no supports. This is done by not specifying supports and num_supports. However, infinite parameters would not be allowed at the transcription step since it needs information about how to discretize the infinite parameters. In previous examples, we have shown that users can add supports to a defined parameter using methods add_supports and set_supports.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In this section we introduce automatic support generation for defined parameters with no associated supports. This can be done using the fill_in_supports! functions. fill_in_supports! can take as argument a ParameterRef, in which case it will generate supports for the associated infinite parameter. Alternatively, fill_in_supports! can also take an InfiniteModel as an argument, in which case it will generate supports for all infinite parameters of the InfiniteModel with no supports.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The fill_in_supports! method allows users to specify integer keyword arguments num_supports and sig_fig. num_supports dictates the number of supports to be generated, and sig_fig dictates the significant figures of generated supports desired. The default values are 50 and 5, respectively.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The ways by which supports are automatically generated are as follows. If the parameter is in an IntervalSet, then we generate an array of supports that are uniformly distributed along the interval, including the two ends. For example, consider a 3D position parameter x distributed in the unit cube [0, 1]. We can generate supports for that point in the following way:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x[1:3] in [0, 1], independent = true);\n\njulia> fill_in_supports!.(x, num_supports = 3);\n\njulia> supports.(x)\n3-element Array{Array{Number,1},1}:\n [0.0, 0.5, 1.0]\n [0.0, 0.5, 1.0]\n [0.0, 0.5, 1.0]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that the dot syntax because fill_in_supports! takes single ParameterRef as argument. In each dimension, three equally spaced supports ([0.0, 0.5, 1.0]) are generated. Since the independent keyword is set as true, the transcription stage will create a three-dimensional grid for all variables parameterized by x, with each point separated by 0.5 units in each dimension.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"If the parameter is in a DistributionSet, fill_in_supports! samples num_supports supports from the distribution. Recall that support generation is not allowed for parameters under multivariate distribution during parameter definition. However, if the parameter is defined first without supports, fill_in_supports! allows for supports generation. For example, for a 2D random variable xi under a multivariate Gaussian distribution, we can generate supports for it in the following way:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> dist = MvNormal([0., 0.], [1. 0.; 0. 2.])\nFullNormal(\ndim: 2\nμ: [0.0, 0.0]\nΣ: [1.0 0.0; 0.0 2.0]\n)\n\n\njulia> @infinite_parameter(model, xi[1:2] in dist);\n\njulia> fill_in_supports!(xi[1], num_supports = 3)\n\njulia> supports.(xi)\n2-element Array{Array{Number,1},1}:\n [0.67911, -0.35301, 0.58662]\n [1.1716, -0.19071, 0.4205]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that for parameters under multivariate distribution, the users do not have to call fill_in_supports! for all ParameterRef associated with that parameter. fill_in_supports!, once called upon one ParameterRef, would search for the other ParameterRef and fill in supports for them if they, together with the original ParameterRef, make up for the same multi-dimensional parameter under a multivariate distribution.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Also, fill_in_supports! only fill in supports for parameters with no associated supports. To modify the supports of parameters already associated with some supports, refer to Supports for how to do that.","category":"page"},{"location":"guide/parameter/#Parameter-Queries-1","page":"Infinite Parameters","title":"Parameter Queries","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In addition to the modeling framework, this package provides many functions for users to access information about the model. This section will go over basic functions for accessing parameter information.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Once a (possibly large-scale) InfiniteModel is built, the users might want to check if an infinite parameter is actually used in any way. This could be checked by is_used function as follows:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, x in [0, 1])\nx\n\njulia> is_used(x)\nfalse\n","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"This function checks if the parameter is used by any constraint, measure, or variable. In a similar way, functions used_by_constraint, used_by_measure and used_by_variable can be applied to find out any dependency of specific types on the infinite parameter.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In addition, sometimes we need to check if a certain ParameterRef is valid with an InfiniteModel model, meaning that the parameter reference actually refers to some parameter associated with the model. We extend the JuMP.is_valid function from JuMP for that purpose. To see how to use this, for example,","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pref1 = ParameterRef(model, 1);\n\njulia> pref2 = ParameterRef(model, 2);\n\njulia> is_valid(model, pref1)\ntrue\n\njulia> is_valid(model, pref2)\nfalse","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"The second call of is_valid returns false because the model does not have parameter with index 2 yet.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also access different information about the set that the infinite parameter is in. This is given by infinite_set, which takes a [ParameterRef] as argument. For example, we have","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> infinite_set(x)\nIntervalSet(0.0, 1.0)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"infinite_set might be more useful if the infinite parameter is in a DistributionSet, by which users can access information about the underlying distribution. On the other hand, if we already know that the parameter is in an interval set, we can use JuMP.has_lower_bound, JuMP.lower_bound, JuMP.has_upper_bound, JuMP.upper_bound to retrieve information about the interval set in a more specific way:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> has_lower_bound(x)\ntrue\n\njulia> lower_bound(x)\n0.0\n\njulia> has_upper_bound(x)\ntrue\n\njulia> upper_bound(x)\n1.0","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For multi-dimensional parameters, the definition step would create the parameter for each dimension an add it into the model separately. However, users can find out if different parameters belong to the same group using group_id function. The group ID is simply an index assigned at the parameter definition. See the following example for how to use it:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> @infinite_parameter(model, y[1:2] in [0, 5])\n2-element Array{ParameterRef,1}:\n y[1]\n y[2]\n\njulia> group_id(x)\n1\n\njulia> group_id(y)\n2\n\njulia> group_id([x, y[1]])\nERROR: Array contains parameters from multiple groups.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In the example above, the function returns the group ID if it receives one ParameterRef. If the argument is a vector of ParameterRef, however, it will throw an error if the parameters do not belong to the same group. Otherwise, it will return the group ID for all parameters in the vector. Again, this function could be helpful if the users want to verify if a set of parameters are correlated.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Another important piece of information about multi-dimensional parameters is whether different dimensions are independent. This can be checked by is_independent:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> is_independent(y[1])\nfalse","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"A quick way for users to obtain a ParameterRef for a parameter with a known name would be through parameter_by_name function. This function takes an InfiniteModel and the parameter name in string, and returns a ParameterRef for that parameter. For example,","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> pref = parameter_by_name(model, \"x\")\nx","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"If there is no parameter associated with that name, the function would return nothing. Otherwise, if multiple parameters share the same name, the function would throw an error.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Now we introduce two additional functions that we can use to access parameter information for an  InfiniteModel. The function num_parameters returns the number of infinite parameters associated with a model, while all_parameters returns the list of all infinite parameter references in the model. For a quick example:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> num_parameters(model)\n3\n\njulia> all_parameters(model)\n3-element Array{ParameterRef,1}:\n x   \n y[1]\n y[2]","category":"page"},{"location":"guide/parameter/#Parameter-Modification-1","page":"Infinite Parameters","title":"Parameter Modification","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In this section we introduce a few shortcuts for users to modify defined infinite parameters.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"First, once an infinite parameter is defined, we can change its name by calling the [JuMP.set_name] function, which takes the [ParameterRef] that needs a name change and the name string as arguments. For example, to change the parameter x to t we can do:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> JuMP.set_name(x, \"t\")\n\njulia> all_parameters(model)\n3-element Array{ParameterRef,1}:\n t   \n y[1]\n y[2]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"In a similar way, we can also change the infinite set that the parameter is in using the set_infinite_set function as follows:","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> t = parameter_by_name(model, \"t\")\nt\n\njulia> set_infinite_set(t, IntervalSet(0, 5))\n\njulia> infinite_set(t)\nIntervalSet(0.0, 5.0)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"For parameters in an IntervalSet, we extend JuMP.set_lower_bound and JuMP.set_upper_bound functions for users to modify the lower bounds and upper bounds. For example,","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> JuMP.set_lower_bound(t, 1)\n\njulia> JuMP.set_upper_bound(t, 4)\n\njulia> infinite_set(t)\nIntervalSet(1.0, 4.0)","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We do not support setting lower bounds and upper bounds for random parameters in a DistributionSet and will throw an error if users attempt to do so. If users want to set lower bound and upper bound for a random infinite parameter, consider using Distributions.Truncated, which creates a truncated distribution from a univariate distribution.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"We can also modify the independent status of a parameter using set_independent and unset_independent functions. The set_independent function sets true for the independent status, while unset_independent function sets false for the independent status.","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"julia> set_independent(y[1])\n\njulia> is_independent(y[1])\ntrue\n\njulia> is_independent(y[2])\nfalse\n\njulia> unset_independent(y[1])\n\njulia> is_independent(y[1])\nfalse","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Note that these two functions takes one single [ParameterRef] as argument, and it will not automatically find the other associated parameters and reset their status altogether. This gives more flexibility on how we want to discretize certain parameters. For example, if for a 3D position parameter x we want to have uniform discretization along x[1], but custom supports over the 2D space x[2] and x[3], we can set x[1] only as independent.","category":"page"},{"location":"guide/parameter/#Datatypes-1","page":"Infinite Parameters","title":"Datatypes","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Pages   = [\"parameter.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"AbstractInfiniteSet\nIntervalSet\nDistributionSet\nInfOptParameter\nParameterRef","category":"page"},{"location":"guide/parameter/#InfiniteOpt.AbstractInfiniteSet","page":"Infinite Parameters","title":"InfiniteOpt.AbstractInfiniteSet","text":"AbstractInfiniteSet\n\nAn abstract type for sets that characterize infinite parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.IntervalSet","page":"Infinite Parameters","title":"InfiniteOpt.IntervalSet","text":"IntervalSet <: AbstractInfiniteSet\n\nA DataType that stores the lower and upper interval bounds for infinite parameters that are continuous over a certain that interval.\n\nFields\n\nlower_bound::Float64 Lower bound of the infinite parameter.\nupper_bound::Float64 Upper bound of the infinite parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.DistributionSet","page":"Infinite Parameters","title":"InfiniteOpt.DistributionSet","text":"DistributionSet{T <: Distributions.NonMatrixDistribution} <: AbstractInfiniteSet\n\nA DataType that stores the distribution characterizing infinite parameters that are random.\n\nFields\n\ndistribution::T Distribution of the random parameter.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.InfOptParameter","page":"Infinite Parameters","title":"InfiniteOpt.InfOptParameter","text":"InfOptParameter{T <: AbstractInfiniteSet} <: JuMP.AbstractVariable\n\nA DataType for storing core infinite parameter information.\n\nFields\n\nset::T The infinite set that characterizes the parameter.\nsupports::Vector{<:Number} The support points used to discretize this                              parameter.\nindependent::Bool Is independent of other parameters that share its group ID                     number.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#InfiniteOpt.ParameterRef","page":"Infinite Parameters","title":"InfiniteOpt.ParameterRef","text":"ParameterRef <: GeneralVariableRef\n\nA DataType for untranscripted infinite parameters references that parameterize the infinite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/parameter/#Methods/Macros-1","page":"Infinite Parameters","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"Pages   = [\"parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/parameter/#","page":"Infinite Parameters","title":"Infinite Parameters","text":"@infinite_parameter\nIntervalSet(::Number, ::Number)\nbuild_parameter(::Function, ::AbstractInfiniteSet)\nadd_parameter(::InfiniteModel, ::InfOptParameter)\nused_by_constraint(::ParameterRef)\nused_by_measure(::ParameterRef)\nused_by_variable(::ParameterRef)\nis_used(::ParameterRef)\nJuMP.delete(::InfiniteModel, ::ParameterRef)\nJuMP.is_valid(::InfiniteModel, ::ParameterRef)\nJuMP.name(::ParameterRef)\nJuMP.set_name(::ParameterRef, ::String)\nnum_parameters(::InfiniteModel)\ninfinite_set(::ParameterRef)\nset_infinite_set(::ParameterRef, ::AbstractInfiniteSet)\nJuMP.has_lower_bound(::ParameterRef)\nJuMP.lower_bound(::ParameterRef)\nJuMP.set_lower_bound(::ParameterRef, ::Number)\nJuMP.has_upper_bound(::ParameterRef)\nJuMP.upper_bound(::ParameterRef)\nJuMP.set_upper_bound(::ParameterRef, ::Number)\nnum_supports(::ParameterRef)\nhas_supports(::ParameterRef)\nsupports(::ParameterRef)\nsupports(::AbstractArray{<:ParameterRef})\nset_supports(::ParameterRef, ::Vector{<:Number})\nadd_supports(::ParameterRef, ::Union{Number, Vector{<:Number}})\ndelete_supports(::ParameterRef)\nfill_in_supports!(::InfiniteModel)\nfill_in_supports!(::ParameterRef)\ngroup_id(::ParameterRef)\ngroup_id(::AbstractArray{<:ParameterRef})\nis_independent(::ParameterRef)\nset_independent(::ParameterRef)\nunset_independent(::ParameterRef)\nparameter_by_name(::InfiniteModel, ::String)\nall_parameters(::InfiniteModel)","category":"page"},{"location":"guide/parameter/#InfiniteOpt.@infinite_parameter","page":"Infinite Parameters","title":"InfiniteOpt.@infinite_parameter","text":"@infinite_parameter(model, kw_args...)\n\nAdd an anonymous infinite parameter to the model model described by the keyword arguments kw_args and returns the parameter reference.\n\n@infinite_parameter(model, expr, kw_args...)\n\nAdd a parameter to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. (note that in the following the symbol <= can be used instead of ≤, the symbol >=can be used instead of ≥, and the symbo in can be used instead of ∈) The expression expr can be of the form:\n\nparamexpr creating parameters described by paramexpr.\nlb ≤ paramexpr ≤ ub creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ [lb, ub] creating parameters described by paramexpr characterized  by a continuous interval set with lower bound lb and upper bound ub.\nparamexpr ∈ dist creating parameters described by paramexpr characterized  by the Distributions.jl distribution object dist.\n\nThe expression paramexpr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the parameter lower bound for an interval set.\nupper_bound: Sets the value of the parameter upper bound for an interval set.\nset: The InfiniteSet characterizing the parameters see IntervalSet  and DistributionSet.\ndistribution: Sets the Distributions.jl distribution object that characterizes the parameters.\nsupports: Sets the support points for the parameters.\nnum_supports: Specifies the number of supports to be automatically generated.                 Note that supports takes precedence. Defaults to 50.\nsig_figs: Specifies the number of significant digits that should be used             in automatic support generation. Defaults to 5.\nindependent: Specifies if the each parameter is independent from each other or not. Defaults to false.\ncontainer: Specify the container type. Defaults to automatic\n\nExamples\n\njulia> @infinite_parameter(m, 0 <= x <= 1)\nx\n\njulia> @infinite_parameter(m, y[i = 1:2] in Normal(), num_supports = 10)\n2-element Array{ParameterRef,1}:\n y[1]\n y[2]\n\njulia> z = @infinite_parameter(m, [\"a\", \"b\"], distribution = Uniform(), independent = true)\n2-dimensional DenseAxisArray{ParameterRef,2,...} with index sets:\n    Dimension 1, \"a\"\n    Dimension 2, \"b\"\nAnd data, a 1×1 Array{ParameterRef,2}:\n noname\n\n\n\n\n\n","category":"macro"},{"location":"guide/parameter/#InfiniteOpt.IntervalSet-Tuple{Number,Number}","page":"Infinite Parameters","title":"InfiniteOpt.IntervalSet","text":"IntervalSet(lower_bound::Number, upper_bound::Number)\n\nA constructor for IntervalSet that converts values of type Number to values of type Float64 as required by IntervalSet.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.build_parameter-Tuple{Function,AbstractInfiniteSet}","page":"Infinite Parameters","title":"InfiniteOpt.build_parameter","text":"build_parameter(_error::Function, set::AbstractInfiniteSet,\n                [num_params::Int = 1; num_supports::Int = 0,\n                supports::Union{Number, Vector{<:Number}} = Number[],\n                independent::Bool = false,\n                sig_fig::Int = 5])::InfOptParameter\n\nReturns a InfOptParameter given the appropriate information. This is analagous to JuMP.build_variable. Errors if supports violate the bounds associated set. Also errors if set contains a multivariate distribution with a different dimension than num_params. This is meant to primarily serve as a helper method for @infinite_parameter.\n\nExample\n\njulia> build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_parameter-Tuple{InfiniteModel,InfOptParameter}","page":"Infinite Parameters","title":"InfiniteOpt.add_parameter","text":"add_parameter(model::InfiniteModel, p::InfOptParameter,\n              [name::String = \"\"])::ParameterRef\n\nReturns a ParameterRef associated with the parameter p that is added to model. This adds a parameter to the model in a manner similar to JuMP.add_variable. This can be used to add parameters with the use of @infinite_parameter. build_parameter should be used to construct p.\n\nExample\n\njulia> p = build_parameter(error, IntervalSet(0, 3), supports = Vector(0:3))\nInfOptParameter{IntervalSet}(IntervalSet(0.0, 3.0), [0, 1, 2, 3], false)\n\njulia> param_ref = add_parameter(model, p, \"name\")\nname\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_constraint-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(pref::ParameterRef)::Bool\n\nReturn true if pref is used by a constraint or false otherwise.\n\nExample\n\njulia> used_by_constraint(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_measure-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(pref::ParameterRef)::Bool\n\nReturn true if pref is used by a measure or false otherwise.\n\nExample\n\njulia> used_by_measure(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.used_by_variable-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.used_by_variable","text":"used_by_variable(pref::ParameterRef)::Bool\n\nReturn true if pref is used by an infinite variable or false otherwise.\n\nExample\n\njulia> used_by_variable(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.is_used-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_used","text":"is_used(pref::ParameterRef)::Bool\n\nReturn true if pref is used in the model or false otherwise.\n\nExample\n\njulia> is_used(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.delete-Tuple{InfiniteModel,ParameterRef}","page":"Infinite Parameters","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, pref::ParameterRef)\n\nExtend JuMP.delete to delete infinite parameters and their dependencies. All variables, constraints, and measure functions that depend on pref are updated to exclude it. Errors if the parameter is contained in an AbstractMeasureData datatype that is employed by a measure since the measure becomes invalid otherwise. Thus, measures that contain this dependency must be deleted first. Note that _check_param_in_data(pref, measure_data) needs to be extended to allow deletion of parameters when custom AbstractMeasureData datatypes are used.\n\nExample\n\njulia> print(model)\nMin measure(g(t, x)*t + x) + z\nSubject to\n z >= 0.0\n g(t, x) + z >= 42.0\n g(0.5, x) == 0\n t in [0, 6]\n x in [0, 1]\n\njulia> delete(model, x)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n g(t) + z >= 42.0\n g(0.5) == 0\n z >= 0.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.is_valid-Tuple{InfiniteModel,ParameterRef}","page":"Infinite Parameters","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, pref::ParameterRef)::Bool\n\nExtend the JuMP.is_valid function to accomodate infinite parameters. Returns true if the InfiniteModel stored in pref matches model and if the parameter index is used by model. It returns false otherwise.\n\nExample\n\njulia> is_valid(model, t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.name-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.name","text":"JuMP.name(pref::ParameterRef)::String\n\nExtend the JuMP.name function to accomodate infinite parameters. Returns the name string associated with pref.\n\nExample\n\njulia> name(t)\n\"t\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_name-Tuple{ParameterRef,String}","page":"Infinite Parameters","title":"JuMP.set_name","text":"JuMP.set_name(pref::ParameterRef, name::String)\n\nExtend the JuMP.set_name function to accomodate infinite parameters. Set a new base name to be associated with pref.\n\nExample\n\njulia> set_name(t, \"time\")\n\njulia> name(t)\n\"time\"\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_parameters-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.num_parameters","text":"num_parameters(model::InfiniteModel)::Int\n\nReturn the number of infinite parameters currently present in model.\n\nExample\n\njulia> num_parameters(model)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.infinite_set-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.infinite_set","text":"infinite_set(pref::ParameterRef)::AbstractInfiniteSet\n\nReturn the infinite set associated with pref.\n\nExample\n\njulia> infinite_set(t)\nIntervalSet(0.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_infinite_set-Tuple{ParameterRef,AbstractInfiniteSet}","page":"Infinite Parameters","title":"InfiniteOpt.set_infinite_set","text":"set_infinite_set(pref::ParameterRef, set::AbstractInfiniteSet)\n\nSpecify the infinite set of pref.\n\nExample\n\njulia> set_infinite_set(t, IntervalSet(0, 2))\n\njulia> infinite_set(t)\nIntervalSet(0.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_lower_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(pref::ParameterRef)::Bool\n\nExtend the JuMP.has_lower_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined lower bound or if a lower bound can be found.\n\nExample\n\njulia> has_lower_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.lower_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.lower_bound","text":"JuMP.lower_bound(pref::ParameterRef)::Number\n\nExtend the JuMP.lower_bound function to accomodate infinite parameters. Returns the lower bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> lower_bound(t)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_lower_bound-Tuple{ParameterRef,Number}","page":"Infinite Parameters","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(pref::ParameterRef, lower::Number)\n\nExtend the JuMP.set_lower_bound function to accomodate infinite parameters. Updates the infinite set lower bound if and only if it is an IntervalSet. Errors otherwise.\n\nExample\n\njulia> set_lower_bound(t, -1)\n\njulia> lower_bound(t)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.has_upper_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(pref::ParameterRef)::Bool\n\nExtend the JuMP.has_upper_bound function to accomodate infinite parameters. Return true if the set associated with pref has a defined upper bound or if a upper bound can be found.\n\nExample\n\njulia> has_upper_bound(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.upper_bound-Tuple{ParameterRef}","page":"Infinite Parameters","title":"JuMP.upper_bound","text":"JuMP.upper_bound(pref::ParameterRef)::Number\n\nExtend the JuMP.upper_bound function to accomodate infinite parameters. Returns the upper bound associated with the infinite set. Errors if such a bound is not well-defined.\n\nExample\n\njulia> upper_bound(t)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#JuMP.set_upper_bound-Tuple{ParameterRef,Number}","page":"Infinite Parameters","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(pref::ParameterRef, lower::Number)\n\nExtend the JuMP.set_upper_bound function to accomodate infinite parameters. Updates the infinite set upper bound if and only if it is an IntervalSet. Errors otherwise.\n\nExample\n\njulia> set_upper_bound(t, 2)\n\njulia> upper_bound(t)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.num_supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.num_supports","text":"num_supports(pref::ParameterRef)::Int\n\nReturn the number of support points associated with pref.\n\nExample\n\njulia> num_supports(t)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.has_supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.has_supports","text":"has_supports(pref::ParameterRef)::Bool\n\nReturn true if pref has supports or false otherwise.\n\nExample\n\njulia> has_supports(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(pref::ParameterRef)::Vector\n\nReturn the support points associated with pref. Errors if there are no supports.\n\nExample\n\njulia> supports(t)\n2-element Array{Int64,1}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.supports-Tuple{AbstractArray{#s2,N} where N where #s2<:ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.supports","text":"supports(prefs::AbstractArray{<:ParameterRef})::Vector\n\nReturn the support points associated with an array of prefs formatted as a vector of SparseAxisArrays following the format of the input array. If the parameters are not independent then the supports of each parameter are simply spliced together. Alternatively can call supports. to more efficiently obtain an array of the same input format whose parameter references have been replaced with their supports. Errors if all the parameter references do not have the same group ID number (were intialized together as an array) or if the nonindependent parameters have support vectors of different lengths. If the parameters are independent then all the unique combinations are identified and returned as supports. Warning this operation is computationally expensive if there exist a large number of combinations.\n\nExample\n\njulia> x = @infinite_parameter(model, [i = 1:2], set = IntervalSet(-1, 1),\n                               base_name = \"x\", independent = true)\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> for i = 1:length(x)\n           set_supports(x[i], [-1, 1])\n       end\n\njulia> supports(x)\n4-element Array{JuMP.Containers.SparseAxisArray,1}:\n   [2]  =  -1\n  [1]  =  -1\n   [2]  =  1\n  [1]  =  -1\n   [2]  =  -1\n  [1]  =  1\n   [2]  =  1\n  [1]  =  1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_supports-Tuple{ParameterRef,Array{#s2,1} where #s2<:Number}","page":"Infinite Parameters","title":"InfiniteOpt.set_supports","text":"set_supports(pref::ParameterRef, supports::Vector{<:Number}; [force = false])\n\nSpecify the support points for pref. Errors if the supports violate the bounds associated with the infinite set. Warns if the points are not unique. If force this will overwrite exisiting supports otherwise it will error if there are existing supports.\n\nExample\n\njulia> set_supports(t, [0, 1])\n\njulia> supports(t)\n2-element Array{Int64,1}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.add_supports-Tuple{ParameterRef,Union{Number, Array{#s2,1} where #s2<:Number}}","page":"Infinite Parameters","title":"InfiniteOpt.add_supports","text":"add_supports(pref::ParameterRef, supports::Union{Number, Vector{<:Number}})\n\nAdd additional support points for pref.\n\nExample\n\njulia> add_supports(t, 0.5)\n\njulia> supports(t)\n3-element Array{Float64,1}:\n 0.0\n 1.0\n 0.5\n\njulia> add_supports(t, [0.25, 1])\n\njulia> supports(t)\n4-element Array{Float64,1}:\n 0.0\n 1.0\n 0.5\n 0.25\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.delete_supports-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.delete_supports","text":"delete_supports(pref::ParameterRef)\n\nDelete the support points for pref.\n\nExample\n\njulia> delete_supports(t)\n\njulia> supports(t)\nERROR: Parameter t does not have supports.\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.fill_in_supports!-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(model::InfiniteModel; [num_supports::Int = 50,\n                  sig_fig::Int = 5])\n\nAutomatically generate support points for all infinite parameters in model except for parameters in multivariate distributions, where we require that the user inputs the supports. User can specify the number of significant figures kept after decimal point for the auto-generated supports wtih sig_fig.\n\nExample\n\njulia> fill_in_supports!(model, num_supports = 4, sig_fig = 3)\n\njulia> supports(x)\n4-element Array{Number,1}:\n 0.0\n 0.333\n 0.667\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.fill_in_supports!-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.fill_in_supports!","text":"fill_in_supports!(pref::ParameterRef; [num_supports::Int = 50,\n                                       sig_fig::Int = 5])\n\nAutomatically generate support points for all infinite parameters in model except for parameters in multivariate distributions, where we require that the user inputs the supports. User can specify the number of digits kept after decimal point for the auto-generated supports wtih sig_fig.\n\nExample\n\njulia> fill_in_supports!(x, num_supports = 4, sig_fig = 3)\n\njulia> supports(x)\n4-element Array{Number,1}:\n 0.0\n 0.333\n 0.667\n 1.0\n\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.group_id-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.group_id","text":"group_id(pref::ParameterRef)::Int\n\nReturn the group ID number for pref.\n\nExample\n\njulia> group_id(t)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.group_id-Tuple{AbstractArray{#s2,N} where N where #s2<:ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.group_id","text":"group_id(prefs::AbstractArray{<:ParameterRef})::Int\n\nReturn the group ID number for a group of prefs. Error if contains multiple groups.\n\nExample\n\njulia> group_id([x[1], x[2]])\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.is_independent-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.is_independent","text":"is_independent(pref::ParameterRef)::Bool\n\nReturns true for pref if it is independent or false otherwise.\n\nExample\n\njulia> is_independent(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.set_independent-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.set_independent","text":"set_independent(pref::ParameterRef)\n\nSpecify that pref be independent.\n\nExample\n\njulia> set_independent(t)\n\njulia> is_independent(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.unset_independent-Tuple{ParameterRef}","page":"Infinite Parameters","title":"InfiniteOpt.unset_independent","text":"unset_independent(pref::ParameterRef)\n\nSpecify that pref be not independent.\n\nExample\n\njulia> unset_independent(t)\n\njulia> is_independent(t)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.parameter_by_name-Tuple{InfiniteModel,String}","page":"Infinite Parameters","title":"InfiniteOpt.parameter_by_name","text":"parameter_by_name(model::InfiniteModel, name::String)::Union{ParameterRef,\n                                                             Nothing}\n\nReturn the parameter reference assoociated with a parameter name. Errors if multiple parameters have the same name. Returns nothing if no such name exists.\n\nExample\n\njulia> parameter_by_name(model, \"t\")\nt\n\n\n\n\n\n","category":"method"},{"location":"guide/parameter/#InfiniteOpt.all_parameters-Tuple{InfiniteModel}","page":"Infinite Parameters","title":"InfiniteOpt.all_parameters","text":"all_parameters(model::InfiniteModel)::Vector{ParameterRef}\n\nReturn all of the infinite parameter references currently in model.\n\nExample\n\njulia> all_parameters(model)\n3-element Array{ParameterRef,1}:\n t\n x[1]\n x[2]\n\n\n\n\n\n","category":"method"},{"location":"guide/finite_parameter/#Finite-Parameters-1","page":"Finite Parameters","title":"Finite Parameters","text":"","category":"section"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"A guide and manual to the definition and use of finite parameters in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/finite_parameter/#Overview-1","page":"Finite Parameters","title":"Overview","text":"","category":"section"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"Often a mathematical model needs to be optimized several times in accordance with a set of fixed parameter values. In such cases, it is typically preferable to modify these values in place without having to redefine the entire model. This ability is provided in InfiniteOpt via @finite_parameter which permits users to define finite parameters whose values can later be modified as needed. Furthermore, at the optimization step these parameters are replaced with their numeric values. Thus, not adding unnecessary decision variables as is typically done in JuMP models using JuMP.fix on placeholder variables.  ","category":"page"},{"location":"guide/finite_parameter/#Basic-Usage-1","page":"Finite Parameters","title":"Basic Usage","text":"","category":"section"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"Once an InfiniteModel model has been defined we can add a finite parameter via @finite_parameter. For example, let's define a maximum cost parameter called max_cost with an initial value of 42:","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"julia> @finite_parameter(model, max_cost, 42)\nmax_cost","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"Notice that a Julia variable called max_cost is returned that contains a ParameterRef that points to the finite parameter we have just created. An array of parameters can also be defined following standard JuMP macro syntax:","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"julia> values = [2, 3.2, 1];\n\njulia> @finite_parameter(model, params[i = 1:3], values[i])\n3-element Array{ParameterRef,1}:\n params[1]\n params[2]\n params[3]","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"The @finite_parameter macro emulates all typical JuMP functionality and can define anonymous parameters, use JuMP containers and more. We refer to its documentation below to learn more. Once a finite parameter is defined the corresponding ParameterRef can be used in expressions, objectives, measures, and constraints just like infinite parameters.","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"The value of a finite parameter can be checked using JuMP.value and can modified using JuMP.set_value. For example, let's update the value of max_cost to be now be 10.2:","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"julia> value(max_cost)\n42\n\njulia> set_value(max_cost, 10.2)\n\njulia> value(max_cost)\n10.2","category":"page"},{"location":"guide/finite_parameter/#Advanced-Details-1","page":"Finite Parameters","title":"Advanced Details","text":"","category":"section"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"The ability to implement finite parameters simply stems from InfiniteOpt's framework for infinite parameters. In reality finite parameters are simply infinite parameters defined with an IntervalSet whose lower and upper bounds equal to the desired value. Thus, @finite_parameter simply processes the names, values, and other arguments and then makes the appropriate @infinite_parameter call. For example, the following calls are equivalent:","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"julia> @finite_parameter(model, param[1:2], 42)\n2-element Array{ParameterRef,1}:\n param[1]\n param[2]\n\njulia> @infinite_parameter(model, param[1:2] in [42, 42], supports = [42])\n2-element Array{ParameterRef,1}:\n param[1]\n param[2]","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"Furthermore, the JuMP.value checks the bound value (also ensuring the bounds match) and JuMP.set_value updates the the IntervalSet and updates the support value.","category":"page"},{"location":"guide/finite_parameter/#Methods/Macros-1","page":"Finite Parameters","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"Pages   = [\"finite_parameter.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/finite_parameter/#","page":"Finite Parameters","title":"Finite Parameters","text":"@finite_parameter\nis_finite_parameter\nJuMP.value(::ParameterRef)\nJuMP.set_value(::ParameterRef, ::Number)","category":"page"},{"location":"guide/finite_parameter/#InfiniteOpt.@finite_parameter","page":"Finite Parameters","title":"InfiniteOpt.@finite_parameter","text":"@finite_parameter(model::InfiniteModel, value)\n\nDefine and add an anonymous finite parameter to model and return its parameter reference. Its value is equal to value.\n\n    @finite_parameter(model::InfiniteModel, param_expr, value_expr)\n\nDefine and add a finite parameter(s) to model and return appropriate parameter reference(s). The parameter(s) has/have value(s) indicated by the value_expr. The expression param_expr can be of the form:\n\nparamname creating a scalar parameter of name paramname\nparamname[...] or [...] creating a container of parameters\n\nThe expression value_expr simply expresses the value of the parameter(s). This is typically a number but could be an array indexed using an index defined in param_expr.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate parameter names. It corresponds to the parameter name for scalar parameter, otherwise, the parameter names are set to base_name[...] for each index ... of the axes axes.\ncontainer: Specify the container type.\n\nExamples\n\njulia> par = @finite_parameter(model, 2)\nnoname\n\njulia> vals = [3, 2];\n\njulia> pars = @finite_parameter(model, [i = 1:2], vals[i], base_name = \"par\")\n2-element Array{ParameterRef,1}:\n par[1]\n par[2]\n\njulia> @finite_parameter(model, par2, 42)\npar2\n\n\n\n\n\n","category":"macro"},{"location":"guide/finite_parameter/#InfiniteOpt.is_finite_parameter","page":"Finite Parameters","title":"InfiniteOpt.is_finite_parameter","text":"is_finite_parameter(pref::ParameterRef)::Bool\n\nReturn a Bool indicating if pref is a finite parameter.\n\nExample\n\njulia> is_finite_parameter(cost)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"guide/finite_parameter/#JuMP.value-Tuple{ParameterRef}","page":"Finite Parameters","title":"JuMP.value","text":"JuMP.value(pref::ParameterRef)::Number\n\nReturn the value of pref so long as it is a finite parameter. Errors if it is an infinite parameter.\n\nExample\n\njulia> value(cost)\n42\n\n\n\n\n\n","category":"method"},{"location":"guide/finite_parameter/#JuMP.set_value-Tuple{ParameterRef,Number}","page":"Finite Parameters","title":"JuMP.set_value","text":"JuMP.set_value(pref::ParameterRef, value::Number)\n\nSet the value of pref so long as it is a finite parameter. Errors if it is an infinite parameter.\n\nExample\n\njulia> set_value(cost, 27)\n\njulia> value(cost)\n27\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#Variables-1","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"A guide and manual for the definition and use of variables in InfiniteOpt. The Datatypes and Methods sections at the end comprise the manual, and the above sections comprise the guide.  ","category":"page"},{"location":"guide/variable/#Overview-1","page":"Variables","title":"Overview","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Decision variables are at the very core of InfiniteOpt as its name alludes to mathematical programs that entail infinite decision spaces (i.e., contain infinite decision variables). Principally, three variable types are employed: infinite, point, and hold. Infinite variables encompass any decision variable that is parameterized by an infinite parameter (e.g., space-time variables and recourse variables). Point variables are infinite variables at a particular infinite parameter value (point). Finally, hold variables are decisions that are made irrespective of the infinite domain (e.g., first stage variables and design variables). Or in other words, they hold a particular value over the infinite domain or some sub-domain of it.","category":"page"},{"location":"guide/variable/#Basic-Usage-1","page":"Variables","title":"Basic Usage","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Infinite, point, and hold variables are typically defined via their respective macros: @infinite_variable, @point_variable, and @hold_variable. These macros generally emulate JuMP.@variable except that they each employ additional syntax capabilities to employ their respective variable type.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Let's first setup a simple space-time model with infinite parameters time t and spatial position x:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> using InfiniteOpt, JuMP\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_parameter(model, x[1:2] in [-1, 1], independent = true)\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]","category":"page"},{"location":"guide/variable/#Infinite-Variables-1","page":"Variables","title":"Infinite Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Now let's define a time dependent infinite variable y(t) with a lower bound of 0:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, y(t) >= 0)\ny(t)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"This creates a Julia variable y that points to the decision variable y(t) that is stored in model which is added to include a lower bound of 0. Another useful case is that of defining an array of variables w that depend on both position and time:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, w[i = 1:3](t, x), start = [0, 2, 1][i])\n3-element Array{InfiniteVariableRef,1}:\n w[1](t, x)\n w[2](t, x)\n w[3](t, x)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus we create a Julia array variable w whose elements w[i] point to their respective infinite variables w[i](t, x) stored in model. Note that the i used in the array definition can be used to index attributes assigned to each variable in the array. In this case, we used i to assign different initial guess values for each variable via the start keyword argument.","category":"page"},{"location":"guide/variable/#Point-Variables-1","page":"Variables","title":"Point Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Now let's add some point variables. These allow us to consider an infinite variable evaluated at a certain infinite parameter point. For example, let's define a point variable for y(0) with the alias y0 that is fixed at a value of 0:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @point_variable(model, y(0), y0 == 0)\ny0","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we create a Julia variable y0 which points to the point variable y(0). Notice that in the second argument we specify the infinite variable indexed at the appropriate parameter value(s). Point variables automatically inherit attributes of the infinite variable (e.g., bounds, start values, etc.), but these are overwritten with properties specified for the point variable. In this case the lower bound inherited from y(t) is overwritten by instead fixing y(0) to a value of 0.  ","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"note: Note\nPoint variables are provided for enhancing the generality of InfiniteOpt, but typically can be avoided by using infinite variables in combination with @BDconstraint to define bounded constraints ( e.g., initial conditions).","category":"page"},{"location":"guide/variable/#Hold-Variables-1","page":"Variables","title":"Hold Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Finally, we can add hold variables to our model. These denote variables that hold a single value over the infinite domain or some portion of it (e.g., design variables, first stage variables, etc.). Let's add a hold variable 0 leq d leq 42 that is an integer variable and defined over all infinite domains (i.e., time and space):","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, 0 <= d <= 42, Int)\nd","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"This creates a Julia variable d that points to the hold variable d which has a lower bound of 0, an upper bound of 42, and is an integer variable. Thus, @hold_variable follows the same exact syntax as JuMP.@variable except that it also allows the user to specify a subdomain over which the hold variable is valid. For example, let's add a hold variable z that is only valid over the subdomain t in 0 5 via the parameter_bounds keyword argument:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> anon = @hold_variable(model, parameter_bounds = (t in [0, 5]),\n                             base_name = \"z\")\nz","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we make an anonymous variable for the sake of example whose reference is stored to the Julia variable anon and points to a hold variable z which is only valid for t in 0 5. Thus, this will be enforced in any constraints that involve anon, meaning they will automatically be bounded to such a subdomain. Any number of parameters bounds (bounds on the parameters of the infinite domain) can be added in a tuple like argument as explained in the documentation for @hold_variable.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Now we have defined variables that we can use in the objective, measures, and constraints. Please note that the above tutorial only shows a small portion of the capabilities and options available in defining variables. A full description is provided in the documentation below.","category":"page"},{"location":"guide/variable/#Variable-Definition-Methodology-1","page":"Variables","title":"Variable Definition Methodology","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The @infinite_variable, @point_variable, and @hold_variable macros all follow a similar methodology behind the scenes and these commonalities are discussed in this section for conciseness. Defining/initializing a variable principally involves the following steps:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Define the variable information pertaining to JuMP.VariableInfo (e.g., bounds, indicate if it is integer, etc.)\nConstruct a concrete subtype of InfOptVariable to store the variable information\nAdd the InfOptVariable object to an InfiniteModel and assign a name\nCreate a concrete subtype of InfOptVariableRef that points to the variable object stored in the model","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The JuMP.VariableInfo data structure stores the following variable information:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"has_lb::Bool: Specifies a Bool it has a lower bound\nlower_bound::Number: Specifies lower bound value\nhas_ub::Bool: Specifies a Bool it has a upper bound\nupper_bound::Number: Specifies upper bound value\nhas_fix::Bool: Specifies a Bool it is fixed\nfixed_value::Number: Specifies the fixed value\nhas_start::Bool: Specifies a Bool it has a start value\nstart::Number: Specifies the start value\nbinary: Specifies Bool if it is binary\ninteger: Specifies Bool if it is integer.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, the user specifies this information to prepare such an object:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> info = VariableInfo(true, 0, true, 42, false, 0, false, 0, false, true)\nVariableInfo{Int64,Int64,Int64,Int64}(true, 0, true, 42, false, 0, false, 0, false, true)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we specified a lower bound of 0, an upper bound of 42, and that it is integer.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The variable objects (InfOptVariable subtypes) are defined via build_variable which requires that the user provide a JuMP.VariableInfo object, the variable type to be defined (Infinite, Point, or Hold), and any necessary keyword arguments required for that variable type (i.e., parameter_refs, infinite_variable_ref, and/or parameter_values). For example, let's build an infinite variable y(t) that has an lower bound of 0, an upper bound of 42, and is integer:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> info = VariableInfo(true, 0, true, 42, false, 0, false, 0, false, true);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = (t))\nInfiniteVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}(true, 0, true, 42, false, 0, false, 0, false, true), (t,))","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, we create an InfiniteVariable object with the desired properties. Note that in this case the parameter_refs keyword argument is required to indicate which infinite parameter(s) this infinite variable will depend on.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Once a variable has been built, it needs to be added to our model and a Julia variable should be defined to reference it. Variables are added via add_variable which adds a variable object to the model, assigns a name to the variable, adds any constraints associated with the JuMP.VariableInfo, and returns an appropriate variable reference variable (subtyped from InfOptVariableRef). For example, let's add inf_var to model:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> var_ref = add_variable(model, inf_var, \"y\")\ny(t)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, we have added an infinite variable y that is parameterized by t with the variable information mentioned above and now have a InfiniteVariableRef called var_ref that can be used in defining our infinite model.","category":"page"},{"location":"guide/variable/#Macro-Variable-Definition-1","page":"Variables","title":"Macro Variable Definition","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The @infinite_variable, @point_variable, and @hold_variable macros automate the variable definition process discussed above in the Variable Definition Methodology section via a straightforward symbolic syntax. The only key difference is that non-anonymous macro calls will register variable names to ensure they are not repeated. Anonymous macro calls forgo this step and exactly follow the process described above. This section will highlight the details of using these macros.","category":"page"},{"location":"guide/variable/#var_macro_gen_usage-1","page":"Variables","title":"General Usage","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we discuss the features that the variable macros have in common (generally these pertain to JuMP-like features). To illustrate this via example, let's setup a model with a variety of infinite parameters t in 010, x in -1 1^3, and xi in mathcalN(0 1):","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> using InfiniteOpt, JuMP, Distributions\n\njulia> model = InfiniteModel();\n\njulia> @infinite_parameter(model, t in [0, 10]);\n\njulia> @infinite_parameter(model, x[1:3] in [-1, 1], independent = true);\n\njulia> @infinite_parameter(model, ξ in Normal());","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"We will first consider anonymous variable macro calls which generally are less convenient than non-anonymous macro calls which offer a much more intuitive mathematical syntax. However, anonymous variables can be useful and provide a good foundation to understanding non-anonymous variables. Furthermore, we'll use hold variables as the motivating examples since they best exemplify commonalities between the macros. First, let's consider single anonymous definition a hold variable:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> var_ref = @hold_variable(model)\nnoname","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we just added a nameless hold variable to model and defined var_ref as a HoldVariableRef that points to it. We can add a name via the base_name keyword argument:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> var_ref1 = @hold_variable(model, base_name = \"d\")\nd\n\njulia> var_ref2 = @hold_variable(model, base_name = \"d\")\nd","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Now we've made 2 more hold variables both called d. Thus, the anonymous syntax allows us to define variables with the same name. Moreover, any variable information can be specified via the appropriate keywords which include:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"lower_bound::Number: specifies lower bound\nupper_bound::Number: specifies upper bound\nstart::Number: specifies the initial guess value the solver will use\nbinary::Bool: specifies if is binary variable\ninteger::Bool: specifies if is integer variable.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Anonymous variables must use these keyword arguments since symbolic definition is only permitted for non-anonymous macro calls. For example, let's define a hold variable 0 leq d leq 5 that is integer:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> var_ref = @hold_variable(model, base_name = \"d\", lower_bound = 0,\n                                upper_bound = 5, integer = true)\nd","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"We can also define arrays of variables using any indices of our choice. For example, let's define a 3 dimensional vector with indices [1, 2, 3]:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> var_refs = @hold_variable(model, [i = 1:3], start = [0, 2, 1][i],\n                                 base_name = \"d\")\n3-element Array{HoldVariableRef,1}:\n d[1]\n d[2]\n d[3]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, we define 3 variables named d[i] and each with different start values and define var_refs which is a vector of HoldVariableRefs that uses the indices we specified. Note the syntax i = indices is used to define an iteration variable to use with the keyword arguments to assign different values for each variable being defined. Note the above example is equivalent to:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> starts = [0, 2, 1];\n\njulia> var_refs = Vector{HoldVariableRef}(undef, 3);\n\njulia> for i = eachindex(var_refs)\n          var_refs[i] = @hold_variable(model, base_name = \"d\", start = starts[i])\n       end","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Other non-standard indices can also be used such as the following examples:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> var_refs2 = @hold_variable(model, [2:4], base_name = \"d\")\n1-dimensional DenseAxisArray{HoldVariableRef,1,...} with index sets:\n    Dimension 1, 2:4\nAnd data, a 3-element Array{HoldVariableRef,1}:\n d[2]\n d[3]\n d[4]\n\njulia> var_refs3 = @hold_variable(model, [[:A, :C, :Z]], base_name = \"d\")\n1-dimensional DenseAxisArray{HoldVariableRef,1,...} with index sets:\n    Dimension 1, Symbol[:A, :C, :Z]\nAnd data, a 3-element Array{HoldVariableRef,1}:\n d[A]\n d[C]\n d[Z]\n\njulia> var_refs3 = @hold_variable(model, [i=1:2, j=i:2], base_name = \"d\")\nJuMP.Containers.SparseAxisArray{HoldVariableRef,2,Tuple{Any,Any}} with 3 entries:\n  [1, 2]  =  d[1,2]\n  [2, 2]  =  d[2,2]\n  [1, 1]  =  d[1,1]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we see that a variety of indices can be used and this is explained more fully in the documentation of JuMP.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"JuMP employs 2 special array container types: DenseAxisArrays and SparseAxisArrays which help facilitate this special indexing. The variable macros will by default automatically detect which container type should be used. However, the user can specify a particular container type using the container keyword. For example, if we want to use indices a:b where a = 1 and b = 3, a DenseAxisArray will be used by default, but we can force it to be a regular Array:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> a = 1; b = 3;\n\njulia> var_refs1 = @hold_variable(model, [a:b], base_name = \"d\")\n1-dimensional DenseAxisArray{HoldVariableRef,1,...} with index sets:\n    Dimension 1, 1:3\nAnd data, a 3-element Array{HoldVariableRef,1}:\n d[1]\n d[2]\n d[3]\n\njulia> var_refs2 = @hold_variable(model, [a:b], base_name = \"d\", container = Array)\n3-element Array{HoldVariableRef,1}:\n d[1]\n d[2]\n d[3]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Now that we have a foundation with anonymous variable macro calls, let's focus on non-anonymous calls which offer a much more straightforward syntax. These calls can still implement all of the same keyword arguments. Moreover, they automatically create a Julia variable with the variable name provided and register this name to ensure subsequent automatic Julia variables do not overwrite it.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The supported symbolic syntax principally implements the following keyword arguments:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"base_name\nlower_bound\nupper_bound\ninteger\nbinary\nparameter_refs (for infinite variables)\ninfinite_variable_ref (for point variables)\nparameter_values (for point variables).","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"These are implemented via the syntax @[type]_variable(model, expr, integrality_arg, keyword_args...). Here expr specifies the name, bounds, and/or variable specific keyword arguments. It can use the following forms (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥):","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"varexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, providing an intuitive means to specify bounds. The expressions varexpr specifies the name, dimensions, and/or type specific keywords and can be of the form:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"varname creating a scalar real variable of name varname\nvarname[...] creating a container of variables with indices ...\nvarname(params) creating an infinite variable dependent on params\nvarname[...](params) creating infinite variables dependent on params.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The integrality_arg optionally is used to indicate if the variable(s) is/are integer or binary using Int or Bin, respectively.  ","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"For example, let's define a hold variable 0 leq d leq 3 that is integer:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, 0 <= d <= 3, Int)\nd","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Note this is equivalent to","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> d = @hold_variable(model, base_name = \"d\", lower_bound = 0, upper_bound = 3,\n                          integer = true)\nd","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"with the exception that the non-anonymous definition registers d as variable name that cannot be duplicated. For one more example let's define a vector of variables a in mathbbR_+^3 with starting values of 0:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, a[1:3] >= 0, start = 0)\n3-element Array{HoldVariableRef,1}:\n a[1]\n a[2]\n a[3]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, highlighting how keyword arguments can still be used.","category":"page"},{"location":"guide/variable/#Infinite-Variables-2","page":"Variables","title":"Infinite Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Infinite variables entail decision variables that depend on infinite parameter(s). Thus, @infinite_variable follows the general definition methodology with this additional consideration.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Let's first consider a basic anonymous definition of an infinite variable y(t x):","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> y = @infinite_variable(model, parameter_refs = (t, x), base_name = \"y\")\ny(t, x)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we created an infinite variable with the base name y that depends on t and x. Notice that each group of parameters are specified in a particular element of the parameter_refs tuple, this is the required format. Moreover, the keyword argument parameter_refs is required to specify what parameterizes the infinite variable. Because we used an anonymous call, we can still make another variable with the same name. For example let's define another infinite variable also called y that only depends on t:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> y2 = @infinite_variable(model, parameter_refs = (t), base_name = \"y\")\ny(t)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"More conveniently, we can equivalently define y(t x) symbolically:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, y(t, x))\ny(t, x)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"We can also use this symbolic syntax to add constraint information as described in the previous section. For example, let's define a vector of infinite variables z(t) in 0 1 2^3:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @infinite_variable(model, 0 <= z[1:3](t) <= 2, Int)\n3-element Array{InfiniteVariableRef,1}:\n z[1](t)\n z[2](t)\n z[3](t)","category":"page"},{"location":"guide/variable/#Point-Variables-2","page":"Variables","title":"Point Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Point variables denote infinite variables evaluated at a particular point in the infinite decision space (i.e., particular infinite parameter values). These are commonly employed when using initial and terminal conditions, and to build discrete characterizations of complex operators such as derivatives. The @point_variable macro is employed to define such variables. Principally, it follows the general variable definition paradigm, but allows us to specify the infinite variable it refers to and the parameter values it is evaluated at. Also, note that by default it inherits the characteristics of the infinite variable (e.g., bounds), but these are overwritten as specified in the point variable macro.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"To begin let's consider defining a boundary point y(0 -1) based on the infinite variable y(t x) and enforce that it be nonnegative. Note that -1 need be a 3 element vector in this case to match the dimensions of x. The anonymous syntax would be:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> y0 = @point_variable(model, infinite_variable_ref = y,\n                            parameter_values = (0, [-1, -1, -1]), lower_bound = 0)\ny(0, [-1, -1, -1])","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"This creates a point variable y(0, [-1, -1, -1]) ≥ 0 that is added to model and assigns to the associated PointVariableRef to the Julia variable y0. Equivalently, this can accomplished much more conveniently via:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @point_variable(model, y(0, [-1, -1, -1]), y0 >= 0)\ny0","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here the 2nd argument specifies the infinite variable and parameter values, and the next argument is used to provide a convenient alias that can be used in combination with the typical symbolic variable syntax described in the previous sections. Let's also demonstrate how this works for multi-dimensional infinite variables. For example consider defining z(0) = 0 for z(t) in 0 1 2^3:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @point_variable(model, z[i](0), z0[i = 1:3] == 0)\n3-element Array{PointVariableRef,1}:\n z0[1]\n z0[2]\n z0[3]","category":"page"},{"location":"guide/variable/#Hold-Variables-2","page":"Variables","title":"Hold Variables","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Hold variables denote decision variables that are constant (agnostic) over the infinite domain or some sub-domain of it. This is accomplished via the @hold_variable macro as demonstrated in the General Usage section. By default and as shown in the above examples, hold variables are valid over the entire infinite domain. However, this scope can be limited via the parameter_bounds keyword argument.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"For example, let's define a hold variable b in 0 1 that is valid over the entire infinite domain (any infinite parameter value):","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, b, Bin)\nb","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Again, this follows the methodology outlined above. Now let's suppose we want to define a hold variable 0 leq c leq 42 that is only valid over the time interval t in 0 5 which is a subset of the entire range being considered. This can be accomplished via parameter_bounds:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, 0 <= c <= 42, parameter_bounds = (t in [0, 5]))\nc","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, we defined c and it can only be used in constraints and measures in accordance with this limited sub-domain. When such a limited hold variable is used in a constraint, the constraint parameter bounds be overlapped with those of c if possible. Otherwise, an error will be thrown. This is further explained on the Constraints page.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Any number of parameters can be specified in a hold variable's sub-domain. For example, let's define e such over the domain t in 0 1, x = -1:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @hold_variable(model, e, parameter_bounds = (t in [0, 1], x == -1))\ne","category":"page"},{"location":"guide/variable/#Queries-1","page":"Variables","title":"Queries","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"InfiniteOpt contains a large suite of methods to query information about variables. This suite is comprised of extensions to all current JuMP query methods and many more that are specific to InfiniteOpt. A number of the more commonly used ones are explained in this section, but all of the available methods are explained in the Methods/Macros section (i.e., the manual) below.","category":"page"},{"location":"guide/variable/#General-Information-1","page":"Variables","title":"General Information","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Here we describe some methods used to query general variable information such as the name. Variable names can be extracted via name which returns the name of a variable. The index of a variable (where it is stored in the infinite model) is accessed via index and the infinite model it belongs to is given by owner_model. These methods are demonstrated below:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> name(y)\n\"y(t, x)\"\n\njulia> index(y)\n33\n\njulia> model_where_stored = owner_model(y);","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Also, num_variables is useful in returning the total number variables currently stored in an infinite model:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> num_variables(model)\n44","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Similarly, all_variables returns a list of all the variables currently added to the model.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Finally, variable_by_name can be employed to return the appropriate explicit type of GeneralVariableRef based off of the variable name if it is unique. Errors if such a name cannot be found or it is not unique. For example, we can request the reference associated with \"c\":","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> variable_by_name(model, \"c\")\nc","category":"page"},{"location":"guide/variable/#Variable-Constraint-Info-1","page":"Variables","title":"Variable Constraint Info","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"As described above, variables in InfiniteOpt can have constraints associated with them like JuMP variables. These constraints include:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"lower bounds\nupper bounds\nfixed values\nbinary specifications\ninteger specifications.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, a number of methods exist to query information about these constraints.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"First, the [has/is]_[variable constraint type] methods indicate whether or not a variable has that particular constraint type. For example, to query if a variable d has a lower bound we can use has_lower_bound:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> has_lower_bound(d)\ntrue","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, d does have a lower bound. The other methods are has_upper_bound, is_fixed, is_binary, and is_integer.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Next, the [ConstraintType]Ref methods return an appropriate explicit type GeneralConstraintRef that points to the constraint (errors if no such constraint exists). For example, the upper bound constraint of d can be obtained via UpperBoundRef:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> UpperBoundRef(d)\nd ≤ 3.0","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"The other methods are LowerBoundRef, FixRef, BinaryRef, and IntegerRef.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Finally, variable constraints that entail values (i.e., lower bounds, upper bounds, and fixed values) have their values queried via the appropriate method. For example, the lower bound value of d is obtained via lower_bound:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> lower_bound(d)\n0.0","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Note these methods error when no such constraint is associated with the variable. The other methods are upper_bound and fix_value.","category":"page"},{"location":"guide/variable/#Variable-Use-1","page":"Variables","title":"Variable Use","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"InfiniteOpt defines a number of methods to track if and how variables are used in an infinite model. For example, used_by_constraint is used to determine if a variable is used by a constraint. For example, let's see if c is used by a constraint:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> used_by_constraint(c)\ntrue","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Other methods include used_by_measure and used_by_objective. For infinite variables, used_by_point_variable can also be used in a similar manner.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Finally, in general is_used can be used to determine if a variable is used at all in the infinite model or not. For example, if we check e using is_used we find that it isn't:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> is_used(e)\nfalse","category":"page"},{"location":"guide/variable/#Type-Specific-1","page":"Variables","title":"Type Specific","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"InfiniteOpt also employs a few methods for specific variable types that return information pertaining to that particular variable type. For infinite variables, parameter_refs returns the tuple of infinite parameters that the variable depends on. For example, consider y(t, x):","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> parameter_refs(y)\n(t,   [3]  =  x[3]\n  [2]  =  x[2]\n  [1]  =  x[1])","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"For point variables, infinite_variable_ref and parameter_values return the infinite variable it depends on and the infinite parameter point values, respectively. For example, consider the point variable y0:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> infinite_variable_ref(y0)\ny(t, x)\n\njulia> parameter_values(y0)\n(0,   [3]  =  -1\n  [2]  =  -1\n  [1]  =  -1)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"For hold variables, has_parameter_bounds returns if a hold variable has parameter bounds (i.e., a specified sub-domain) and parameter_bounds returns those bounds if there are any. For example, consider c:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> has_parameter_bounds(c)\ntrue\n\njulia> parameter_bounds(c)\nSubdomain bounds (1): t ∈ [0, 5]","category":"page"},{"location":"guide/variable/#Modification-1","page":"Variables","title":"Modification","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"InfiniteOpt employs a wide variety of methods to modify/delete variables. These are comprised of JuMP extensions and methods native only to InfiniteOpt. This section will highlight some of the more commonly used ones. All of the methods/macros are detailed in the Methods/Macros section (i.e., the manual) below.","category":"page"},{"location":"guide/variable/#Deletion-1","page":"Variables","title":"Deletion","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Like JuMP v0.19+, InfiniteOpt fully supports deletion throughout its data types. Any variable and its dependencies can be deleted via delete. Thus, when delete is invoked any bound/type constraints associated with the variable will be removed and it will be removed from any other constraints, measures, and/or objectives. For example, if we delete y(t, x) it will be removed along with its bounds and the point variable y0 will also be removed since it is a dependent:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> delete(model, y)","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Another class of deletion methods correspond to variable constraints. For example, delete_lower_bound is used to delete a lower bound associated with a variable if it has one. Let's illustrate this by deleting the lower bound of d:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> delete_lower_bound(d)\n\njulia> has_lower_bound(d)\nfalse","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Other similar methods are delete_upper_bound, unfix, unset_binary, and unset_integer.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Finally, delete_parameter_bounds and delete_parameter_bound can be used on hold variables to delete all of their parameter bounds or a particular one. For example, let's delete all of the parameter bounds associated with c:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> parameter_bounds(c)\nSubdomain bounds (1): t ∈ [0, 5]\n\njulia> delete_parameter_bounds(c)\n\njulia> has_parameter_bounds(c)\nfalse","category":"page"},{"location":"guide/variable/#Variable-Constraints-1","page":"Variables","title":"Variable Constraints","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Another class of methods seek to add/modify variable constraints such as bounds. For example, set_lower_bound specifies the lower bound of a variable. We can add a lower bound of 0 to c by:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> set_lower_bound(c, 0)\n\njulia> lower_bound(c)\n0.0","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Thus, adding a lower bound to c. Furthermore, we can later modify the lower bound using the same method:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> set_lower_bound(c, -2)\n\njulia> lower_bound(c)\n-2.0","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Other similar methods are set_upper_bound, fix, set_binary, and set_integer.","category":"page"},{"location":"guide/variable/#Type-Specific-2","page":"Variables","title":"Type Specific","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Finally, we consider methods unique to InfiniteOpt that exist to modify specific variable types. For infinite variables, add_parameter_ref and set_parameter_refs are used to add an infinite parameter and overwrite the infinite parameters, respectively.","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"For hold variables, the parameter bounds can be modified via @add_parameter_bounds and @set_parameter_bounds which facilitate an intuitive symbolic syntax to add and/or overwrite existing parameter bounds for a hold variable. For example, let's add the bounds t in 0 5 and x = 0 to c:","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"julia> @add_parameter_bounds(c, (t in [0, 5], x == 0))","category":"page"},{"location":"guide/variable/#Datatypes-1","page":"Variables","title":"Datatypes","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Pages   = [\"variable.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"InfOptVariable\nInfiniteVariable\nPointVariable\nParameterBounds\nHoldVariable\nInfOptVariableRef\nGeneralVariableRef\nMeasureFiniteVariableRef\nFiniteVariableRef\nInfiniteVariableRef\nPointVariableRef\nHoldVariableRef","category":"page"},{"location":"guide/variable/#InfiniteOpt.InfOptVariable","page":"Variables","title":"InfiniteOpt.InfOptVariable","text":"InfOptVariable <: JuMP.AbstractVariable\n\nAn abstract type for infinite, point, and hold variables.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariable","page":"Variables","title":"InfiniteOpt.InfiniteVariable","text":"InfiniteVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing core infinite variable information. Note each element of the parameter reference tuple must contain either a single ParameterRef or an AbstractArray of ParameterRefs where each ParameterRef has the same group ID number.\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP variable information.\nparameter_refs::Tuple The infinite parameters(s) that parameterize the                         variable.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariable","page":"Variables","title":"InfiniteOpt.PointVariable","text":"PointVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing point variable information. Note that the elements parameter_values field must match the format of the parameter reference tuple defined in InfiniteVariable\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP Variable information.\ninfinite_variable_ref::InfiniteVariableRef The infinite variable associated                                              with the point variable.\nparameter_values::Tuple The infinite parameter values defining the point.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.ParameterBounds","page":"Variables","title":"InfiniteOpt.ParameterBounds","text":"ParameterBounds\n\nA DataType for storing intervaled bounds of parameters. This is used to define subdomains of HoldVariables and BoundedScalarConstraints.\n\nFields\n\nintervals::Dict{ParameterRef, IntervalSet} A dictionary of parameter intervals\n\nthat are tighter than those already associated those paraticular parameters.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.HoldVariable","page":"Variables","title":"InfiniteOpt.HoldVariable","text":"HoldVariable{S, T, U, V} <: InfOptVariable\n\nA DataType for storing hold variable information.\n\nFields\n\ninfo::JuMP.VariableInfo{S, T, U, V} JuMP variable information.\nparameter_bounds::ParameterBounds Valid parameter sub-domains\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfOptVariableRef","page":"Variables","title":"InfiniteOpt.InfOptVariableRef","text":"InfOptVariableRef\n\nA union type for infinite, point, and hold variable references.\n\n\n\n\n\n","category":"constant"},{"location":"guide/variable/#InfiniteOpt.GeneralVariableRef","page":"Variables","title":"InfiniteOpt.GeneralVariableRef","text":"GeneralVariableRef <: JuMP.AbstractVariableRef\n\nAn abstract type to for variable references used with infinite models.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.MeasureFiniteVariableRef","page":"Variables","title":"InfiniteOpt.MeasureFiniteVariableRef","text":"MeasureFiniteVariableRef <: GeneralVariableRef\n\nAn abstract type to define finite variable and measure references.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.FiniteVariableRef","page":"Variables","title":"InfiniteOpt.FiniteVariableRef","text":"FiniteVariableRef <: GeneralVariableRef\n\nAn abstract type to define new finite variable references.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.InfiniteVariableRef","page":"Variables","title":"InfiniteOpt.InfiniteVariableRef","text":"InfiniteVariableRef <: GeneralVariableRef\n\nA DataType for untranscripted infinite dimensional variable references (e.g., second stage variables, time dependent variables).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.PointVariableRef","page":"Variables","title":"InfiniteOpt.PointVariableRef","text":"PointVariableRef <: FiniteVariableRef\n\nA DataType for variables defined at a transcipted point (e.g., second stage variable at a particular scenario, dynamic variable at a discretized time point).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#InfiniteOpt.HoldVariableRef","page":"Variables","title":"InfiniteOpt.HoldVariableRef","text":"HoldVariableRef <: FiniteVariableRef\n\nA DataType for finite fixed variable references (e.g., first stage variables, steady-state variables).\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/variable/#var_methods-1","page":"Variables","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"Pages   = [\"variable.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/variable/#","page":"Variables","title":"Variables","text":"JuMP.build_variable(::Function, ::JuMP.VariableInfo, ::Symbol)\nJuMP.add_variable(::InfiniteModel, ::InfOptVariable, ::String)\n@infinite_variable\n@point_variable\n@hold_variable\nJuMP.owner_model(::GeneralVariableRef)\nJuMP.index(::GeneralVariableRef)\nused_by_constraint(::InfOptVariableRef)\nused_by_measure(::InfOptVariableRef)\nused_by_objective(::InfOptVariableRef)\nis_used(::InfOptVariableRef)\nused_by_point_variable(::InfiniteVariableRef)\nused_by_reduced_variable(::InfiniteVariableRef)\nis_used(::InfiniteVariableRef)\nJuMP.delete(::InfiniteModel, ::InfOptVariableRef)\nJuMP.is_valid(::InfiniteModel, ::InfOptVariableRef)\nJuMP.num_variables(::InfiniteModel)\nJuMP.has_lower_bound(::InfOptVariableRef)\nJuMP.lower_bound(::InfOptVariableRef)\nJuMP.set_lower_bound(::InfOptVariableRef, ::Number)\nJuMP.LowerBoundRef(::InfOptVariableRef)\nJuMP.delete_lower_bound(::InfOptVariableRef)\nJuMP.has_upper_bound(::InfOptVariableRef)\nJuMP.upper_bound(::InfOptVariableRef)\nJuMP.set_upper_bound(::InfOptVariableRef, ::Number)\nJuMP.UpperBoundRef(::InfOptVariableRef)\nJuMP.delete_upper_bound(::InfOptVariableRef)\nJuMP.is_fixed(::InfOptVariableRef)\nJuMP.fix_value(::InfOptVariableRef)\nJuMP.fix(::InfOptVariableRef, ::Number; ::Bool)\nJuMP.FixRef(::InfOptVariableRef)\nJuMP.unfix(::InfOptVariableRef)\nJuMP.start_value(::InfOptVariableRef)\nJuMP.set_start_value(::InfOptVariableRef, ::Number)\nJuMP.is_binary(::InfOptVariableRef)\nJuMP.set_binary(::InfOptVariableRef)\nJuMP.BinaryRef(::InfOptVariableRef)\nJuMP.unset_binary(::InfOptVariableRef)\nJuMP.is_integer(::InfOptVariableRef)\nJuMP.set_integer(::InfOptVariableRef)\nJuMP.IntegerRef(::InfOptVariableRef)\nJuMP.unset_integer(::InfOptVariableRef)\nJuMP.name(::InfOptVariableRef)\nJuMP.set_name(::InfiniteVariableRef, ::String)\nJuMP.set_name(::PointVariableRef, ::String)\nJuMP.set_name(::HoldVariableRef, ::String)\nparameter_refs(::InfiniteVariableRef)\nset_parameter_refs(::InfiniteVariableRef, ::Tuple)\nadd_parameter_ref(::InfiniteVariableRef,::Union{ParameterRef, AbstractArray{<:ParameterRef}})\n@set_parameter_bounds\n@add_parameter_bounds\nhas_parameter_bounds(::HoldVariableRef)\nparameter_bounds(::HoldVariableRef)\nset_parameter_bounds(::HoldVariableRef, ::ParameterBounds)\nadd_parameter_bound(::HoldVariableRef, ::ParameterRef, ::Number, ::Number)\ndelete_parameter_bound(::HoldVariableRef, ::ParameterRef)\ndelete_parameter_bounds(::HoldVariableRef)\ninfinite_variable_ref(::PointVariableRef)\nparameter_values(::PointVariableRef)\nJuMP.variable_by_name(::InfiniteModel, ::String)\nJuMP.all_variables(::InfiniteModel)","category":"page"},{"location":"guide/variable/#JuMP.build_variable-Tuple{Function,VariableInfo,Symbol}","page":"Variables","title":"JuMP.build_variable","text":"JuMP.build_variable(_error::Function, info::JuMP.VariableInfo,\n                    var_type::Symbol;\n                    [parameter_refs::Union{ParameterRef,\n                                          AbstractArray{<:ParameterRef},\n                                          Tuple, Nothing} = nothing,\n                    infinite_variable_ref::Union{InfiniteVariableRef,\n                                                 Nothing} = nothing,\n                    parameter_values::Union{Number, AbstractArray{<:Number},\n                                            Tuple, Nothing} = nothing,\n                    parameter_bounds::Union{Dict{ParameterRef, IntervalSet},\n                                            Nothing} = nothing])\n\nExtend the JuMP.build_variable function to accomodate InfiniteOpt variable types. Returns the appropriate variable Datatype (i.e., InfiniteVariable, PointVariable, and HoldVariable). Primarily this method is to be used internally by the appropriate constructor macros @infinite_variable, @point_variable, and @hold_variable. However, it can be called manually to build InfiniteOpt variables. Errors if an unneeded keyword argument is given or if the keywoard arguments are formatted incorrectly (e.g., parameter_refs contains repeated parameter references when an infinite variable is defined). Also errors if needed kewword arguments are negated.\n\nExamples\n\njulia> @infinite_parameter(m, 0 <= t <= 1)\nt\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t)\nInfiniteVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}(false, 0, false, 0, false, 0, false, 0, false, false), (t,))\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5)\nPointVariable{Int64,Int64,Int64,Float64}(VariableInfo{Int64,Int64,Int64,Float64}(false, 0, false, 0, false, 0, true, 0.0, false, false), var_name(t), (0.5,))\n\njulia> hd_var = build_variable(error, info, Hold)\nHoldVariable{Int64,Int64,Int64,Int64}(VariableInfo{Int64,Int64,Int64,Int64}(false, 0, false, 0, false, 0, false, 0, false, false), Subdomain bounds (0): )\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.add_variable-Tuple{InfiniteModel,InfOptVariable,String}","page":"Variables","title":"JuMP.add_variable","text":"JuMP.add_variable(model::InfiniteModel, var::InfOptVariable, [name::String = \"\"])\n\nExtend the JuMP.add_variable function to accomodate InfiniteOpt variable types. Adds a variable to an infinite model model and returns an appropriate variable reference (i.e., InfiniteVariableRef, PointVariableRef, or HoldVariableRef). Primarily intended to be an internal function of the constructor macros @infinite_variable, @point_variable, and @hold_variable. However, it can be used in combination with JuMP.build_variable to add variables to an infinite model object. Errors if invalid parameters reference(s) or an invalid infinite variable reference is included in var.\n\nExamples\n\njulia> @infinite_parameter(m, t in [0, 10]);\n\njulia> info = VariableInfo(false, 0, false, 0, false, 0, false, 0, false, false);\n\njulia> inf_var = build_variable(error, info, Infinite, parameter_refs = t);\n\njulia> ivref = add_variable(m, inf_var, \"var_name\")\nvar_name(t)\n\njulia> pt_var = build_variable(error, info, Point, infinite_variable_ref = ivref,\n                               parameter_values = 0.5);\n\njulia> pvref = add_variable(m, pt_var, \"var_alias\")\nvar_alias\n\njulia> hd_var = build_variable(error, info, Hold);\n\njulia> hvref = add_variable(m, hd_var, \"var_name\")\nvar_name\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.@infinite_variable","page":"Variables","title":"InfiniteOpt.@infinite_variable","text":"@infinte_variable(model, kw_args...)\n\nAdd an anonymous infinite variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the parameter_refs keyword is required in this case.\n\n@infinite_variable(model, varexpr, args..., kw_args...)\n\nAdd an infinite variable to model described by the expression var_expr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname(params...) creating a scalar real variable of name varname with infinite parameters params... see parameter_refs for format.\nvarname[...] or [...] creating a container of variables.\nvarname[...](params...) or [...] creating a container of variables with infinite parameters params... in the first case.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\nparameter_refs: This is mandatory if not specified in varexpr. Can be a single parameter reference, a single parameter array with parameters defined in the same call of @infinite_parameter (i.e., have same group ID), or a tuple where each element is either of the first two options listed.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. Furthermore, the parameter reference tuple is appended on the end of the name i.e., base_name(params...) or base_name[...](params...).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{ParameterRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> x = @infinite_variable(model, parameter_refs = (t, w), base_name = \"x\",\n                              lower_bound = 0)\nx(t, w)\n\njulia> lb = [0, 1]; ub = [10, 12];\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{InfiniteVariableRef,1}:\n y[1](t)\n y[2](t)\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@point_variable","page":"Variables","title":"InfiniteOpt.@point_variable","text":"@point_variable(model, kw_args...)\n\nAdd an anonymous point variable to the model model described by the keyword arguments kw_args and returns the variable reference. Note that the infinite_variable_ref and parameter_values keywords are required in this case.\n\n@point_variable(model, infvarexpr, varexpr, args..., kw_args...)\n\nAdd a point variable to model described by the expression varexpr, the positional arguments args, and the keyword arguments kw_args and the infinite variable expr infvarexpr. The expression infvarexpr specifies the infinite variable this point variable corresponds to and the values at which the parameters are evaluated and must be of the form: infvar(param_values...) where the parameter values param_values... are listed in the same format as they are in teh definition of infvar. The expression varexpr is used to define variable specific bounds and whose name is used as an alias for the point variable which is simply the infinite variable evaluated at the values indicated. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nNote that be default a point variable inherits all of the same properties as  the infinite variable it corresponds to, but that these can be overwritten  by specifying properties such as lower bounds, fix values, etc.\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of alias name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nThe recognized keyword arguments in kw_args are the following:\n\ninfinite_variable_ref: Sets the infinite variable reference that the point variable is associated with.\nparameter_refs: Sets the values of the infinite parameters of the infinite variable at which this poitn variable is evaluated at. Must be of the same format of that specified for the parameters in the definition of the infinite variable.\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes. This serves as the alias for infvarexpr (the infinite variable evaluated at particular parameter values).\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @infinite_parameter(model, 0 <= t <= 1)\nt\n\njulia> @infinite_parameter(model, w[1:2] in Normal())\n2-element Array{ParameterRef,1}:\n w[1]\n w[2]\n\njulia> @infinite_variable(model, x(t, w) >= 0)\nx(t, w)\n\njulia> @point_variable(model, x(0, [0, 0]), x0 <= 1)\nx0\n\njulia> x0 = @point_variable(model, x(0, [0, 0]), upper_bound = 1, base_name = \"x0\")\nx0\n\njulia> x0 = @point_variable(model, upper_bound = 1, base_name = \"x0\",\n                            infinite_variable_ref = x, parameter_values = (0, [0, 0]))\nx0\n\njulia> @point_variable(model, x([0, 1][i], [0, 0]), xf[i = 1:2])\n2-element Array{PointVariableRef,1}:\n xf[1]\n xf[2]\n\njulia> lb = [0, 1]; ub = [10, 12];\n\njulia> @infinite_variable(model, lb[i] <= y[i = 1:2](t) <= ub[i], Int)\n2-element Array{InfiniteVariableRef,1}:\ny[1](t)\ny[2](t)\n\njulia> @point_variable(model, y[i](0), y0[i = 1:2], Bin)\n2-element Array{PointVariableRef,1}:\n y0[1]\n y0[2]\n\njulia> y0 = @point_variable(model, [i = 1:2], binary = true, base_name = \"y0\",\n                             infinite_variable_ref = y[i], parameter_values = 0)\n2-element Array{PointVariableRef,1}:\n y0[1]\n y0[2]\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@hold_variable","page":"Variables","title":"InfiniteOpt.@hold_variable","text":"@hold_variable(model, kw_args...)\n\nAdd an anonymous hold variable to the model model described by the keyword arguments kw_args and returns the variable reference.\n\n@hold_variable(model, varexpr, args..., kw_args...)\n\nAdd a hold variable to model described by the expression varexpr, the positional arguments args and the keyword arguments kw_args. The expression varexpr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥) of the form:\n\nvarexpr creating variables described by varexpr\nvarexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb)\nvarexpr == value creating variables described by varexpr with fixed values  given by value\nlb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub\n\nThe expression varexpr can be of the form:\n\nvarname creating a scalar real variable of name varname\nvarname[...] or [...] creating a container of variables.\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\n\nSpecifiying a hold variable which applies only to sub-domain of the model's infinite parameter(s) domain can be done via the parameter_bounds keyword argument. It is specified as a tuple of parameter bound expressions which can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nThe other recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\ncontainer: Specify the container type.\n\nExamples\n\njulia> @hold_variable(model, x)\nx\n\njulia> @hold_variable(model, 0 <= y <= 4, Bin)\ny\n\njulia> y = @hold_variable(model, lower_bound = 0, upper_bound = 4,\n                            binary = true, base_name = \"y\")\ny\n\njulia> @hold_variable(model, z[2:3] == 0)\n1-dimensional DenseAxisArray{HoldVariableRef,1,...} with index sets:\n    Dimension 1, 2:3\nAnd data, a 2-element Array{HoldVariableRef,1}:\n z[2]\n z[3]\n\njulia> @hold_variable(model, d, parameter_bounds = (t in [0, 5]))\nd\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#JuMP.owner_model-Tuple{GeneralVariableRef}","page":"Variables","title":"JuMP.owner_model","text":"JuMP.owner_model(vref::GeneralVariableRef)::InfiniteModel\n\nExtend JuMP.owner_model function for InfiniteOpt variables. Returns the infinite model associated with vref.\n\nExample\n\njulia> owner_model(vref)\nAn InfiniteOpt Model\nFeasibility problem with:\nVariable: 1\n`HoldVariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 1 constraint\n`HoldVariableRef`-in-`MathOptInterface.LessThan{Float64}`: 1 constraint\nNames registered in the model: vref\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.index-Tuple{GeneralVariableRef}","page":"Variables","title":"JuMP.index","text":"JuMP.index(v::GeneralVariableRef)::Int\n\nExtent JuMP.index to return the index of a InfiniteOpt variable.\n\nExample\n\njulia> index(vref)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_constraint-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_measure-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_objective-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by the objective.\n\nExample\n\njulia> used_by_objective(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.is_used-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::InfOptVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_point_variable-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_point_variable","text":"used_by_point_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a point variable.\n\nExample\n\njulia> used_by_point_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.used_by_reduced_variable-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.used_by_reduced_variable","text":"used_by_reduced_variable(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a reduced infinite variable.\n\nExample\n\njulia> used_by_reduced_variable(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.is_used-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.is_used","text":"is_used(vref::InfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used in the model.\n\nExample\n\njulia> is_used(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete-Tuple{InfiniteModel,Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::InfOptVariableRef)\n\nExtend JuMP.delete to delete InfiniteOpt variables and their dependencies. Errors if variable is invalid, meaning it has already been deleted or it belongs to another model.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z ≥ 0.0\n g(t) + z ≥ 42.0\n g(0.5) = 0\n t ∈ [0, 6]\n\njulia> delete(model, g)\n\njulia> print(model)\nMin measure(t) + z\nSubject to\n z ≥ 0.0\n z ≥ 42.0\n t ∈ [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_valid-Tuple{InfiniteModel,Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_valid to accomodate InfiniteOpt variables.\n\nExample\n\njulia> is_valid(model, vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.num_variables-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.num_variables","text":"JuMP.num_variables(model::InfiniteModel)::Int\n\nExtend JuMP.num_variables to return the number of InfiniteOpt variables assigned to model.\n\nExample\n\njulia> num_variables(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.has_lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether an InfiniteOpt variable has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.lower_bound to return the lower bound of an InfiniteOpt variable. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.set_lower_bound","text":"JuMP.set_lower_bound(vref::InfOptVariableRef, lower::Number)\n\nExtend JuMP.set_lower_bound to specify the lower bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_lower_bound(vref, -1)\n\njulia> lower_bound(vref)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.LowerBoundRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of vref.\n\nExample\n\njulia> cref = LowerBoundRef(vref)\nvar ≥ 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete_lower_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete_lower_bound","text":"JuMP.delete_lower_bound(vref::InfOptVariableRef)\n\nExtend JuMP.delete_lower_bound to delete lower bound of vref. Errors if it doesn't have a lower bound.\n\nExample\n\njulia> delete_lower_bound(vref)\n\njulia> has_lower_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.has_upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether an InfiniteOpt variable has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of an InfiniteOpt variable. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.set_upper_bound","text":"JuMP.set_upper_bound(vref::InfOptVariableRef, upper::Number)\n\nExtend JuMP.set_upper_bound to specify the upper bound of an InfiniteOpt variable vref. Errors if vref is fixed.\n\nExample\n\njulia> set_upper_bound(vref, 1)\n\njulia> upper_bound(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.UpperBoundRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar ≤ 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.delete_upper_bound-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.delete_upper_bound","text":"JuMP.delete_upper_bound(vref::InfOptVariableRef)\n\nExtend JuMP.delete_upper_bound to delete the upper bound of vref. Errors if it doesn't have an upper bound.\n\nExample\n\njulia> delete_upper_bound(vref)\n\njulia> has_upper_bound(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_fixed-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether an InfiniteOpt variable is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.fix_value-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::InfOptVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of an InfiniteOpt variable. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.fix-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.fix","text":"JuMP.fix(vref::InfOptVariableRef, value::Number; force::Bool = false)\n\nExtend JuMP.fix to fix the value of an InfiniteOpt variable. Errors if variable has a lower and/or an upper bound(s) unless force = true.\n\nExamples\n\njulia> fix(vref, 3)\n\njulia> fix_value(vref)\n3.0\n\njulia> fix(vref2, 2, force = true)\n\njulia> fix_value(vref2)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.FixRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar = 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unfix-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unfix","text":"JuMP.unfix(vref::InfOptVariableRef)\n\nExtend JuMP.unfix to unfix vref. Errors if it is not fixed.\n\nExample\n\njulia> unfix(vref)\n\njulia> is_fixed(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.start_value-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.start_value","text":"JuMP.start_value(vref::InfOptVariableRef)::Union{Nothing, Float64}\n\nExtend JuMP.start_value to return starting value of InfiniteOpt variable if it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_start_value-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef},Number}","page":"Variables","title":"JuMP.set_start_value","text":"JuMP.set_start_value(vref::InfOptVariableRef, value::Number)\n\nExtend JuMP.set_start_value to specify the start value of InfiniteOpt variables.\n\nExample\n\njulia> set_start_value(vref, 1)\n\njulia> start_value(vref)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_binary-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether an InfiniteOpt variable is binary.\n\nExample\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_binary-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.set_binary","text":"JuMP.set_binary(vref::InfOptVariableRef)\n\nExtend JuMP.set_binary to specify an InfiniteOpt variable as a binary variable. Errors if vref is an integer variable.\n\nExample\n\njulia> set_binary(vref)\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.BinaryRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unset_binary-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unset_binary","text":"JuMP.unset_binary(vref::InfOptVariableRef)\n\nExtend JuMP.unset_binary to unset vref as a binary variable. Errors if it is not binary.\n\njulia> unset_binary(vref)\n\njulia> is_binary(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.is_integer-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::InfOptVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether an InfiniteOpt variable is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_integer-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.set_integer","text":"JuMP.set_integer(vref::InfOptVariableRef)\n\nExtend JuMP.set_integer to specify an InfiniteOpt variable as a integer variable. Errors if vref is an binary variable.\n\nExample\n\njulia> set_integery(vref)\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.IntegerRef-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::InfOptVariableRef)::GeneralConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.unset_integer-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.unset_integer","text":"JuMP.unset_integer(vref::InfOptVariableRef)\n\nExtend JuMP.unset_integer to unset vref as an integer variable. Errors if it is not an integer variable.\n\njulia> unset_integer(vref)\n\njulia> is_integer(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.name-Tuple{Union{HoldVariableRef, InfiniteVariableRef, PointVariableRef}}","page":"Variables","title":"JuMP.name","text":"JuMP.name(vref::InfOptVariableRef)::String\n\nExtend JuMP.name to return the names of InfiniteOpt variables.\n\nExample\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{InfiniteVariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::InfiniteVariableRef, root_name::String)\n\nExtend JuMP.set_name to set names of infinite variables. Adds on to root_name the ending (prefs...) where the parameter reference names are listed in the same format as input in the parameter reference tuple.\n\nExample\n\njulia> name(vref)\n\"vref(t)\"\n\njulia> set_name(vref, \"new_name\")\n\njulia> name(vref)\n\"new_name(t)\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{PointVariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::PointVariableRef, name::String)\n\nExtend JuMP.set_name to set the names of point variables.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> vref = @point_variable(model, T(0))\nT(0)\n\njulia> set_name(vref, \"new_name\")\n\njulia> name(vref)\n\"new_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.set_name-Tuple{HoldVariableRef,String}","page":"Variables","title":"JuMP.set_name","text":"JuMP.set_name(vref::HoldVariableRef, name::String)\n\nExtend JuMP.set_name to set names of hold variables.\n\nExample\n\njulia> set_name(vref, \"var_name\")\n\njulia> name(vref)\n\"var_name\"\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_refs-Tuple{InfiniteVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::InfiniteVariableRef)::Tuple\n\nReturn the ParameterRef(s) associated with the infinite variable vref. This is formatted as a Tuple of containing the parameter references as they inputted to define vref.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> parameter_refs(T)\n(t, )\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.set_parameter_refs-Tuple{InfiniteVariableRef,Tuple}","page":"Variables","title":"InfiniteOpt.set_parameter_refs","text":"set_parameter_refs(vref::InfiniteVariableRef, prefs::Tuple)\n\nSpecify a new parameter reference tuple prefs for the infinite variable vref. Note each element must contain a single parameter reference or an array of parameter references. Errors if a parameter is double specified or if an element contains parameters with different group IDs.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> @infinite_parameter(model, x[1:2] in [-1, 1])\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> set_parameter_refs(T, (t, x))\n\njulia> parameter_refs(T)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.add_parameter_ref-Tuple{InfiniteVariableRef,Union{ParameterRef, AbstractArray{#s1,N} where N where #s1<:ParameterRef}}","page":"Variables","title":"InfiniteOpt.add_parameter_ref","text":"add_parameter_ref(vref::InfiniteVariableRef,\n                  pref::Union{ParameterRef, AbstractArray{<:ParameterRef}})\n\nAdd additional parameter reference or group of parameter references to be associated with the infinite variable vref. Errors if the parameter references are already added to the variable or if the added parameters have different group IDs.\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> @infinite_parameter(model, x[1:2] in [-1, 1])\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> add_parameter_ref(T, x)\n\njulia> name(T)\nT(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.@set_parameter_bounds","page":"Variables","title":"InfiniteOpt.@set_parameter_bounds","text":"@set_parameter_bounds(ref, bound_expr; [force = false])\n\nSpecify new parameter bounds for a constraint reference or hold variable reference ref. These bounds correspond to bounding a constraint in an equivalent way to using @BDconstraint or to limiting the scope of a hold variable in an equivalent way to using the parameter_bounds keyword argument in @hold_variable. Here (bound_expr) can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nErrors if the constraint or variable corresponding to ref already has bounds. However, using force = true can be used ignore the current bounds and overwrite them with new ones. Also, note that bounds on dependent constraints of hold variables will be updated to account for changes in hold variable bounds.\n\nExamples\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_variable(model, x(t))\nx(t)\n\njulia> @hold_variable(model, y)\ny\n\njulia> @constraint(model, con, x + y == 0)\ncon : x(t) + y = 0.0\n\njulia> @set_parameter_bounds(y, t in [0, 5])\n\njulia> con\ncon : x(t) + y = 0.0, ∀ t ∈ [0, 5]\n\njulia> @set_parameter_bounds(con, t == 0, force = true)\n\njulia> con\ncon : x(t) + y = 0.0, ∀ t = 0\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.@add_parameter_bounds","page":"Variables","title":"InfiniteOpt.@add_parameter_bounds","text":"@add_parameter_bounds(ref, bound_expr)\n\nAdd new parameter bounds for a constraint reference or hold variable reference ref. These bounds correspond to bounding a constraint in an equivalent way to using @BDconstraint or to limiting the scope of a hold variable in an equivalent way to using the parameter_bounds keyword argument in @hold_variable. Here (bound_expr) can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nErrors if the new bounds cause irreconcilable differences with existing measures and constraints. For example, this occurs when adding hold variable bounds that are outside the domain of a bounded constraint that uses that hold variable. Also, note that bounds on dependent constraints of hold variables will be updated to account for changes in hold variable bounds.\n\nExamples\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @infinite_parameter(model, q in [-2, 2])\nq\n\njulia> @infinite_variable(model, x(t, q))\nx(t, q)\n\njulia> @hold_variable(model, y)\ny\n\njulia> @constraint(model, con, x + y == 0)\ncon : x(t, q) + y = 0.0\n\njulia> @add_parameter_bounds(y, t in [0, 5])\n\njulia> con\ncon : x(t, q) + y = 0.0, ∀ t ∈ [0, 5]\n\njulia> @add_parameter_bounds(con, q == 0)\n\njulia> con\ncon : x(t, q) + y = 0.0, ∀ t ∈ [0, 5], q = 0\n\n\n\n\n\n","category":"macro"},{"location":"guide/variable/#InfiniteOpt.has_parameter_bounds-Tuple{HoldVariableRef}","page":"Variables","title":"InfiniteOpt.has_parameter_bounds","text":"has_parameter_bounds(vref::HoldVariableRef)::Bool\n\nReturn a Bool indicating if vref is limited to a sub-domain as defined by parameter bound.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref, parameter_bounds = (t in [0, 2]))\nvref\n\njulia> has_parameter_bounds(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_bounds-Tuple{HoldVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_bounds","text":"parameter_bounds(vref::HoldVariableRef)::ParameterBounds\n\nReturn the ParameterBounds object associated with the hold variable vref. It contains a dictionary where each key is a ParameterRef which points to an IntervalSet that that defines a sub-domain for vref relative to that parameter reference.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref, parameter_bounds = (t in [0, 2]))\nvref\n\njulia> parameter_bounds(vref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.set_parameter_bounds-Tuple{HoldVariableRef,ParameterBounds}","page":"Variables","title":"InfiniteOpt.set_parameter_bounds","text":"set_parameter_bounds(vref::HoldVariableRef, bounds::ParameterBounds;\n                     [force = false])\n\nSpecify a new dictionary of parameter bounds bounds for the hold variable vref. These are stored in a ParameterBounds object which contains a dictionary. Note the dictionary keys must be ParameterRefs and the values must be IntervalSets that indicate a particular sub-domain for which vref is defined. This is meant to be primarily used by @set_parameter_bounds which provides a more intuitive syntax.\n\nExample\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref)\nvref\n\njulia> set_parameter_bounds(vref, ParameterBounds(Dict(t => IntervalSet(0, 2))))\n\njulia> parameter_bounds(vref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.add_parameter_bound-Tuple{HoldVariableRef,ParameterRef,Number,Number}","page":"Variables","title":"InfiniteOpt.add_parameter_bound","text":"add_parameter_bound(vref::HoldVariableRef, pref::ParameterRef,\n                    lower::Number, upper::Number)\n\nAdd an additional parameter bound to vref such that it is defined over the sub-domain based on pref from lower to upper. This is primarily meant to be used by @add_parameter_bounds.\n\njulia> @infinite_parameter(model, t in [0, 10])\nt\n\njulia> @hold_variable(model, vref)\nvref\n\njulia> add_parameter_bound(vref, t, 0, 2)\n\njulia> parameter_bounds(vref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.delete_parameter_bound-Tuple{HoldVariableRef,ParameterRef}","page":"Variables","title":"InfiniteOpt.delete_parameter_bound","text":"delete_parameter_bound(vref::HoldVariableRef, pref::ParameterRef)\n\nDelete the parameter bound of the hold variable vref associated with the infinite parameter pref if vref has such a bound. Note that any other parameter bounds will be unaffected. Any constraints that employ vref will be updated accordingly.\n\nExample\n\njulia> @infinite_parameter(model, x[1:2] in [0, 10])\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> @hold_variable(model, z, parameter_bounds = (x in [0, 1]))\nz\n\njulia> delete_parameter_bound(z, x[2])\n\njulia> parameter_bounds(z)\nSubdomain bounds (1): x[1] ∈ [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.delete_parameter_bounds-Tuple{HoldVariableRef}","page":"Variables","title":"InfiniteOpt.delete_parameter_bounds","text":"delete_parameter_bounds(vref::HoldVariableRef)\n\nDelete all the parameter bounds of the hold variable vref. Any constraints that employ vref will be updated accordingly.\n\nExample\n\njulia> @infinite_parameter(model, x[1:2] in [0, 10])\n2-element Array{ParameterRef,1}:\n x[1]\n x[2]\n\njulia> @hold_variable(model, z, parameter_bounds = (x in [0, 1]))\nz\n\njulia> delete_parameter_bounds(z)\n\njulia> parameter_bounds(z)\nSubdomain bounds (0):\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.infinite_variable_ref-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::PointVariableRef)::InfiniteVariableRef\n\nReturn the InfiniteVariableRef associated with the point variable vref.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> vref = @point_variable(model, T(0))\nT(0)\n\njulia> infinite_variable_ref(vref)\nT(t)\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#InfiniteOpt.parameter_values-Tuple{PointVariableRef}","page":"Variables","title":"InfiniteOpt.parameter_values","text":"parameter_values(vref::PointVariableRef)::Tuple\n\nReturn the support point associated with the point variable vref.\n\nExample\n\njulia> @infinite_variable(model, T(t))\nT(t)\n\njulia> vref = @point_variable(model, T(0))\nT(0)\n\njulia> parameter_values(vref)\n(0, )\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.variable_by_name-Tuple{InfiniteModel,String}","page":"Variables","title":"JuMP.variable_by_name","text":"JuMP.variable_by_name(model::InfiniteModel,\n                      name::String)::Union{GeneralVariableRef, Nothing}\n\nExtend JuMP.variable_by_name for InfiniteModel objects. Return the variable reference assoociated with a variable name. Errors if multiple variables have the same name. Returns nothing if no such name exists.\n\nExamples\n\njulia> variable_by_name(m, \"var_name\")\nvar_name\n\njulia> variable_by_name(m, \"fake_name\")\n\n\n\n\n\n\n","category":"method"},{"location":"guide/variable/#JuMP.all_variables-Tuple{InfiniteModel}","page":"Variables","title":"JuMP.all_variables","text":"JuMP.all_variables(model::InfiniteModel)::Vector{GeneralVariableRef}\n\nExtend JuMP.all_variables to return a list of all the variable references associated with model.\n\nExamples\n\njulia> all_variables(model)\n4-element Array{GeneralVariableRef,1}:\n y(t)\n w(t, x)\n y(0)\n z\n\n\n\n\n\n","category":"method"},{"location":"guide/expression/#Expressions-1","page":"Expressions","title":"Expressions","text":"","category":"section"},{"location":"guide/expression/#","page":"Expressions","title":"Expressions","text":"A guide and manual for the defining and understanding the variable expressions used in InfiniteOpt.","category":"page"},{"location":"guide/expression/#Overview-1","page":"Expressions","title":"Overview","text":"","category":"section"},{"location":"guide/expression/#Datatype-Hierarchy-1","page":"Expressions","title":"Datatype Hierarchy","text":"","category":"section"},{"location":"guide/expression/#Affine-Expressions-1","page":"Expressions","title":"Affine Expressions","text":"","category":"section"},{"location":"guide/expression/#Quadratic-Expressions-1","page":"Expressions","title":"Quadratic Expressions","text":"","category":"section"},{"location":"guide/expression/#Nonlinear-Expressions-1","page":"Expressions","title":"Nonlinear Expressions","text":"","category":"section"},{"location":"guide/measure/#Measures-1","page":"Measures","title":"Measures","text":"","category":"section"},{"location":"guide/measure/#","page":"Measures","title":"Measures","text":"A guide and manual for defining and using measures in InfiniteOpt.","category":"page"},{"location":"guide/measure/#Overview-1","page":"Measures","title":"Overview","text":"","category":"section"},{"location":"guide/measure/#Basic-Usage-1","page":"Measures","title":"Basic Usage","text":"","category":"section"},{"location":"guide/measure/#Theoretical-Abstraction-1","page":"Measures","title":"Theoretical Abstraction","text":"","category":"section"},{"location":"guide/measure/#Preset-Evaluations-1","page":"Measures","title":"Preset Evaluations","text":"","category":"section"},{"location":"guide/measure/#Custom-Evaluations-1","page":"Measures","title":"Custom Evaluations","text":"","category":"section"},{"location":"guide/measure/#Expansion-1","page":"Measures","title":"Expansion","text":"","category":"section"},{"location":"guide/measure/#Reduced-Infinite-Variables-1","page":"Measures","title":"Reduced Infinite Variables","text":"","category":"section"},{"location":"guide/measure/#Datatypes-1","page":"Measures","title":"Datatypes","text":"","category":"section"},{"location":"guide/measure/#","page":"Measures","title":"Measures","text":"Pages   = [\"measure.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/measure/#","page":"Measures","title":"Measures","text":"AbstractMeasureData\nDiscreteMeasureData\nMultiDiscreteMeasureData\nMeasure\nMeasureRef\nAbstractReducedInfo\nReducedInfiniteInfo\nReducedInfiniteVariableRef","category":"page"},{"location":"guide/measure/#InfiniteOpt.AbstractMeasureData","page":"Measures","title":"InfiniteOpt.AbstractMeasureData","text":"AbstractMeasureData\n\nAn abstract type to define data for measures to define the behavior of Measure.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.DiscreteMeasureData","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData <: AbstractMeasureData\n\nA DataType for one dimensional measure abstraction data where the measure abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i).\n\nFields\n\nparameter_ref::ParameterRef The infinite parameter over which the                               integration occurs.\ncoefficients::Vector{<:Number} Coefficients alpha_i for the above                                  measure abstraction.\nsupports::Vector{<:Number} Support points tau_i for the above                              measure abstraction.\nname::String Name of the measure that will be implemented.\nweight_function::Function Weighting function w must map support value                             input value of type Number to a scalar value.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MultiDiscreteMeasureData","page":"Measures","title":"InfiniteOpt.MultiDiscreteMeasureData","text":"MultiDiscreteMeasureData <: AbstractMeasureData\n\nA DataType for multi-dimensional measure abstraction data where the measure abstraction is of the form: measure = int_tau in T f(tau) w(tau) dtau approx sum_i = 1^N alpha_i f(tau_i) w(tau_i).\n\nFields\n\nparameter_ref::JuMP.Containers.SparseAxisArray{<:ParameterRef} The infinite  parameters over which the integration occurs.\ncoefficients::Vector{<:Number} Coefficients alpha_i for the above                                  measure abstraction.\nsupports::Vector{<:JuMP.Containers.SparseAxisArray{<:Number}} Support points  tau_i for the above measure abstraction.\nname::String Name of the measure that will be implemented.\nweight_function::Function Weighting function w must map a numerical                             support of type JuMP.Containers.SparseAxisArray                             to a scalar value.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.Measure","page":"Measures","title":"InfiniteOpt.Measure","text":"Measure{T <: JuMP.AbstractJuMPScalar, V <: AbstractMeasureData}\n\nA DataType for measure abstractions.\n\nFields\n\nfunc::T Infinite variable expression.\ndata::V Data of the abstraction as described in a AbstractMeasureData           subtype.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.MeasureRef","page":"Measures","title":"InfiniteOpt.MeasureRef","text":"MeasureRef <: FiniteVariableRef\n\nA DataType for referring to measure abstractions.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.AbstractReducedInfo","page":"Measures","title":"InfiniteOpt.AbstractReducedInfo","text":"AbstractReducedInfo\n\nAn abstract type reduced variable information.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.ReducedInfiniteInfo","page":"Measures","title":"InfiniteOpt.ReducedInfiniteInfo","text":"ReducedInfiniteInfo <: AbstractReducedInfo\n\nA DataType for storing reduced infinite variable information.\n\nFields\n\ninfinite_variable_ref::InfiniteVariableRef The original infinite variable.\neval_supports::Dict{Int, Union{Number, JuMP.Containers.SparseAxisArray{<:Number}}} The original parameter tuple indices to the evaluation supports.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#InfiniteOpt.ReducedInfiniteVariableRef","page":"Measures","title":"InfiniteOpt.ReducedInfiniteVariableRef","text":"ReducedInfiniteVariableRef <: GeneralVariableRef\n\nA DataType for partially transcripted infinite dimensional variable references. This is used to expand measures that contain infinite variables that are not fully transcripted by the measure.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of variable in model.\n\n\n\n\n\n","category":"type"},{"location":"guide/measure/#Methods-1","page":"Measures","title":"Methods","text":"","category":"section"},{"location":"guide/measure/#","page":"Measures","title":"Measures","text":"Pages   = [\"measure.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:function]","category":"page"},{"location":"guide/measure/#","page":"Measures","title":"Measures","text":"DiscreteMeasureData(::ParameterRef, ::Vector{<:Number}, ::Vector{<:Number})\nDiscreteMeasureData(::AbstractArray{<:ParameterRef}, ::Vector{<:Number}, ::Vector{<:AbstractArray})\nmeasure\nadd_measure\nmeasure_function\nmeasure_data\nused_by_constraint(::MeasureRef)\nused_by_measure(::MeasureRef)\nused_by_objective(::MeasureRef)\nis_used(::MeasureRef)\nJuMP.is_valid(::InfiniteModel, ::MeasureRef)\nJuMP.delete(::InfiniteModel, ::MeasureRef)\nJuMP.name(::MeasureRef)\nJuMP.set_name(::MeasureRef, ::String)\nexpand\nexpand_all_measures!\ninfinite_variable_ref(::ReducedInfiniteVariableRef)\neval_supports(::ReducedInfiniteVariableRef)\nparameter_refs(::ReducedInfiniteVariableRef)\nJuMP.name(::ReducedInfiniteVariableRef)\nJuMP.has_lower_bound(::ReducedInfiniteVariableRef)\nJuMP.lower_bound(::ReducedInfiniteVariableRef)\nJuMP.LowerBoundRef(::ReducedInfiniteVariableRef)\nJuMP.has_upper_bound(::ReducedInfiniteVariableRef)\nJuMP.upper_bound(::ReducedInfiniteVariableRef)\nJuMP.UpperBoundRef(::ReducedInfiniteVariableRef)\nJuMP.is_fixed(::ReducedInfiniteVariableRef)\nJuMP.fix_value(::ReducedInfiniteVariableRef)\nJuMP.FixRef(::ReducedInfiniteVariableRef)\nJuMP.start_value(::ReducedInfiniteVariableRef)\nJuMP.is_binary(::ReducedInfiniteVariableRef)\nJuMP.BinaryRef(::ReducedInfiniteVariableRef)\nJuMP.is_integer(::ReducedInfiniteVariableRef)\nJuMP.IntegerRef(::ReducedInfiniteVariableRef)\nused_by_constraint(::ReducedInfiniteVariableRef)\nused_by_measure(::ReducedInfiniteVariableRef)\nJuMP.is_valid(::InfiniteModel, ::ReducedInfiniteVariableRef)\nJuMP.delete(::InfiniteModel, ::ReducedInfiniteVariableRef)","category":"page"},{"location":"guide/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{ParameterRef,Array{#s2,1} where #s2<:Number,Array{#s1,1} where #s1<:Number}","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(parameter_ref::ParameterRef,\n                    coefficients::Vector{<:Number},\n                    supports::Vector{<:Number}; name::String = \"measure\",\n                    weight_function::Function = w(t) = 1)::DiscreteMeasureData\n\nReturns a DiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for a scalar (single) parameter. Note that name is used for printing purposes and a description of the other arguments is provided in the documentation for DiscreteMeasureData. Errors if supports are out bounds or an unequal number of supports and coefficients are given.\n\nExample\n\njulia> data = DiscreteMeasureData(pref, [0.5, 0.5], [1, 2], name = \"example\")\nDiscreteMeasureData(pref, [0.5, 0.5], [1, 2], \"example\", InfiniteOpt._w)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.DiscreteMeasureData-Tuple{AbstractArray{#s2,N} where N where #s2<:ParameterRef,Array{#s1,1} where #s1<:Number,Array{#s3,1} where #s3<:AbstractArray}","page":"Measures","title":"InfiniteOpt.DiscreteMeasureData","text":"DiscreteMeasureData(parameter_ref::AbstractArray{<:ParameterRef},\n                    coefficients::Vector{<:Number},\n                    supports::Vector{<:AbstractArray{<:Number}};\n                    name::String = \"measure\",\n                    weight_function::Function = w(t) = 1\n                    )::MultiDiscreteMeasureData\n\nReturns a MultiDiscreteMeasureData object that can be utilized to define measures using measure. This accepts input for an array (multi) parameter. The inner arrays in the supports vector need to match the formatting of the array used for parameter_ref. Note that name is used for printing purposes and a description of the other arguments is provided in the documentation for MultiDiscreteMeasureData. Errors if supports are out bounds, an unequal number of supports and coefficients are given, the array formats do not match, or the parameters have different group IDs.\n\nExample\n\njulia> data = DiscreteMeasureData(prefs, [0.5, 0.5], [[1, 1], [2, 2]], name = \"example\");\n\njulia> typeof(data)\nMultiDiscreteMeasureData\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.measure","page":"Measures","title":"InfiniteOpt.measure","text":"measure(expr::JuMP.AbstractJuMPScalar, data::AbstractMeasureData)::MeasureRef\n\nReturn a measure reference that evaluates expr using according to data. This is the preferred method for implementing measures which follow the form: int_p in P expr(p) w(p) dp where p is an infinite parameter (scalar or vector) and w is the weight function. The measure data data determines how the measure is to be evaluated. Typically, the DiscreteMeasureData constructor can be used to for data. The variable expression expr can contain InfiniteOpt variables, infinite parameters, other measure references (meaning measures can be nested), and constants. Errors if expr does not contain infinite variables, infinite parameters, or measure references. Also errors if the measure parameter specified in data is not in expr and is not in any the nested measure references. Typically, this is called inside of JuMP.@expression, JuMP.@objective, and JuMP.@constraint in a manner similar to sum. Note measures are not explicitly evaluated until build_optimizer_model! is called or unless they are expanded via expand or expand_all_measures!.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [1, 2], name = \"name1\");\n\njulia> xdata = DiscreteMeasureData(xs, [0.5, 0.5], [[-1, -1], [1, 1]],\n                                   name = \"name2\");\n\njulia> constr_RHS = @expression(model, measure(g - s + 2, tdata) + s^2)\nname1(g(t) - s + 2) + s²\n\njulia> @objective(model, Min, measure(g - 1  + measure(T, xdata), tdata))\nname1(g(t) - 1 + name2(T(t, x)))\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.add_measure","page":"Measures","title":"InfiniteOpt.add_measure","text":"add_measure(model::InfiniteModel, meas::Measure)::MeasureRef\n\nAdd a measure to model and return the corresponding measure reference. This operates in a manner similar to JuMP.add_variable.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.measure_function","page":"Measures","title":"InfiniteOpt.measure_function","text":"measure_function(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn the function associated with mref.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.measure_data","page":"Measures","title":"InfiniteOpt.measure_data","text":"measure_data(mref::MeasureRef)::AbstractMeasureData\n\nReturn the measure data associated with mref.\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.used_by_constraint-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(mref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.used_by_measure-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by a measure.\n\nExample\n\njulia> used_by_measure(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.used_by_objective-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.used_by_objective","text":"used_by_objective(vmref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used by the objective.\n\nExample\n\njulia> used_by_objective(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.is_used-Tuple{MeasureRef}","page":"Measures","title":"InfiniteOpt.is_used","text":"is_used(mref::MeasureRef)::Bool\n\nReturn a Bool indicating if mref is used in the model.\n\nExample\n\njulia> is_used(mref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_valid-Tuple{InfiniteModel,MeasureRef}","page":"Measures","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, mref::MeasureRef)::Bool\n\nExtend JuMP.is_valid to return Bool whether mref is valid.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.delete-Tuple{InfiniteModel,MeasureRef}","page":"Measures","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, mref::MeasureRef)\n\nExtend JuMP.delete to delete measures. Errors if measure is invalid, meaning it does not belong to the model or it has already been deleted.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n measure(g(t)) == 0\n g(t) + z >= 42.0\n g(0.5) == 0\n t in [0, 6]\n\njulia> delete(model, meas)\n\njulia> print(model)\nMin z\nSubject to\n z >= 0.0\n 0 == 0\n g(t) + z >= 42.0\n g(0.5) == 0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.name-Tuple{MeasureRef}","page":"Measures","title":"JuMP.name","text":"JuMP.name(mref::MeasureRef)::String\n\nExtend JuMP.name to return the name associated with a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.set_name-Tuple{MeasureRef,String}","page":"Measures","title":"JuMP.set_name","text":"JuMP.set_name(mref::MeasureRef, name::String)\n\nExtend JuMP.set_name to specify the name of a measure reference.\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.expand","page":"Measures","title":"InfiniteOpt.expand","text":"expand(mref::MeasureRef)::JuMP.AbstractJuMPScalar\n\nReturn a JuMP scalar function containing the explicit expansion of the measure mref. This expansion is done according to the measure data. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. If desired this can be used in combination with measure to expand measures on the fly.\n\nThis is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before expressions are translated to the new model. This method can also be extended to handle custom measure data types by extending InfiniteOpt._expand_measure which should be of the form:\n\nInfiniteOpt._expand_measure(expr::AbstractJuMPScalar, data::AbstractMeasureData,\n                            model::InfiniteModel, point_mapper::Function)\n\nSee the source code in InfiniteOpt/src/measures.jl for examples of how to do this.\n\nExample\n\njulia> tdata = DiscreteMeasureData(t, [0.5, 0.5], [0, 1])\n\njulia> expr = expand(measure(g + z + T - h - 2, tdata))\n0.5 g(0) + 0.5 g(1) + z + 0.5 T(0, x) + 0.5 T(1, x) - h(x) - 2\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.expand_all_measures!","page":"Measures","title":"InfiniteOpt.expand_all_measures!","text":"expand_all_measures!(model::InfiniteModel)\n\nExpand all of the measures used in the objective and/or constraints of model. The objective and constraints are updated accordingly. Note that variables are added to the model as necessary to accomodate the expansion (i.e., point variables and reduced infinite variables are made as needed). Errors if expansion is undefined for the measure data and/or the measure expression. Also errors if the expanded objective function is not finite.\n\nThis is useful for extensions that employ a custom optimizer model since it can be used evaluate measures before model is translated into the new model. This method can also be extended to handle custom measure data types by extending InfiniteOpt._expand_measure which should be of the form:\n\nInfiniteOpt._expand_measure(expr::AbstractJuMPScalar, data::AbstractMeasureData,\n                            model::InfiniteModel, point_mapper::Function)\n\nSee the source code in InfiniteOpt/src/measures.jl for examples of how to do this.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n T(t, xi) >= 0.0\n z >= 0.0\n g(t) + z >= 42.0\n measure(T(t, xi)) >= 0.0, for all xi in [-1, 1]\n t in [0, 6]\n xi in Normal(μ=0.0, σ=1.0)\n\njulia> expand_all_measures!(model)\n\njulia> print(model)\nMin 3 g(6) + z\nSubject to\n T(t, xi) >= 0.0\n z >= 0.0\n g(t) + z >= 42.0\n 0.5 T(0, xi) + 0.5 T(6, xi) >= 0.0, for all xi in [-1, 1]\n t in [0, 6]\n xi in Normal(μ=0.0, σ=1.0)\n\n\n\n\n\n","category":"function"},{"location":"guide/measure/#InfiniteOpt.infinite_variable_ref-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"InfiniteOpt.infinite_variable_ref","text":"infinite_variable_ref(vref::ReducedInfiniteVariableRef)::InfiniteVariableRef\n\nReturn the InfiniteVariableRef associated with the reduced infinite variable vref.\n\nExample\n\njulia> infinite_variable_ref(vref)\ng(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.eval_supports-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"InfiniteOpt.eval_supports","text":"eval_supports(vref::ReducedInfiniteVariableRef)::Dict\n\nReturn the evaluation supports associated with the reduced infinite variable vref.\n\nExample\n\njulia> eval_supports(vref)\nDict{Int64,Float64} with 1 entry:\n  1 => 0.5\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.parameter_refs-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"InfiniteOpt.parameter_refs","text":"parameter_refs(vref::ReducedInfiniteVariableRef)::Tuple\n\nReturn the ParameterRef(s) associated with the reduced infinite variable vref. This is formatted as a Tuple of containing the parameter references as they were inputted to define the untracripted infinite variable except, the evaluated parameters are excluded.\n\nExample\n\njulia> parameter_refs(vref)\n(t,   [2]  =  x[2]\n  [1]  =  x[1])\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.name-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.name","text":"JuMP.name(vref::ReducedInfiniteVariableRef)::String\n\nExtend JuMP.name to return name of reduced infinite variable references. This is used when displaying measure expansions that contain such variables.\n\nExanple\n\njulia> name(rvref)\ng(1.25, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.has_lower_bound-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.has_lower_bound","text":"JuMP.has_lower_bound(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.has_lower_bound to return a Bool whether the original infinite variable of vref has a lower bound.\n\nExample\n\njulia> has_lower_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.lower_bound-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.lower_bound","text":"JuMP.lower_bound(vref::ReducedInfiniteVariableRef)::Float64\n\nExtend JuMP.lower_bound to return the lower bound of the original infinite variable of vref. Errors if vref doesn't have a lower bound.\n\nExample\n\njulia> lower_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.LowerBoundRef-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.LowerBoundRef","text":"JuMP.LowerBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.LowerBoundRef to extract a constraint reference for the lower bound of the original infinite variable of vref.\n\nExample\n\njulia> cref = LowerBoundRef(vref)\nvar >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.has_upper_bound-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.has_upper_bound","text":"JuMP.has_upper_bound(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.has_upper_bound to return a Bool whether the original infinite variable of vref has an upper bound.\n\nExample\n\njulia> has_upper_bound(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.upper_bound-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.upper_bound","text":"JuMP.upper_bound(vref::ReducedInfiniteVariableRef)::Float64\n\nExtend JuMP.upper_bound to return the upper bound of the original infinite variable of vref. Errors if vref doesn't have a upper bound.\n\nExample\n\njulia> upper_bound(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.UpperBoundRef-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.UpperBoundRef","text":"JuMP.UpperBoundRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.UpperBoundRef to extract a constraint reference for the upper bound of the original infinite variable of vref.\n\nExample\n\njulia> cref = UpperBoundRef(vref)\nvar <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_fixed-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.is_fixed","text":"JuMP.is_fixed(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_fixed to return Bool whether the original infinite variable of vref is fixed.\n\nExample\n\njulia> is_fixed(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.fix_value-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.fix_value","text":"JuMP.fix_value(vref::ReducedInfiniteVariableRef)::Float64\n\nExtend JuMP.fix_value to return the fix value of the original infinite variable of vref. Errors if variable is not fixed.\n\nExample\n\njulia> fix_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.FixRef-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.FixRef","text":"JuMP.FixRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.FixRef to return the constraint reference of the fix constraint associated with the original infinite variable of vref. Errors vref is not fixed.\n\nExamples\n\njulia> cref = FixRef(vref)\nvar == 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.start_value-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.start_value","text":"JuMP.start_value(vref::ReducedInfiniteVariableRef)::Union{Nothing, Float64}\n\nExtend JuMP.start_value to return starting value of the original infinite variable of vref if it has one. Returns nothing otherwise.\n\nExample\n\njulia> start_value(vref)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_binary-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.is_binary","text":"JuMP.is_binary(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_binary to return Bool whether the original infinite variable of vref is binary.\n\nExample\n\njulia> is_binary(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.BinaryRef-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.BinaryRef","text":"JuMP.BinaryRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.BinaryRef to return a constraint reference to the constraint constrainting the original infinite variable of vref to be binary. Errors if one does not exist.\n\nExample\n\njulia> cref = BinaryRef(vref)\nvar binary\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_integer-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.is_integer","text":"JuMP.is_integer(vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_integer to return Bool whether the original infinite variable of vref is integer.\n\nExample\n\njulia> is_integer(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.IntegerRef-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.IntegerRef","text":"JuMP.IntegerRef(vref::ReducedInfiniteVariableRef)::GeneralConstraintRef\n\nExtend JuMP.IntegerRef to return a constraint reference to the constraint constrainting the original infinite variable of vref to be integer. Errors if one does not exist.\n\nExample\n\njulia> cref = IntegerRef(vref)\nvar integer\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.used_by_constraint-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"InfiniteOpt.used_by_constraint","text":"used_by_constraint(vref::ReducedInfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a constraint.\n\nExample\n\njulia> used_by_constraint(vref)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#InfiniteOpt.used_by_measure-Tuple{ReducedInfiniteVariableRef}","page":"Measures","title":"InfiniteOpt.used_by_measure","text":"used_by_measure(vref::ReducedInfiniteVariableRef)::Bool\n\nReturn a Bool indicating if vref is used by a measure.\n\nExample\n\njulia> used_by_measure(vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.is_valid-Tuple{InfiniteModel,ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, vref::ReducedInfiniteVariableRef)::Bool\n\nExtend JuMP.is_valid to accomodate reduced infinite variables.\n\nExample\n\njulia> is_valid(model, vref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/measure/#JuMP.delete-Tuple{InfiniteModel,ReducedInfiniteVariableRef}","page":"Measures","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, vref::ReducedInfiniteVariableRef)\n\nExtend JuMP.delete to delete reduced infinite variables and its dependencies. Errors if vref is invalid, meaning it has already been deleted or it belongs to another model.\n\nExample\n\njulia> print(model)\nMin measure(g(0, t)*t + g(1, t)*t) + z\nSubject to\n z >= 0.0\n g(0, t) + g(1, t) == 0\n g(x, t) + z >= 42.0\n g(0.5, 0.5) == 0\n t in [0, 6]\n x in [0, 1]\n\njulia> delete(model, rvref1)\n\njulia> print(model)\nMin measure(t + g(1, t)*t) + z\nSubject to\n z >= 0.0\n g(1, t) == 0\n g(x, t) + z >= 42.0\n g(0.5, 0.5) == 0\n t in [0, 6]\n x in [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#Objectives-1","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"guide/objective/#","page":"Objectives","title":"Objectives","text":"A guide and manual for specifying and modifying objective functions in InfiniteOpt.","category":"page"},{"location":"guide/objective/#Overview-1","page":"Objectives","title":"Overview","text":"","category":"section"},{"location":"guide/objective/#Basic-Usage-1","page":"Objectives","title":"Basic Usage","text":"","category":"section"},{"location":"guide/objective/#Queries-1","page":"Objectives","title":"Queries","text":"","category":"section"},{"location":"guide/objective/#Modification-1","page":"Objectives","title":"Modification","text":"","category":"section"},{"location":"guide/objective/#Methods-1","page":"Objectives","title":"Methods","text":"","category":"section"},{"location":"guide/objective/#","page":"Objectives","title":"Objectives","text":"Pages   = [\"objective.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/objective/#","page":"Objectives","title":"Objectives","text":"JuMP.set_objective_function(::InfiniteModel, ::JuMP.AbstractJuMPScalar)\nJuMP.set_objective_function(::InfiniteModel, ::Real)\nJuMP.set_objective_sense(::InfiniteModel, ::MOI.OptimizationSense)\nJuMP.set_objective(::InfiniteModel, ::MOI.OptimizationSense, ::Union{JuMP.AbstractJuMPScalar, Real})\nJuMP.objective_sense(::InfiniteModel)\nJuMP.objective_function_type(::InfiniteModel)\nJuMP.objective_function(::InfiniteModel)\nJuMP.set_objective_coefficient(::InfiniteModel, ::GeneralVariableRef, ::Real)","category":"page"},{"location":"guide/objective/#JuMP.set_objective_function-Tuple{InfiniteModel,AbstractJuMPScalar}","page":"Objectives","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel,\n                            func::JuMP.AbstractJuMPScalar)\n\nExtend JuMP.set_objective_function to set the objective expression of infinite model model. Errors if func contains infinite variables and/or parameters. Also errors if func contains invalid variables.\n\nExample\n\njulia> set_objective_function(model, x + measure(g + 2, tdata))\n\njulia> objective_function(model)\nx + measure(g(t) + 2)\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_function-Tuple{InfiniteModel,Real}","page":"Objectives","title":"JuMP.set_objective_function","text":"JuMP.set_objective_function(model::InfiniteModel, func::Real)\n\nExtend JuMP.set_objective_function to set the objective expression of model with a number.\n\nExample\n\njulia> set_objective_function(model, 3)\n\njulia> objective_function(model)\n3\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_sense-Tuple{InfiniteModel,MathOptInterface.OptimizationSense}","page":"Objectives","title":"JuMP.set_objective_sense","text":"JuMP.set_objective_sense(model::InfiniteModel, sense::MOI.OptimizationSense)\n\nExtend JuMP.set_objective_sense to set the objective sense of infinite model model.\n\nExample\n\njulia> set_objective_sense(model, MOI.MIN_SENSE)\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective-Tuple{InfiniteModel,MathOptInterface.OptimizationSense,Union{Real, AbstractJuMPScalar}}","page":"Objectives","title":"JuMP.set_objective","text":"JuMP.set_objective(model::InfiniteModel, sense::MOI.OptimizationSense,\n                   func::Union{JuMP.AbstractJuMPScalar, Real})\n\nExtend JuMP.set_objective to set the objective of infinite model model. Errors if func contains infinite variables and/or parameters, or if it does not belong to the model.\n\nExample\n\njulia> set_objective(model, MOI.MIN_SENSE, x + measure(g + 2, tdata))\n\njulia> objective_function(model)\nx + measure(g(t) + 2)\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.objective_sense-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_sense","text":"JuMP.objective_sense(model::InfiniteModel)::MOI.OptimizationSense\n\nExtend JuMP.objective_sense to return the objective sense of the infinite model model.\n\nExample\n\njulia> objective_sense(model)\nMIN_SENSE::OptimizationSense = 0\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.objective_function_type-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_function_type","text":"JuMP.objective_function_type(model::InfiniteModel)::Type{<:JuMP.AbstractJuMPScalar}\n\nExtend JuMP.objective_function_type to return the objective function type of infinite model model.\n\nExample\n\njulia> objective_function_type(model)\nGenericAffExpr{Float64, FiniteVariableRef}\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.objective_function-Tuple{InfiniteModel}","page":"Objectives","title":"JuMP.objective_function","text":"JuMP.objective_function(model::InfiniteModel)::JuMP.AbstractJuMPScalar\n\nExtend JuMP.objective_function to return the objective of infinite model model.\n\nExample\n\njulia> objective_function(model)\nx + measure(g(t))\n\n\n\n\n\n","category":"method"},{"location":"guide/objective/#JuMP.set_objective_coefficient-Tuple{InfiniteModel,GeneralVariableRef,Real}","page":"Objectives","title":"JuMP.set_objective_coefficient","text":"JuMP.set_objective_coefficient(model::InfiniteModel,\n                               variable::GeneralVariableRef,\n                               coefficient::Real)\n\nSet the linear objective coefficient associated with variable to coefficient. Errors if the function type is unsupported.\n\nExample\n\njulia> objective_function(model)\nx + y\n\njulia> set_objective_coefficient(model, y, 2)\n\njulia> objective_function(model)\nx + 2 y\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#Constraints-1","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"guide/constraint/#","page":"Constraints","title":"Constraints","text":"A guide and manual for defining and manipulating constraints in InfiniteOpt.","category":"page"},{"location":"guide/constraint/#Overview-1","page":"Constraints","title":"Overview","text":"","category":"section"},{"location":"guide/constraint/#Basic-Usage-1","page":"Constraints","title":"Basic Usage","text":"","category":"section"},{"location":"guide/constraint/#Data-Structure-1","page":"Constraints","title":"Data Structure","text":"","category":"section"},{"location":"guide/constraint/#Modification-1","page":"Constraints","title":"Modification","text":"","category":"section"},{"location":"guide/constraint/#Datatypes-1","page":"Constraints","title":"Datatypes","text":"","category":"section"},{"location":"guide/constraint/#","page":"Constraints","title":"Constraints","text":"Pages   = [\"constraint.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/constraint/#","page":"Constraints","title":"Constraints","text":"BoundedScalarConstraint\nGeneralConstraintRef\nInfiniteConstraintRef\nFiniteConstraintRef\nMeasureConstraintRef","category":"page"},{"location":"guide/constraint/#InfiniteOpt.BoundedScalarConstraint","page":"Constraints","title":"InfiniteOpt.BoundedScalarConstraint","text":"BoundedScalarConstraint{F <: JuMP.AbstractJuMPScalar,\n                        S <: MOI.AbstractScalarSet} <: JuMP.AbstractConstraint\n\nA DataType that stores infinite constraints defined on a subset of the infinite parameters on which they depend.\n\nFields\n\nfunc::F The JuMP object.\nset::S The MOI set.\nbounds::ParameterBounds Set of valid parameter sub-domains that further bound                           constraint.\norig_bounds::ParameterBounds Set of the constraint's original parameter                                sub-domains (not considering hold variables)\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.GeneralConstraintRef","page":"Constraints","title":"InfiniteOpt.GeneralConstraintRef","text":"GeneralConstraintRef\n\nAn abstract type for constraint references unique to InfiniteOpt.\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.InfiniteConstraintRef","page":"Constraints","title":"InfiniteOpt.InfiniteConstraintRef","text":"InfiniteConstraintRef{S <: JuMP.AbstractShape} <: GeneralConstraintRef\n\nA DataType for constraints that contain infinite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of constraint in model.\nshape::JuMP.AbstractShape Shape of constraint\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.FiniteConstraintRef","page":"Constraints","title":"InfiniteOpt.FiniteConstraintRef","text":"FiniteConstraintRef{S <: JuMP.AbstractShape} <: GeneralConstraintRef\n\nA DataType for constraints that contain finite variables.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of constraint in model.\nshape::JuMP.AbstractShape Shape of constraint\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#InfiniteOpt.MeasureConstraintRef","page":"Constraints","title":"InfiniteOpt.MeasureConstraintRef","text":"MeasureConstraintRef{S <: JuMP.AbstractShape} <: GeneralConstraintRef\n\nA DataType for constraints that contain finite variables and measures.\n\nFields\n\nmodel::InfiniteModel Infinite model.\nindex::Int Index of constraint in model.\nshape::JuMP.AbstractShape Shape of constraint\n\n\n\n\n\n","category":"type"},{"location":"guide/constraint/#Methods/Macros-1","page":"Constraints","title":"Methods/Macros","text":"","category":"section"},{"location":"guide/constraint/#","page":"Constraints","title":"Constraints","text":"Pages   = [\"constraint.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:macro, :function]","category":"page"},{"location":"guide/constraint/#","page":"Constraints","title":"Constraints","text":"@BDconstraint\nJuMP.build_constraint(::Function, ::InfiniteExpr, ::MOI.AbstractScalarSet)\nJuMP.add_constraint(::InfiniteModel, ::JuMP.AbstractConstraint)\nJuMP.owner_model(::GeneralConstraintRef)\nJuMP.index(::GeneralConstraintRef)\nJuMP.constraint_object(::GeneralConstraintRef)\nJuMP.name(::GeneralConstraintRef)\nJuMP.set_name(::GeneralConstraintRef, ::String)\nJuMP.is_valid(::InfiniteModel, ::GeneralConstraintRef)\nJuMP.delete(::InfiniteModel, ::GeneralConstraintRef)\nhas_parameter_bounds(::GeneralConstraintRef)\nparameter_bounds(::GeneralConstraintRef)\nset_parameter_bounds(::GeneralConstraintRef, ::ParameterBounds)\nadd_parameter_bound(::GeneralConstraintRef, ::ParameterRef, ::Number, ::Number)\ndelete_parameter_bound(::GeneralConstraintRef, ::ParameterRef)\ndelete_parameter_bounds(::GeneralConstraintRef)\nJuMP.set_normalized_rhs(::GeneralConstraintRef, ::Real)\nJuMP.normalized_rhs(::GeneralConstraintRef)\nJuMP.add_to_function_constant(::GeneralConstraintRef, ::Real)\nJuMP.set_normalized_coefficient(::GeneralConstraintRef, ::GeneralVariableRef, ::Real)\nJuMP.normalized_coefficient(::GeneralConstraintRef, ::GeneralVariableRef)\nJuMP.constraint_by_name(::InfiniteModel, ::String)\nJuMP.list_of_constraint_types(::InfiniteModel)\nJuMP.num_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar}, ::Type{<:MOI.AbstractSet})\nJuMP.num_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar})\nJuMP.num_constraints(::InfiniteModel, ::Type{<:MOI.AbstractSet})\nJuMP.num_constraints(::InfiniteModel)\nJuMP.all_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar}, ::Type{<:MOI.AbstractSet})\nJuMP.all_constraints(::InfiniteModel, ::Type{<:JuMP.AbstractJuMPScalar})\nJuMP.all_constraints(::InfiniteModel, ::Type{<:MOI.AbstractSet})\nJuMP.all_constraints(::InfiniteModel)","category":"page"},{"location":"guide/constraint/#InfiniteOpt.@BDconstraint","page":"Constraints","title":"InfiniteOpt.@BDconstraint","text":"@BDconstraint(model::InfiniteModel, [i = ..., ...](bound_expr), constr_expr;\n              [kw_args...])\n\nAdd an anonymous bounded constraint to model and return an appropriate container of constraint reference(s).\n\n    @BDconstraint(model::InfiniteModel, name[i = ..., ...](bound_expr),\n                  constr_expr; [kw_args...])\n\nAdd a named bounded constraint to model and return an appropriate container of constraint reference(s). This defines the constraint as expressed in constr_expr over some sub-domain of parameters as indicated by bound_expr. The format of constr_expr must follow the same syntax as that specified in JuMP.@constraint. For example, if we want to express the constraint 2T(t, x) + 3y = 42, the constraint expression constr_expr would be 2 * T + 3 * y == 42.\n\nBy default, JuMP.@constraint would express the above example constraint over the whole domain of t and x. However, we can use @BDconstraint to express this constraint over some sub-domain(s) via bound_expr. Here (bound_expr) can be of the form:\n\n(param in [lb, ub], ...) enforcing param to be in a sub-domain from lb                            to ub (note ∈ can be used in place of in)\n(params in [lb, ub], ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(lb <= param <= ub, ...) enforcing param to be in a sub-domain from lb                            to ub\n(lb <= params <= ub, ...) enforcing that all parameter references in params                             each be a in sub-domain from lb to ub\n(param == value, ...) enforcing param to be equal to value\n(params == value, ...) enforcing that all parameter references in params                           each to be equal to value\nAny combination of the above forms. Must be inside parentheses and comma separated.\n\nLike typical constraints, the container keyword argument can be used to specify the JuMP container type used to store the constraint references. Note this macro errors if bound_expr is ommited or if some unrecognized syntax is used.\n\nExamples\n\njulia> @BDconstraint(model, c1(t in [0, 1]), T^2 + z <= 1)\nc1 : T(x, t)² + z <= 1.0, for all t in [0, 1]\n\njulia> @BDconstraint(model, c2[i = 1:3](x[i] in [0, 1]), T^2 + z + x[i] <= 1)\n3-element Array{GeneralConstraintRef,1}:\n c2[1] : T(x, t)² + z + x[1] <= 1.0, for all x[1] in [0, 1]\n c2[2] : T(x, t)² + z + x[2] <= 1.0, for all x[2] in [0, 1]\n c2[3] : T(x, t)² + z + x[3] <= 1.0, for all x[3] in [0, 1]\n\njulia> @BDconstraint(model, (x == 0, t == 0), T^2 + z <= 1)\nT(x, t)² + z <= 1.0, for all x[2] == 0, x[3] == 0, t == 0, x[1] == 0\n\njulia> @BDconstraint(model, [i = 1:3](x[i] == 0), T^2 + z <= 1,\n                     container = SparseAxisArray)\nJuMP.Containers.SparseAxisArray{GeneralConstraintRef,1,Tuple{Any}} with 3 entries:\n  [3]  =  T(x, t)² + z <= 1.0, for all x[3] == 0\n  [2]  =  T(x, t)² + z <= 1.0, for all x[2] == 0\n  [1]  =  T(x, t)² + z <= 1.0, for all x[1] == 0\n\n\n\n\n\n","category":"macro"},{"location":"guide/constraint/#JuMP.build_constraint-Tuple{Function,Union{InfiniteVariableRef, ReducedInfiniteVariableRef, GenericAffExpr{Float64,GeneralVariableRef}, GenericAffExpr{Float64,InfiniteVariableRef}, GenericAffExpr{Float64,ReducedInfiniteVariableRef}, GenericQuadExpr{Float64,GeneralVariableRef}, GenericQuadExpr{Float64,InfiniteVariableRef}, GenericQuadExpr{Float64,ReducedInfiniteVariableRef}},MathOptInterface.AbstractScalarSet}","page":"Constraints","title":"JuMP.build_constraint","text":"JuMP.build_constraint(_error::Function, expr::InfiniteExpr,\n                      set::MOI.AbstractScalarSet;\n                      [parameter_bounds::ParameterBounds = ParameterBounds()])\n\nExtend JuMP.build_constraint to accept the parameter_bounds argument and return a BoundedScalarConstraint if the parameter_bounds keyword argument is specifed or return a JuMP.ScalarConstraint otherwise. This is primarily intended to work as an internal function for constraint macros.\n\nExample\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42.0),\n              parameter_bounds = ParameterBounds(Dict(t => IntervalSet(0, 1))));\n\njulia> isa(constr, BoundedScalarConstraint)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.add_constraint-Tuple{InfiniteModel,AbstractConstraint}","page":"Constraints","title":"JuMP.add_constraint","text":"JuMP.add_constraint(model::InfiniteModel, c::JuMP.AbstractConstraint,\n                    [name::String = \"\"])\n\nExtend JuMP.add_constraint to add a constraint c to an infinite model model with name name. Returns an appropriate constraint reference whose type depends on what variables are used to define the constraint. Errors if a vector constraint is used, the constraint only constains parameters, or if any variables do not belong to model. This is primarily used as an internal method for the cosntraint macros.\n\nExample\n\njulia> constr = build_constraint(error, g + x, MOI.EqualTo(42));\n\njulia> cref = add_constraint(model, constr, \"name\")\nname : g(t) + x == 42.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.owner_model-Tuple{GeneralConstraintRef}","page":"Constraints","title":"JuMP.owner_model","text":"JuMP.owner_model(cref::GeneralConstraintRef)::InfiniteModel\n\nExtend JuMP.owner_model to return the infinite model associated with cref.\n\nExample\n\njulia> model = owner_model(cref)\nAn InfiniteOpt Model\nMinimization problem with:\nVariables: 3\nObjective function type: HoldVariableRef\n`GenericAffExpr{Float64,FiniteVariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\nNames registered in the model: g, t, h, x\nOptimizer model backend information:\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.index-Tuple{GeneralConstraintRef}","page":"Constraints","title":"JuMP.index","text":"JuMP.index(cref::GeneralConstraintRef)::Int\n\nExtend JuMP.index to return the index of an InfiniteOpt constraint cref.\n\nExample\n\njulia> index(cref)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.constraint_object-Tuple{GeneralConstraintRef}","page":"Constraints","title":"JuMP.constraint_object","text":"JuMP.constraint_object(cref::GeneralConstraintRef)::JuMP.AbstractConstraint\n\nExtend JuMP.constraint_object to return the constraint object associated with cref.\n\nExample\n\njulia> obj = constraint_object(cref)\nScalarConstraint{HoldVariableRef,MathOptInterface.LessThan{Float64}}(x,\nMathOptInterface.LessThan{Float64}(1.0))\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.name-Tuple{GeneralConstraintRef}","page":"Constraints","title":"JuMP.name","text":"JuMP.name(cref::GeneralConstraintRef)::String\n\nExtend JuMP.name to return the name of an InfiniteOpt constraint.\n\nExample\n\njulia> name(cref)\nconstr_name\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.set_name-Tuple{GeneralConstraintRef,String}","page":"Constraints","title":"JuMP.set_name","text":"JuMP.set_name(cref::GeneralConstraintRef, name::String)\n\nExtend JuMP.set_name to specify the name of a constraint cref.\n\nExample\n\njulia> set_name(cref, \"new_name\")\n\njulia> name(cref)\nnew_name\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.is_valid-Tuple{InfiniteModel,GeneralConstraintRef}","page":"Constraints","title":"JuMP.is_valid","text":"JuMP.is_valid(model::InfiniteModel, cref::GeneralConstraintRef)::Bool\n\nExtend JuMP.is_valid to return Bool whether an InfiniteOpt constraint reference is valid.\n\nExample\n\njulia> is_valid(model, cref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.delete-Tuple{InfiniteModel,GeneralConstraintRef}","page":"Constraints","title":"JuMP.delete","text":"JuMP.delete(model::InfiniteModel, cref::GeneralConstraintRef)\n\nExtend JuMP.delete to delete an InfiniteOpt constraint and all associated information. Errors if cref is invalid.\n\nExample\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n g(t) + z >= 42.0\n t in [0, 6]\n\njulia> delete(model, cref)\n\njulia> print(model)\nMin measure(g(t)*t) + z\nSubject to\n z >= 0.0\n t in [0, 6]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.has_parameter_bounds-Tuple{GeneralConstraintRef}","page":"Constraints","title":"InfiniteOpt.has_parameter_bounds","text":"has_parameter_bounds(cref::GeneralConstraintRef)::Bool\n\nReturn a Bool indicating if cref is limited to a sub-domain as defined by a ParameterBounds object.\n\nExample\n\njulia> has_parameter_bounds(cref)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.parameter_bounds-Tuple{GeneralConstraintRef}","page":"Constraints","title":"InfiniteOpt.parameter_bounds","text":"parameter_bounds(cref::GeneralConstraintRef)::ParameterBounds\n\nReturn the ParameterBounds object associated with the constraint cref. Errors if cref does not have parameter bounds.\n\nExample\n\njulia> parameter_bounds(cref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.set_parameter_bounds-Tuple{GeneralConstraintRef,ParameterBounds}","page":"Constraints","title":"InfiniteOpt.set_parameter_bounds","text":"set_parameter_bounds(cref::GeneralConstraintRef, bounds:ParameterBounds;\n                     [force = false])\n\nSpecify a new ParameterBounds object bounds for the constraint cref. This is meant to be primarily used by @set_parameter_bounds which provides a more intuitive syntax.\n\nExample\n\njulia> set_parameter_bounds(cref, ParameterBounds(Dict(t => IntervalSet(0, 2))))\n\njulia> parameter_bounds(cref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.add_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef,Number,Number}","page":"Constraints","title":"InfiniteOpt.add_parameter_bound","text":"add_parameter_bound(cref::GeneralConstraintRef, pref::ParameterRef,\n                    lower::Number, upper::Number)\n\nAdd an additional parameter bound to cref such that it is defined over the sub-domain based on pref from lower to upper. This is primarily meant to be used by @add_parameter_bounds.\n\njulia> add_parameter_bound(cref, t, 0, 2)\n\njulia> parameter_bounds(cref)\nSubdomain bounds (1): t ∈ [0, 2]\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.delete_parameter_bound-Tuple{GeneralConstraintRef,ParameterRef}","page":"Constraints","title":"InfiniteOpt.delete_parameter_bound","text":"delete_parameter_bound(cref::GeneralConstraintRef, pref::ParameterRef)\n\nDelete the parameter bound of the constraint cref associated with the infinite parameter pref if cref has such a bound. Note that any other parameter bounds will be unaffected. Note any bounds that are needed for hold variables inside in cref will be unaffected.\n\nExample\n\njulia> @BDconstraint(model, c1(x == 0), y <= 42)\nc1 : y(x) <= 42, for all x[1] == 0, x[2] == 0\n\njulia> delete_parameter_bounds(c1, x[2])\n\njulia> c1\nc1 : y(x) <= 42, for all x[1] == 0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#InfiniteOpt.delete_parameter_bounds-Tuple{GeneralConstraintRef}","page":"Constraints","title":"InfiniteOpt.delete_parameter_bounds","text":"delete_parameter_bounds(cref::GeneralConstraintRef)\n\nDelete all the parameter bounds of the constraint cref. Note any bounds that are needed for hold variables inside in cref will be unaffected.\n\nExample\n\njulia> @BDconstraint(model, c1(x == 0), y <= 42)\nc1 : y(x) <= 42, for all x[1] == 0, x[2] == 0\n\njulia> delete_parameter_bounds(c1)\n\njulia> c1\nc1 : y(x) <= 42\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.set_normalized_rhs-Tuple{GeneralConstraintRef,Real}","page":"Constraints","title":"JuMP.set_normalized_rhs","text":"JuMP.set_normalized_rhs(cref::GeneralConstraintRef, value::Real)\n\nSet the right-hand side term of constraint to value. Note that prior to this step, JuMP will aggregate all constant terms onto the right-hand side of the constraint. For example, given a constraint 2x + 1 <= 2, set_normalized_rhs(con, 4) will create the constraint 2x <= 4, not 2x + 1 <= 4.\n\njulia> @constraint(model, con, 2x + 1 <= 2)\ncon : 2 x <= 1.0\n\njulia> set_normalized_rhs(con, 4)\n\njulia> con\ncon : 2 x <= 4.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.normalized_rhs-Tuple{GeneralConstraintRef}","page":"Constraints","title":"JuMP.normalized_rhs","text":"JuMP.normalized_rhs(cref::GeneralConstraintRef)::Number\n\nReturn the right-hand side term of cref after JuMP has converted the constraint into its normalized form. See also JuMP.set_normalized_rhs.\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.add_to_function_constant-Tuple{GeneralConstraintRef,Real}","page":"Constraints","title":"JuMP.add_to_function_constant","text":"JuMP.add_to_function_constant(cref::GeneralConstraintRef, value::Real)\n\nAdd value to the function constant term. Note that for scalar constraints, JuMP will aggregate all constant terms onto the right-hand side of the constraint so instead of modifying the function, the set will be translated by -value. For example, given a constraint 2x <= 3, add_to_function_constant(c, 4) will modify it to 2x <= -1. ```\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.set_normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef,Real}","page":"Constraints","title":"JuMP.set_normalized_coefficient","text":"JuMP.set_normalized_coefficient(cref::GeneralConstraintRef,\n                                variable::GeneralVariableRef, value::Real)\n\nSet the coefficient of variable in the constraint constraint to value. Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint 2x + 3x <= 2, set_normalized_coefficient(con, x, 4) will create the constraint 4x <= 2.\n\njulia> con\ncon : 5 x <= 2.0\n\njulia> set_normalized_coefficient(con, x, 4)\n\njulia> con\ncon : 4 x <= 2.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.normalized_coefficient-Tuple{GeneralConstraintRef,GeneralVariableRef}","page":"Constraints","title":"JuMP.normalized_coefficient","text":"JuMP.normalized_coefficient(cref::GeneralConstraintRef,\n                            variable::GeneralVariableRef)::Number\n\nReturn the coefficient associated with variable in constraint after JuMP has normalized the constraint into its standard form. See also JuMP.set_normalized_coefficient.\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.constraint_by_name-Tuple{InfiniteModel,String}","page":"Constraints","title":"JuMP.constraint_by_name","text":"JuMP.constraint_by_name(model::InfiniteModel,\n                        name::String)::Union{GeneralConstraintRef, Nothing}\n\nExtend JuMP.constraint_by_name to return the constraint reference associated with name if one exists or returns nothing. Errors if more than one constraint uses the same name.\n\nExample\n\njulia> constraint_by_name(model, \"constr_name\")\nconstr_name : x + pt == 3.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.list_of_constraint_types-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.list_of_constraint_types","text":"JuMP.list_of_constraint_types(model::InfiniteModel)::Vector{Tuple)\n\nExtend JuMP.list_of_constraint_types to return a list of tuples that contain all the used combinations of function types and set types in the model.\n\njulia> all_constraints(model)\n5-element Array{Tuple{DataType,DataType},1}:\n (HoldVariableRef, MathOptInterface.LessThan{Float64})\n (PointVariableRef, MathOptInterface.GreaterThan{Float64})\n (HoldVariableRef, MathOptInterface.GreaterThan{Float64})\n (HoldVariableRef, MathOptInterface.Integer)\n (InfiniteVariableRef, MathOptInterface.GreaterThan{Float64})\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s1} where #s1<:AbstractJuMPScalar,Type{#s2} where #s2<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar},\n                     set_type::Type{<:MOI.AbstractSet})::Int\n\nExtend JuMP.num_constraints to return the number of constraints with a partiuclar function type and set type.\n\nExample\n\njulia> num_constraints(model, HoldVariableRef, MOI.LessThan)\n1\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s2} where #s2<:AbstractJuMPScalar}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar})::Int\n\nExtend JuMP.num_constraints to search by function types for all MOI sets and return the total number of constraints with a particular function type.\n\njulia> num_constraints(model, HoldVariableRef)\n3\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel,Type{#s2} where #s2<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel,\n                     function_type::Type{<:MOI.AbstractSet})::Int\n\nExtend JuMP.num_constraints to search by MOI set type for all function types and return the total number of constraints that use a particular MOI set type.\n\njulia> num_constraints(model, MOI.LessThan)\n2\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.num_constraints-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.num_constraints","text":"JuMP.num_constraints(model::InfiniteModel)::Int\n\nExtend JuMP.num_constraints to return the total number of constraints in an infinite model model.\n\njulia> num_constraints(model)\n4\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s2} where #s2<:AbstractJuMPScalar,Type{#s1} where #s1<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar},\n                     set_type::Type{<:MOI.AbstractSet}\n                     )::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to return a list of all the constraints with a particular function type and set type.\n\njulia> all_constraints(model, HoldVariableRef, MOI.LessThan)\n1-element Array{GeneralConstraintRef,1}:\n x <= 1.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s2} where #s2<:AbstractJuMPScalar}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     function_type::Type{<:JuMP.AbstractJuMPScalar}\n                     )::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to search by function types for all MOI sets and return a list of all constraints use a particular function type.\n\njulia> all_constraints(model, HoldVariableRef)\n3-element Array{GeneralConstraintRef,1}:\n x >= 0.0\n x <= 3.0\n x integer\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel,Type{#s2} where #s2<:MathOptInterface.AbstractSet}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel,\n                     set_type::Type{<:MOI.AbstractSet}\n                     )::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to search by MOI set type for all function types and return a list of all constraints that use a particular set type.\n\njulia> all_constraints(model, MOI.GreaterThan)\n3-element Array{GeneralConstraintRef,1}:\n x >= 0.0\n g(t) >= 0.0\n g(0.5) >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/constraint/#JuMP.all_constraints-Tuple{InfiniteModel}","page":"Constraints","title":"JuMP.all_constraints","text":"JuMP.all_constraints(model::InfiniteModel)::Vector{<:GeneralConstraintRef}\n\nExtend JuMP.all_constraints to return all a list of all the constraints in an infinite model model.\n\njulia> all_constraints(model)\n5-element Array{GeneralConstraintRef,1}:\n x >= 0.0\n x <= 3.0\n x integer\n g(t) >= 0.0\n g(0.5) >= 0.0\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#Model-Transcription-1","page":"Model Transcription","title":"Model Transcription","text":"","category":"section"},{"location":"guide/transcribe/#","page":"Model Transcription","title":"Model Transcription","text":"A guide and manual for transcribing infinite models using InfiniteOpt.","category":"page"},{"location":"guide/transcribe/#Overview-1","page":"Model Transcription","title":"Overview","text":"","category":"section"},{"location":"guide/transcribe/#Basic-Usage-1","page":"Model Transcription","title":"Basic Usage","text":"","category":"section"},{"location":"guide/transcribe/#TranscriptionOpt-1","page":"Model Transcription","title":"TranscriptionOpt","text":"","category":"section"},{"location":"guide/transcribe/#Datatypes-1","page":"Model Transcription","title":"Datatypes","text":"","category":"section"},{"location":"guide/transcribe/#","page":"Model Transcription","title":"Model Transcription","text":"Pages   = [\"transcribe.md\"]\nModules = [InfiniteOpt]\nOrder   = [:type]","category":"page"},{"location":"guide/transcribe/#","page":"Model Transcription","title":"Model Transcription","text":"TranscriptionData","category":"page"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionData","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.TranscriptionData","text":"TranscriptionData\n\nA DataType for storing the data mapping an InfiniteOpt.InfiniteModel that has been transcribed to a regular JuMP.Model that contains the transcribed variables. This is stored in the ext field of a JuMP.Model to make what is called a TranscriptionModel via the TranscriptionModel constructor.\n\nFields\n\ninfinite_to_vars::Dict{InfiniteOpt.InfiniteVariableRef,  Vector{JuMP.VariableRef}}: Infinite variables to their transcribed variables.\nhold_to_var::Dict{InfiniteOpt.HoldVariableRef, JuMP.VariableRef}: Hold variables to model variables.\npoint_to_var::Dict{InfiniteOpt.PointVariableRef, JuMP.VariableRef}: Point variables to model variables.\ninfvar_to_supports::Dict{InfiniteOpt.InfiniteVariableRef, Dict}: Infinite variables to transcribed supports indexed by their numeric aliases.\ninfinite_to_constrs::Dict{InfiniteOpt.InfiniteConstraintRef, Vector{JuMP.ConstraintRef}}: Infinite constraints to their transcribed constraints.\nmeasure_to_constrs::Dict{InfiniteOpt.MeasureConstraintRef, Vector{JuMP.ConstraintRef}}: Measure constraints to model constraints.\nfinite_to_constr::Dict{InfiniteOpt.FiniteConstraintRef, JuMP.ConstraintRef}: Finite constraints to model constraints.\ninfconstr_to_supports::Dict{InfiniteOpt.InfiniteConstraintRef, Dict}: Infinite constraints to the transcribed supports indxed by their numeric aliases.\nmeasconstr_to_supports::Dict{InfiniteOpt.MeasureConstraintRef, Dict}: Measure constraints to the transcribed supports indxed by their numeric aliases.\ninfconstr_to_params::Dict{InfiniteOpt.InfiniteConstraintRef, Tuple}: Infinite constraints to the parameter tuples associated with each transcribed support.\nmeasconstr_to_params::Dict{InfiniteOpt.MeasureConstraintRef, Tuple}: Measure constraints to the parameter tuples associated with each transcribed support.\n\n\n\n\n\n","category":"type"},{"location":"guide/transcribe/#Methods-1","page":"Model Transcription","title":"Methods","text":"","category":"section"},{"location":"guide/transcribe/#","page":"Model Transcription","title":"Model Transcription","text":"Pages   = [\"transcribe.md\"]\nModules = [InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:function]","category":"page"},{"location":"guide/transcribe/#","page":"Model Transcription","title":"Model Transcription","text":"transcription_model\nbuild_optimizer_model!(::InfiniteModel,::Val{:TransData})\nTranscriptionModel()\nTranscriptionModel(::InfiniteModel)\nis_transcription_model\ntranscription_data\ntranscription_variable\nInfiniteOpt.supports(::JuMP.Model, ::InfiniteOpt.InfiniteVariableRef)\nInfiniteOpt.supports(::InfiniteOpt.InfiniteVariableRef)\ntranscription_constraint\nInfiniteOpt.supports(::JuMP.Model, ::InfiniteOpt.InfiniteConstraintRef)\nInfiniteOpt.supports(::InfiniteOpt.InfiniteConstraintRef)\nInfiniteOpt.parameter_refs(::JuMP.Model, ::InfiniteOpt.InfiniteConstraintRef)\nInfiniteOpt.parameter_refs(::InfiniteOpt.InfiniteConstraintRef)","category":"page"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_model","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_model","text":"transcription_model(model::InfiniteOpt.InfiniteModel)::JuMP.Model\n\nReturn the transcription model stored in model if that is what is stored in model.optimizer_model.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel,Val{:TransData}}","page":"Model Transcription","title":"InfiniteOpt.build_optimizer_model!","text":"InfiniteOpt.build_optimizer_model!(model::InfiniteOpt.InfiniteModel,\n                                   key::Val{:TransData})\n\nTranscribe model and store it as a TranscriptionModel in the model.optimizer_model field which can be accessed with transcription_model.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.TranscriptionModel","text":"TranscriptionModel([optimizer_factory::JuMP.OptimizerFactory];\n                   [caching_mode::MOIU.CachingOptimizerMode = MOIU.AUTOMATIC,\n                    bridge_constraints::Bool = true])::JuMP.Model\n\nReturn a JuMP.Model with TranscriptionData included in the ext data field. Accepts the same arguments as a typical JuMP Model.\n\nExample\n\njulia> TranscriptionModel()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.TranscriptionModel-Tuple{InfiniteModel}","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.TranscriptionModel","text":"TranscriptionModel(model::InfiniteModel, args...)\n\nReturn a TranscriptionModel of model. This transcribes all of the variables, constraints, and objective.\n\nExample\n\njulia> TranscriptionModel(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 130\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 25 constraints\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.GreaterThan{Float64}`: 100 constraint\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.LessThan{Float64}`: 84 constraints\n`VariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 40 constraints\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 40 constraints\n`VariableRef`-in-`MathOptInterface.LessThan{Float64}`: 25 constraints\n`VariableRef`-in-`MathOptInterface.Integer`: 40 constraints\n`VariableRef`-in-`MathOptInterface.ZeroOne`: 40 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.is_transcription_model","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.is_transcription_model","text":"is_transcription_model(model::JuMP.Model)::Bool\n\nReturn true if model is a TranscriptionModel or false otherwise.\n\nExample\n\njulia> is_transcription_model(model)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_data","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_data","text":"transcription_data(model::JuMP.Model)::TranscriptionData\n\nReturn the TranscriptionData from a TranscriptionModel. Errors if it is not a TranscriptionModel.\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_variable","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_variable","text":"transcription_variable(model::JuMP.Model,\n                       vref::InfiniteOpt.InfOptVariableRef)\n\nReturn the transcribed variable reference(s) corresponding to vref. Errors if no transcription variable is found.\n\nExample\n\njulia> transcription_variable(trans_model, infvar)\n2-element Array{VariableRef,1}:\n infvar(support: 1)\n infvar(support: 2)\n\njulia> transcription_variable(trans_model, gbvar)\ngbvar\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.supports-Tuple{Model,InfiniteVariableRef}","page":"Model Transcription","title":"InfiniteOpt.supports","text":"InfiniteOpt.supports(model::JuMP.Model,\n                     vref::InfiniteOpt.InfiniteVariableRef)::Vector\n\nReturn the support alias mapping associated with vref in the transcribed model. Errors if vref does not have transcribed variables.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.supports-Tuple{InfiniteVariableRef}","page":"Model Transcription","title":"InfiniteOpt.supports","text":"InfiniteOpt.supports(vref::InfiniteOpt.InfiniteVariableRef)::Vector\n\nReturn the support alias mapping associated with vref in the transcription model. Errors if the infinite model does not contain a transcription model or if vref is not transcribed.\n\nExample\n\njulia> supports(vref)\nDict{Int64,Tuple{Float64}} with 2 entries:\n  2 => (1.0,)\n  1 => (0.0,)\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.TranscriptionOpt.transcription_constraint","page":"Model Transcription","title":"InfiniteOpt.TranscriptionOpt.transcription_constraint","text":"transcription_constraint(model::JuMP.Model,\n                         cref::InfiniteOpt.GeneralConstraintRef)\n\nReturn the transcribed constraint reference(s) corresponding to cref. Errors if cref has not been transcribed.\n\nExample\n\njulia> transcription_constraint(trans_model, fin_con)\nfin_con : x(support: 1) - y <= 3.0\n\n\n\n\n\n","category":"function"},{"location":"guide/transcribe/#InfiniteOpt.supports-Tuple{Model,InfiniteConstraintRef}","page":"Model Transcription","title":"InfiniteOpt.supports","text":"InfiniteOpt.supports(model::JuMP.Model,\n                     cref::InfiniteOpt.GeneralConstraintRef)::Vector\n\nReturn the support alias mappings associated with cref. Errors if cref is not transcribed.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.supports-Tuple{InfiniteConstraintRef}","page":"Model Transcription","title":"InfiniteOpt.supports","text":"InfiniteOpt.supports(cref::InfiniteOpt.GeneralConstraintRef)::Vector\n\nReturn the support alias mappings associated with cref. Errors if cref is not transcribed or if the infinite model does not have a transcription model.\n\nExample\n\njulia> supports(cref)\nDict{Int64,Tuple{Float64}} with 2 entries:\n  2 => (1.0,)\n  1 => (0.0,)\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.parameter_refs-Tuple{Model,InfiniteConstraintRef}","page":"Model Transcription","title":"InfiniteOpt.parameter_refs","text":"InfiniteOpt.parameter_refs(model::JuMP.Model,\n                           cref::InfiniteOpt.GeneralConstraintRef)::Tuple\n\nReturn the a parameter reference tuple of all the parameters that parameterize cref and correspond to the supports. Errors if cref has not been transcribed.\n\n\n\n\n\n","category":"method"},{"location":"guide/transcribe/#InfiniteOpt.parameter_refs-Tuple{InfiniteConstraintRef}","page":"Model Transcription","title":"InfiniteOpt.parameter_refs","text":"InfiniteOpt.parameter_refs(cref::InfiniteOpt.GeneralConstraintRef)::Tuple\n\nReturn the a parameter reference tuple of all the parameters that parameterize cref and correspond to the supports. Errors if cref has not been transcribed or if the infinite model does not have a transcription model associated with it.\n\nExample\n\njulia> parameter_refs(cref)\n(t, x)\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#Optimization-1","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"guide/optimize/#","page":"Optimization","title":"Optimization","text":"A guide and manual for optimizing (solving) InfiniteOpt models.","category":"page"},{"location":"guide/optimize/#Overview-1","page":"Optimization","title":"Overview","text":"","category":"section"},{"location":"guide/optimize/#Basic-Usage-1","page":"Optimization","title":"Basic Usage","text":"","category":"section"},{"location":"guide/optimize/#Optimizer-Models-1","page":"Optimization","title":"Optimizer Models","text":"","category":"section"},{"location":"guide/optimize/#Optimizer-Settings-1","page":"Optimization","title":"Optimizer Settings","text":"","category":"section"},{"location":"guide/optimize/#Methods-1","page":"Optimization","title":"Methods","text":"","category":"section"},{"location":"guide/optimize/#","page":"Optimization","title":"Optimization","text":"Pages   = [\"optimize.md\"]\nModules = [InfiniteOpt, JuMP]\nOrder   = [:function]","category":"page"},{"location":"guide/optimize/#","page":"Optimization","title":"Optimization","text":"optimizer_model\nset_optimizer_model\noptimizer_model_key\nbuild_optimizer_model!(::InfiniteModel)\nbuild_optimizer_model!\noptimizer_model_ready\nset_optimizer_model_ready\nJuMP.bridge_constraints(::InfiniteModel)\nJuMP.add_bridge(::InfiniteModel, ::Type{<:MOI.Bridges.AbstractBridge})\nJuMP.set_optimizer(::InfiniteModel, ::JuMP.OptimizerFactory)\nJuMP.set_silent(::InfiniteModel)\nJuMP.unset_silent(::InfiniteModel)\nJuMP.set_parameter(::InfiniteModel, ::Any, ::Any)\nJuMP.optimize!(::InfiniteModel, ::Union{Nothing, JuMP.OptimizerFactory})","category":"page"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model","page":"Optimization","title":"InfiniteOpt.optimizer_model","text":"optimizer_model(model::InfiniteModel)::JuMP.Model\n\nReturn the JuMP model stored in model that is used to solve it.\n\nExample\n\njulia> opt_model = optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.set_optimizer_model","page":"Optimization","title":"InfiniteOpt.set_optimizer_model","text":"set_optimizer_model(inf_model::InfiniteModel, opt_model::JuMP.Model)\n\nSpecify the JuMP model that is used to solve inf_model. This is intended for internal use and extensions. Note that opt_model should contain extension data to allow it to map to inf_model in a manner similar to TranscriptionModel.\n\nExample\n\njulia> set_optimizer_model(model, TranscriptionModel())\n\njulia> optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_key","page":"Optimization","title":"InfiniteOpt.optimizer_model_key","text":"optimizer_model_key(model::InfiniteModel)::Any\n\nReturn the extension key used in the optimizer model of model. Errors if optimizer_model.ext contains more than one key. This is intended for internal use and extensions. For extensions this is used to dispatch to the appropriate optmizer model functions such as extensions to build_optimizer_model!.\n\nExample\n\njulia> optimizer_model_key(model)\n:TransData\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.build_optimizer_model!-Tuple{InfiniteModel}","page":"Optimization","title":"InfiniteOpt.build_optimizer_model!","text":" build_optimizer_model!(model::InfiniteModel)\n\nBuild the optimizer model stored in model such that it can be  treated as a normal JuMP model. Specifically, translate the variables and  constraints stored in model into ones that are stored in the optimizer model  and can be solved. This is build generally to accomodate extensions that use  custom optimizer model types in accordance with optimizer_model_key.  Extensions will need to implement their own version of the function  build_optimizer_model!(model::InfiniteModel, key::Val{ext_key_name}).\n\nExample\n\njulia> build_optimizer_model!(model)\n\njulia> optimizer_model_ready(model)\ntrue\n\n\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#InfiniteOpt.build_optimizer_model!","page":"Optimization","title":"InfiniteOpt.build_optimizer_model!","text":"build_optimizer_model!(model::InfiniteModel, key; kwargs...)\n\nBuild the optimizer model stored in model such that it can be treated as a normal JuMP model, where the Model.ext field contains a key that points to a datastructure that appropriately maps the data between the two models. The key argument should be be typed to Val{ext_key_name}.\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.optimizer_model_ready","page":"Optimization","title":"InfiniteOpt.optimizer_model_ready","text":"optimizer_model_ready(model::InfiniteModel)::Bool\n\nReturn Bool if the optimizer model is up to date with model.\n\nExample\n\njulia> optimizer_model_ready(model)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#InfiniteOpt.set_optimizer_model_ready","page":"Optimization","title":"InfiniteOpt.set_optimizer_model_ready","text":"set_optimizer_model_ready(model::InfiniteModel, status::Bool)\n\nSet the status of the optimizer model to whether it is up to date or not. Note is more intended as an internal function, but is useful for extensions.\n\nExample\n\njulia> set_optimizer_model_ready(model, true)\n\njulia> optimizer_model_ready(model)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"guide/optimize/#JuMP.bridge_constraints-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.bridge_constraints","text":"JuMP.bridge_constraints(model::InfiniteModel)::Bool\n\nExtend JuMP.bridge_constraints to return if an infinite model model has an optimizer model where the optimizer is set and unsupported constraints are automatically bridged to equivalent supported constraints when an appropriate transformation is available.\n\nExample\n\njulia> bridge_constraints(model)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.add_bridge-Tuple{InfiniteModel,Type{#s2} where #s2<:MathOptInterface.Bridges.AbstractBridge}","page":"Optimization","title":"JuMP.add_bridge","text":"JuMP.add_bridge(model::InfiniteModel,\n                BridgeType::Type{<:MOI.Bridges.AbstractBridge})\n\nExtend [JuMP.add_bridge] to add BridgeType to the list of bridges that can be used by the optimizer model to transform unsupported constraints into an equivalent formulation using only constraints supported by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_optimizer-Tuple{InfiniteModel,OptimizerFactory}","page":"Optimization","title":"JuMP.set_optimizer","text":"JuMP.set_optimizer(model::InfiniteModel,\n                   optimizer_factory::JuMP.OptimizerFactory;\n                   bridge_constraints::Bool=true)\n\nExtend JuMP.set_optimizer to set optimizer of infinite models. Specifically, the optimizer of the optimizer model is modified.\n\nExample\n\njulia> set_optimizer(model, with_optimizer(Clp.Optimizer))\n\njulia> optimizer_model(model)\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: SolverName() attribute not implemented by the optimizer.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_silent-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.set_silent","text":"JuMP.set_silent(model::InfiniteModel)\n\nExtend JuMP.set_silent for infinite models to take precedence over any other attribute controlling verbosity and requires the solver to produce no output.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.unset_silent-Tuple{InfiniteModel}","page":"Optimization","title":"JuMP.unset_silent","text":"JuMP.unset_silent(model::InfiniteModel)\n\nExtend JuMP.unset_silent for infinite models to Neutralize the effect of the set_silent function and let the solver attributes control the verbosity.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.set_parameter-Tuple{InfiniteModel,Any,Any}","page":"Optimization","title":"JuMP.set_parameter","text":"JuMP.set_parameter(model::InfiniteModel, name, value)\n\nSets solver-specific parameter identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"guide/optimize/#JuMP.optimize!-Tuple{InfiniteModel,Union{Nothing, OptimizerFactory}}","page":"Optimization","title":"JuMP.optimize!","text":"JuMP.optimize!(model::InfiniteModel,\n               optimizer_factory::Union{Nothing, JuMP.OptimizerFactory} = nothing;\n               bridge_constraints::Bool=true, kwargs...)\n\nExtend JuMP.optimize! to optimize infinite models using the internal optimizer model. Will call build_optimizer_model! if the optimizer model isn't up to date. The kwargs correspond to keyword arguments passed to build_optimizer_model! if any are defined.\n\nExample\n\njulia> optimize!(model, with_optimizer(Clp.Optimizer))\n\njulia> has_values(model)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#Results-1","page":"Results","title":"Results","text":"","category":"section"},{"location":"guide/result/#","page":"Results","title":"Results","text":"A guide and manual to querying optimized InfiniteOpt models.","category":"page"},{"location":"guide/result/#Overview-1","page":"Results","title":"Overview","text":"","category":"section"},{"location":"guide/result/#Basic-Usage-1","page":"Results","title":"Basic Usage","text":"","category":"section"},{"location":"guide/result/#Termination-Queries-1","page":"Results","title":"Termination Queries","text":"","category":"section"},{"location":"guide/result/#Variable-Queries-1","page":"Results","title":"Variable Queries","text":"","category":"section"},{"location":"guide/result/#Constraint-Queries-1","page":"Results","title":"Constraint Queries","text":"","category":"section"},{"location":"guide/result/#Methods-1","page":"Results","title":"Methods","text":"","category":"section"},{"location":"guide/result/#","page":"Results","title":"Results","text":"Pages   = [\"optimize.md\"]\nModules = [JuMP, InfiniteOpt, InfiniteOpt.TranscriptionOpt]\nOrder   = [:function]","category":"page"},{"location":"guide/result/#","page":"Results","title":"Results","text":"JuMP.termination_status(::InfiniteModel)\nJuMP.raw_status(::InfiniteModel)\nJuMP.primal_status(::InfiniteModel)\nJuMP.dual_status(::InfiniteModel)\nJuMP.solve_time(::InfiniteModel)\nJuMP.has_values(::InfiniteModel)\nJuMP.objective_bound(::InfiniteModel)\nJuMP.objective_value(::InfiniteModel)\nJuMP.value(::GeneralVariableRef)\nJuMP.value(::GeneralConstraintRef)\nmap_value\nInfiniteOpt.map_value(::InfiniteOpt.FiniteVariableRef, ::Val{:TransData})\nInfiniteOpt.map_value(::InfiniteOpt.InfiniteVariableRef, ::Val{:TransData})\nInfiniteOpt.map_value(::InfiniteOpt.FiniteConstraintRef, ::Val{:TransData})\nInfiniteOpt.map_value(::InfiniteOpt.GeneralConstraintRef, ::Val{:TransData})\nJuMP.optimizer_index(::GeneralVariableRef)\nJuMP.optimizer_index(::GeneralConstraintRef)\nmap_optimizer_index\nInfiniteOpt.map_optimizer_index(::InfiniteOpt.FiniteVariableRef, ::Val{:TransData})\nInfiniteOpt.map_optimizer_index(::InfiniteOpt.InfiniteVariableRef, ::Val{:TransData})\nInfiniteOpt.map_optimizer_index(::InfiniteOpt.FiniteConstraintRef, ::Val{:TransData})\nInfiniteOpt.map_optimizer_index(::InfiniteOpt.GeneralConstraintRef, ::Val{:TransData})\nJuMP.dual(::GeneralConstraintRef)\nmap_dual\nInfiniteOpt.map_dual(::InfiniteOpt.FiniteConstraintRef, ::Val{:TransData})\nInfiniteOpt.map_dual(::InfiniteOpt.InfiniteConstraintRef, ::Val{:TransData})\nJuMP.shadow_price(::GeneralConstraintRef)\nmap_shadow_price\nInfiniteOpt.map_shadow_price(::InfiniteOpt.FiniteConstraintRef, ::Val{:TransData})\nInfiniteOpt.map_shadow_price(::InfiniteOpt.InfiniteConstraintRef, ::Val{:TransData})","category":"page"},{"location":"guide/result/#JuMP.termination_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.termination_status","text":"JuMP.termination_status(model::InfiniteModel)\n\nReturn the reason why the solver stopped (i.e., the MathOptInterface model attribute TerminationStatus).\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.raw_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.raw_status","text":"JuMP.raw_status(model::InfiniteModel)\n\nReturn the reason why the solver stopped in its own words (i.e., the MathOptInterface model attribute RawStatusString).\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.primal_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.primal_status","text":" JuMP.primal_status(model::InfiniteModel)\n\nReturn the status of the most recent primal solution of the solver (i.e., the MathOptInterface model attribute PrimalStatus).\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.dual_status-Tuple{InfiniteModel}","page":"Results","title":"JuMP.dual_status","text":"JuMP.dual_status(model::InfiniteModel)\n\nReturn the status of the most recent dual solution of the solver (i.e., the MathOptInterface model attribute DualStatus).\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.solve_time-Tuple{InfiniteModel}","page":"Results","title":"JuMP.solve_time","text":"JuMP.solve_time(model::InfiniteModel)\n\nIf available, returns the solve time reported by the solver. Returns \"ArgumentError: ModelLike of type Solver.Optimizer does not support accessing the attribute MathOptInterface.SolveTime()\" if the attribute is not implemented.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.has_values-Tuple{InfiniteModel}","page":"Results","title":"JuMP.has_values","text":"JuMP.has_values(model::InfiniteModel)\n\nReturn true if the solver has a primal solution available to query, otherwise return false. See also JuMP.value.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.objective_bound-Tuple{InfiniteModel}","page":"Results","title":"JuMP.objective_bound","text":"JuMP.objective_bound(model::InfiniteModel)::Float64\n\nReturn the best known bound on the optimal objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.objective_value-Tuple{InfiniteModel}","page":"Results","title":"JuMP.objective_value","text":"JuMP.objective_value(model::InfiniteModel)::Float64\n\nReturn the objective value after a call to optimize!(model).\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.value-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.value","text":"JuMP.value(vref::GeneralVariableRef)\n\nGet the value of this variable in the result returned by a solver. Use JuMP.has_values to check if a result exists before asking for values.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.value-Tuple{GeneralConstraintRef}","page":"Results","title":"JuMP.value","text":"JuMP.value(cref::GeneralConstraintRef)\n\nGet the value of this constraint in the result returned by a solver. Use JuMP.has_values to check if a result exists before asking for values. This returns the primal value of the constraint function.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_value","page":"Results","title":"InfiniteOpt.map_value","text":"map_value(vref::GeneralVariableRef, key)\n\nMap the value of vref to its counterpart in the optimizer model type is distininguished by its extension key key as type Val{ext_key_name}.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_value-Tuple{FiniteVariableRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_value","text":"InfiniteOpt.map_value(fvref::InfiniteOpt.FiniteVariableRef,\n                      key::Val{:TransData})\n\nMap the value of the appropriate transcription variable in the transcription model to fvref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_value-Tuple{InfiniteVariableRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_value","text":"InfiniteOpt.map_value(ivref::InfiniteOpt.InfiniteVariableRef,\n                      key::Val{:TransData})\n\nMap the value of the appropriate transcription variables in the transcription model to ivref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_value-Tuple{FiniteConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_value","text":"InfiniteOpt.map_value(fcref::InfiniteOpt.FiniteConstraintRef,\n                      key::Val{:TransData})\n\nMap the value of the appropriate transcription constraint function in the transcription model to fcref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_value-Tuple{GeneralConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_value","text":"InfiniteOpt.map_value(icref::InfiniteOpt.GeneralConstraintRef,\n                      key::Val{:TransData})\n\nMap the value of the appropriate transcription constraint functions in the transcription model to icref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.optimizer_index-Tuple{GeneralVariableRef}","page":"Results","title":"JuMP.optimizer_index","text":"JuMP.optimizer_index(vref::GeneralVariableRef)\n\nReturn the index of the variables that corresponds to vref in the optimizer model. It throws JuMP.NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.optimizer_index-Tuple{GeneralConstraintRef}","page":"Results","title":"JuMP.optimizer_index","text":"JuMP.optimizer_index(cref::GeneralConstraintRef)\n\nReturn the index of the constraints that corresponds to cref in the optimizer model. It throws JuMP.NoOptimizer if no optimizer is set and throws an ErrorException if the optimizer is set but is not attached.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_optimizer_index","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"map_optimizer_index(ref, key)\n\nMap the optimizer index of ref to its counterpart in the optimizer model type distininguished by its extension key key as type Val{ext_key_name}. Here ref need refer to methods for both variable references and constraint references.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_optimizer_index-Tuple{FiniteVariableRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"InfiniteOpt.map_optimizer_index(fvref::InfiniteOpt.FiniteVariableRef,\n                                key::Val{:TransData})\n\nMap the optimizer model index of the appropriate transcription variable in the transcription model to fvref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_optimizer_index-Tuple{InfiniteVariableRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"InfiniteOpt.map_optimizer_index(ivref::InfiniteOpt.InfiniteVariableRef,\n                                key::Val{:TransData})\n\nMap the optimizer model index of the appropriate transcription variables in the transcription model to ivref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_optimizer_index-Tuple{FiniteConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"InfiniteOpt.map_optimizer_index(fcref::InfiniteOpt.FiniteConstraintRef,\n                                key::Val{:TransData})\n\nMap the optimizer model index of the appropriate transcription constraint in the transcription model to fcref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_optimizer_index-Tuple{GeneralConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_optimizer_index","text":"InfiniteOpt.map_optimizer_index(cref::InfiniteOpt.GeneralConstraintRef,\n                                key::Val{:TransData})\n\nMap the optimizer model index of the appropriate transcription constraints in the transcription model to cref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.dual-Tuple{GeneralConstraintRef}","page":"Results","title":"JuMP.dual","text":"JuMP.dual(cref::GeneralConstraintRef)\n\nGet the dual value of this constraint in the result returned by a solver. Use has_dual to check if a result exists before asking for values. See also JuMP.shadow_price.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_dual","page":"Results","title":"InfiniteOpt.map_dual","text":"map_dual(cref::GeneralConstraintRef, key)\n\nMap the dual of cref to its counterpart in the optimizer model type distininguished by its extension key key as type Val{ext_key_name}.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_dual-Tuple{FiniteConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_dual","text":"InfiniteOpt.map_dual(fcref::InfiniteOpt.FiniteConstraintRef,\n                     key::Val{:TransData})\n\nMap the dual of the appropriate transcription constraint in the transcription model to fcref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_dual-Tuple{InfiniteConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_dual","text":"InfiniteOpt.map_dual(icref::InfiniteOpt.InfiniteConstraintRef,\n                     key::Val{:TransData})\n\nMap the duals of the appropriate transcription constraints in the transcription model to icref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#JuMP.shadow_price-Tuple{GeneralConstraintRef}","page":"Results","title":"JuMP.shadow_price","text":"JuMP.shadow_price(cref::GeneralConstraintRef)\n\nThe change in the objective from an infinitesimal relaxation of the constraint. This value is computed from JuMP.dual and can be queried only when has_duals is true and the objective sense is MIN_SENSE or MAX_SENSE (not FEASIBILITY_SENSE). For linear constraints, the shadow prices differ at most in sign from the dual value depending on the objective sense.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_shadow_price","page":"Results","title":"InfiniteOpt.map_shadow_price","text":"map_shadow_price(cref::GeneralConstraintRef, key)\n\nMap the shadow price of cref to its counterpart in the optimizer model type distininguished by its extension key key as type Val{ext_key_name}.\n\n\n\n\n\n","category":"function"},{"location":"guide/result/#InfiniteOpt.map_shadow_price-Tuple{FiniteConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_shadow_price","text":"InfiniteOpt.map_shadow_price(fcref::InfiniteOpt.FiniteConstraintRef,\n                             key::Val{:TransData})\n\nMap the shadow price of the appropriate transcription constraint in the transcription model to fcref.\n\n\n\n\n\n","category":"method"},{"location":"guide/result/#InfiniteOpt.map_shadow_price-Tuple{InfiniteConstraintRef,Val{:TransData}}","page":"Results","title":"InfiniteOpt.map_shadow_price","text":"InfiniteOpt.map_shadow_price(icref::InfiniteOpt.InfiniteConstraintRef,\n                             key::Val{:TransData})\n\nMap the shadow prices of the appropriate transcription constraints in the transcription model to icref.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"extensions/#Extensions-1","page":"Extensions","title":"Extensions","text":"","category":"section"},{"location":"develop/#Developers-Guide-1","page":"Development","title":"Developers Guide","text":"","category":"section"},{"location":"library/#Method,-DataType,-and-Macro-Index-1","page":"Library","title":"Method, DataType, and Macro Index","text":"","category":"section"},{"location":"library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"JuMP/#JuMP-Documentation-1","page":"JuMP Docs","title":"JuMP Documentation","text":"","category":"section"},{"location":"JuMP/#","page":"JuMP Docs","title":"JuMP Docs","text":"JuMP.Model\nJuMP.Model()\nJuMP.Model(::OptimizerFactory)\nJuMP.with_optimizer\nJuMP.@expression\nJuMP.add_to_expression!\nJuMP.@objective\nJuMP.ScalarConstraint\nJuMP.@constraint\nJuMP.SecondOrderCone\nJuMP.RotatedSecondOrderCone\nJuMP.PSDCone\nJuMP.NoOptimizer\nJuMP.delete(::Model, ::VariableRef)\nJuMP.is_valid(::JuMP.Model, ::JuMP.VariableRef)\nJuMP.set_name(::VariableRef, ::String)\nJuMP.add_variable\nJuMP.@variable\nJuMP.owner_model(::AbstractVariableRef)\nJuMP.index(::VariableRef)\nJuMP.num_variables(::Model)\nJuMP.name(::VariableRef)\nJuMP.variable_by_name(::Model, ::String)\nall_variables(::Model)\nJuMP.has_lower_bound(::VariableRef)\nJuMP.lower_bound(::VariableRef)\nJuMP.set_lower_bound(::VariableRef, ::Number)\nJuMP.LowerBoundRef(::VariableRef)\nJuMP.delete_lower_bound(::VariableRef)\nJuMP.has_upper_bound(::VariableRef)\nJuMP.upper_bound(::VariableRef)\nJuMP.set_upper_bound(::VariableRef, ::Number)\nJuMP.UpperBoundRef(::VariableRef)\nJuMP.delete_upper_bound(::VariableRef)\nJuMP.is_fixed(::VariableRef)\nJuMP.fix_value(::VariableRef)\nJuMP.fix(::VariableRef, ::Number)\nJuMP.FixRef(::VariableRef)\nJuMP.unfix(::VariableRef)\nJuMP.start_value(::VariableRef)\nJuMP.set_start_value(::VariableRef, ::Number)\nJuMP.is_binary(::VariableRef)\nJuMP.set_binary(::VariableRef)\nJuMP.BinaryRef(::VariableRef)\nJuMP.unset_binary(::VariableRef)\nJuMP.is_integer(::VariableRef)\nJuMP.set_integer(::VariableRef)\nJuMP.IntegerRef(::VariableRef)\nJuMP.unset_integer(::VariableRef)","category":"page"},{"location":"JuMP/#JuMP.Model","page":"JuMP Docs","title":"JuMP.Model","text":"Model\n\nA mathematical model of an optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.Model-Tuple{}","page":"JuMP Docs","title":"JuMP.Model","text":"Model(; caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,\n        bridge_constraints::Bool=true)\n\nReturn a new JuMP model without any optimizer; the model is stored the model in a cache. The mode of the CachingOptimizer storing this cache is caching_mode. The optimizer can be set later in the optimize! call. If bridge_constraints is true, constraints that are not supported by the optimizer are automatically bridged to equivalent supported constraints when an appropriate transformation is defined in the MathOptInterface.Bridges module or is defined in another module and is explicitely added.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.Model-Tuple{OptimizerFactory}","page":"JuMP Docs","title":"JuMP.Model","text":"Model(optimizer_factory::OptimizerFactory;\n      caching_mode::MOIU.CachingOptimizerMode=MOIU.AUTOMATIC,\n      bridge_constraints::Bool=true)\n\nReturn a new JuMP model using the optimizer factory optimizer_factory to create the optimizer. The optimizer factory can be created by the with_optimizer function.\n\nExamples\n\nThe following creates a model using the optimizer Ipopt.Optimizer(print_level=0):\n\nmodel = Model(with_optimizer(Ipopt.Optimizer, print_level=0))\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.with_optimizer","page":"JuMP Docs","title":"JuMP.with_optimizer","text":"with_optimizer(constructor, args...; kwargs...)\n\nReturn an OptimizerFactory that creates optimizers using the constructor constructor with positional arguments args and keyword arguments kwargs.\n\nExamples\n\nThe following returns an optimizer factory that creates Ipopt.Optimizers using the constructor call Ipopt.Optimizer(print_level=0):\n\nwith_optimizer(Ipopt.Optimizer, print_level=0)\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.@expression","page":"JuMP Docs","title":"JuMP.@expression","text":"@expression(args...)\n\nEfficiently builds a linear or quadratic expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:\n\n@expression(m, shared, sum(i*x[i] for i=1:5))\n@constraint(m, shared + y >= 5)\n@constraint(m, shared + z <= 10)\n\nThe ref accepts index sets in the same way as @variable, and those indices can be used in the construction of the expressions:\n\n@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))\n\nAnonymous syntax is also supported:\n\nexpr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.add_to_expression!","page":"JuMP Docs","title":"JuMP.add_to_expression!","text":"add_to_expression!(expression, terms...)\n\nUpdates expression in place to expression + (*)(terms...). This is typically much more efficient than expression += (*)(terms...). For example, add_to_expression!(expression, a, b) produces the same result as expression += a*b, and add_to_expression!(expression, a) produces the same result as expression += a.\n\nOnly a few methods are defined, mostly for internal use, and only for the cases when (1) they can be implemented efficiently and (2) expression is capable of storing the result. For example, add_to_expression!(::AffExpr, ::VariableRef, ::VariableRef) is not defined because a GenericAffExpr cannot store the product of two variables.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.@objective","page":"JuMP Docs","title":"JuMP.@objective","text":"@objective(model::Model, sense, func)\n\nSet the objective sense to sense and objective function to func. The objective sense can be either Min, Max, MathOptInterface.MIN_SENSE, MathOptInterface.MAX_SENSE or MathOptInterface.FEASIBILITY_SENSE; see MathOptInterface.ObjectiveSense. In order to set the sense programatically, i.e., when sense is a Julia variable whose value is the sense, one of the three MathOptInterface.ObjectiveSense values should be used. The function func can be a single JuMP variable, an affine expression of JuMP variables or a quadratic expression of JuMP variables.\n\nExamples\n\nTo minimize the value of the variable x, do as follows:\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> @objective(model, Min, x)\nx\n\nTo maximize the value of the affine expression 2x - 1, do as follows:\n\njulia> @objective(model, Max, 2x - 1)\n2 x - 1\n\nTo set a quadratic objective and set the objective sense programatically, do as follows:\n\njulia> sense = MOI.MIN_SENSE\nMIN_SENSE::OptimizationSense = 0\n\njulia> @objective(model, sense, x^2 - 2x + 1)\nx² - 2 x + 1\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.ScalarConstraint","page":"JuMP Docs","title":"JuMP.ScalarConstraint","text":"struct ScalarConstraint\n\nThe data for a scalar constraint. The func field containts a JuMP object representing the function and the set field contains the MOI set. See also the documentation on JuMP's representation of constraints for more background.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.@constraint","page":"JuMP Docs","title":"JuMP.@constraint","text":"@constraint(m::Model, expr)\n\nAdd a constraint described by the expression expr.\n\n@constraint(m::Model, ref[i=..., j=..., ...], expr)\n\nAdd a group of constraints described by the expression expr parametrized by i, j, ...\n\nThe expression expr can either be\n\nof the form func in set constraining the function func to belong to the set set which is either a MathOptInterface.AbstractSet or one of the JuMP shortcuts SecondOrderCone, RotatedSecondOrderCone and PSDCone, e.g. @constraint(model, [1, x-1, y-2] in SecondOrderCone()) constrains the norm of [x-1, y-2] be less than 1;\nof the form a sign b, where sign is one of ==, ≥, >=, ≤ and <= building the single constraint enforcing the comparison to hold for the expression a and b, e.g. @constraint(m, x^2 + y^2 == 1) constrains x and y to lie on the unit circle;\nof the form a ≤ b ≤ c or a ≥ b ≥ c (where ≤ and <= (resp. ≥ and >=) can be used interchangeably) constraining the paired the expression b to lie between a and c;\nof the forms @constraint(m, a .sign b) or @constraint(m, a .sign b .sign c) which broadcast the constraint creation to each element of the vectors.\n\nNote for extending the constraint macro\n\nEach constraint will be created using add_constraint(m, build_constraint(_error, func, set)) where\n\n_error is an error function showing the constraint call in addition to the error message given as argument,\nfunc is the expression that is constrained\nand set is the set in which it is constrained to belong.\n\nFor expr of the first type (i.e. @constraint(m, func in set)), func and set are passed unchanged to build_constraint but for the other types, they are determined from the expressions and signs. For instance, @constraint(m, x^2 + y^2 == 1) is transformed into add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0))).\n\nTo extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to build_constraint. Note that this will likely mean that either func or set will be some custom type, rather than e.g. a Symbol, since we will likely want to dispatch on the type of the function or set appearing in the constraint.\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.SecondOrderCone","page":"JuMP Docs","title":"JuMP.SecondOrderCone","text":"SecondOrderCone\n\nSecond order cone object that can be used to constrain the euclidean norm of a vector x to be less than or equal to a nonnegative scalar t. This is a shortcut for the MathOptInterface.SecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le t and t ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x-1, x-2] in SecondOrderCone())\n[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.RotatedSecondOrderCone","page":"JuMP Docs","title":"JuMP.RotatedSecondOrderCone","text":"RotatedSecondOrderCone\n\nRotated second order cone object that can be used to constrain the square of the euclidean norm of a vector x to be less than or equal to 2tu where t and u are nonnegative scalars. This is a shortcut for the MathOptInterface.RotatedSecondOrderCone.\n\nExamples\n\nThe following constrains (x-1 x-2)_2 le 2tx and t x ge 0:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> @variable(model, t)\nt\n\njulia> @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())\n[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.PSDCone","page":"JuMP Docs","title":"JuMP.PSDCone","text":"PSDCone\n\nPositive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the @constraint macro. If the matrix has type Symmetric then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the MOI.PositiveSemidefiniteConeTriangle set, otherwise its column vectorization is constrained to belong to the MOI.PositiveSemidefiniteConeSquare set.\n\nExamples\n\nConsider the following example:\n\njulia> model = Model();\n\njulia> @variable(model, x)\nx\n\njulia> a = [ x 2x\n            2x  x];\n\njulia> b = [1 2\n            2 4];\n\njulia> cref = @SDconstraint(model, a ⪰ b)\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n4-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeSquare(2)\n\nWe see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\njulia> using LinearAlgebra # For Symmetric\n\njulia> cref = @constraint(model, Symmetric(a - b) in PSDCone())\n[x - 1    2 x - 2;\n 2 x - 2  x - 4  ] ∈ PSDCone()\n\njulia> jump_function(constraint_object(cref))\n3-element Array{GenericAffExpr{Float64,VariableRef},1}:\n x - 1\n 2 x - 2\n x - 4\n\njulia> moi_set(constraint_object(cref))\nMathOptInterface.PositiveSemidefiniteConeTriangle(2)\n\nAs we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the PositiveSemidefiniteConeSquare.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.NoOptimizer","page":"JuMP Docs","title":"JuMP.NoOptimizer","text":"struct NoOptimizer <: Exception end\n\nNo optimizer is set. The optimizer can be provided at the Model constructor or at the optimize! call with with_optimizer.\n\n\n\n\n\n","category":"type"},{"location":"JuMP/#JuMP.delete-Tuple{Model,VariableRef}","page":"JuMP Docs","title":"JuMP.delete","text":"delete(model::Model, variable_ref::VariableRef)\n\nDelete the variable associated with variable_ref from the model model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_valid-Tuple{Model,VariableRef}","page":"JuMP Docs","title":"JuMP.is_valid","text":"is_valid(model::Model, variable_ref::VariableRef)\n\nReturn true if variable refers to a valid variable in model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_name-Tuple{VariableRef,String}","page":"JuMP Docs","title":"JuMP.set_name","text":"set_name(v::VariableRef, s::AbstractString)\n\nSet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.add_variable","page":"JuMP Docs","title":"JuMP.add_variable","text":"add_variable(m::Model, v::AbstractVariable, name::String=\"\")\n\nAdd a variable v to Model m and sets its name.\n\n\n\n\n\n","category":"function"},{"location":"JuMP/#JuMP.@variable","page":"JuMP Docs","title":"JuMP.@variable","text":"@variable(model, kw_args...)\n\nAdd an anonymous variable to the model model described by the keyword arguments kw_args and returns the variable.\n\n@variable(model, expr, args..., kw_args...)\n\nAdd a variable to the model model described by the expression expr, the positional arguments args and the keyword arguments kw_args. The expression expr can either be (note that in the following the symbol <= can be used instead of ≤ and the symbol >=can be used instead of ≥)\n\nof the form varexpr creating variables described by varexpr;\nof the form varexpr ≤ ub (resp. varexpr ≥ lb) creating variables described by varexpr with upper bounds given by ub (resp. lower bounds given by lb);\nof the form varexpr == value creating variables described by varexpr with fixed values given by value; or\nof the form lb ≤ varexpr ≤ ub or ub ≥ varexpr ≥ lb creating variables described by varexpr with lower bounds given by lb and upper bounds given by ub.\n\nThe expression varexpr can either be\n\nof the form varname creating a scalar real variable of name varname;\nof the form varname[...] or [...] creating a container of variables (see Containers in macros).\n\nThe recognized positional arguments in args are the following:\n\nBin: Sets the variable to be binary, i.e. either 0 or 1.\nInt: Sets the variable to be integer, i.e. one of ..., -2, -1, 0, 1, 2, ...\nSymmetric: Only available when creating a square matrix of variables, i.e. when varexpr is of the form varname[1:n,1:n] or varname[i=1:n,j=1:n]. It creates a symmetric matrix of variable, that is, it only creates a new variable for varname[i,j] with i ≤ j and sets varname[j,i] to the same variable as varname[i,j].\nPSD: The square matrix of variable is both Symmetric and constrained to be positive semidefinite.\n\nThe recognized keyword arguments in kw_args are the following:\n\nbase_name: Sets the name prefix used to generate variable names. It corresponds to the variable name for scalar variable, otherwise, the variable names are set to base_name[...] for each index ... of the axes axes.\nlower_bound: Sets the value of the variable lower bound.\nupper_bound: Sets the value of the variable upper bound.\nstart: Sets the variable starting value used as initial guess in optimization.\nbinary: Sets whether the variable is binary or not.\ninteger: Sets whether the variable is integer or not.\nvariable_type: See the \"Note for extending the variable macro\" section below.\ncontainer: Specify the container type, see Containers in macros.\n\nExamples\n\nThe following are equivalent ways of creating a variable x of name x with lower bound 0:\n\n# Specify everything in `expr`\n@variable(model, x >= 0)\n# Specify the lower bound using a keyword argument\n@variable(model, x, lower_bound=0)\n# Specify everything in `kw_args`\nx = @variable(model, base_name=\"x\", lower_bound=0)\n\nThe following are equivalent ways of creating a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b].\n\nub = Dict(:a => 2, :b => 3)\n# Specify everything in `expr`\n@variable(model, x[i=keys(ub)] <= ub[i])\n# Specify the upper bound using a keyword argument\n@variable(model, x[i=keys(ub)], upper_bound=ub[i])\n\nNote for extending the variable macro\n\nThe single scalar variable or each scalar variable of the container are created using add_variable(model, build_variable(_error, info, extra_args...; extra_kw_args...)) where\n\nmodel is the model passed to the @variable macro;\n_error is an error function with a single String argument showing the @variable call in addition to the error message given as argument;\ninfo is the VariableInfo struct containing the information gathered in expr, the recognized keyword arguments (except base_name and variable_type) and the recognized positional arguments (except Symmetric and PSD);\nextra_args are the unrecognized positional arguments of args plus the value of the variable_type keyword argument if present. The variable_type keyword argument allows the user to pass a position argument to build_variable without the need to give a positional argument to @variable. In particular, this allows the user to give a positional argument to the build_variable call when using the anonymous single variable syntax @variable(model, kw_args...); and\nextra_kw_args are the unrecognized keyword argument of kw_args.\n\nExamples\n\nThe following creates a variable x of name x with lower_bound 0 as with the first example above but does it without using the @variable macro\n\ninfo = VariableInfo(true, 0, false, NaN, false, NaN, false, NaN, false, false)\nJuMP.add_variable(model, JuMP.build_variable(error, info), \"x\")\n\nThe following creates a DenseAxisArray of index set [:a, :b] and with respective upper bounds 2 and 3 and names x[a] and x[b] as with the second example above but does it without using the @variable macro\n\n# Without the `@variable` macro\ndata = Vector{JuMP.variable_type(model)}(undef, length(keys(ub)))\nx = JuMP.Containers.DenseAxisArray(data, keys(ub))\nfor i in keys(ub)\n    info = VariableInfo(false, NaN, true, ub[i], false, NaN, false, NaN, false, false)\n    x[i] = JuMP.add_variable(model, JuMP.build_variable(error, info), \"x[$i]\")\nend\n\nThe following are equivalent ways of creating a Matrix of size N x N with variables custom variables created with a JuMP extension using the Poly(X) positional argument to specify its variables:\n\n# Using the `@variable` macro\n@variable(model, x[1:N,1:N], Symmetric, Poly(X))\n# Without the `@variable` macro\nx = Matrix{JuMP.variable_type(model, Poly(X))}(N, N)\ninfo = VariableInfo(false, NaN, false, NaN, false, NaN, false, NaN, false, false)\nfor i in 1:N, j in i:N\n    x[i,j] = x[j,i] = JuMP.add_variable(model, build_variable(error, info, Poly(X)), \"x[$i,$j]\")\nend\n\n\n\n\n\n","category":"macro"},{"location":"JuMP/#JuMP.owner_model-Tuple{AbstractVariableRef}","page":"JuMP Docs","title":"JuMP.owner_model","text":"owner_model(v::AbstractVariableRef)\n\nReturns the model to which v belongs.\n\nExample\n\njulia> model = Model()\n\njulia> x = @variable(model)\n\njulia> owner_model(x) === model\ntrue\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.index-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.index","text":"index(v::VariableRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to v in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.num_variables-Tuple{Model}","page":"JuMP Docs","title":"JuMP.num_variables","text":"num_variables(model::Model)::Int64\n\nReturns number of variables in model.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.name-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.name","text":"name(v::VariableRef)::String\n\nGet a variable's name attribute.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.variable_by_name-Tuple{Model,String}","page":"JuMP Docs","title":"JuMP.variable_by_name","text":"variable_by_name(model::AbstractModel,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute.\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, x)\nx\n\njulia> variable_by_name(model, \"x\")\nx\n\njulia> @variable(model, base_name=\"x\")\nx\n\njulia> variable_by_name(model, \"x\")\nERROR: Multiple variables have the name x.\nStacktrace:\n [1] error(::String) at ./error.jl:33\n [2] get(::MOIU.Model{Float64}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/model.jl:222\n [3] get at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/universalfallback.jl:201 [inlined]\n [4] get(::MathOptInterface.Utilities.CachingOptimizer{MathOptInterface.AbstractOptimizer,MathOptInterface.Utilities.UniversalFallback{MOIU.Model{Float64}}}, ::Type{MathOptInterface.VariableIndex}, ::String) at /home/blegat/.julia/dev/MathOptInterface/src/Utilities/cachingoptimizer.jl:490\n [5] variable_by_name(::Model, ::String) at /home/blegat/.julia/dev/JuMP/src/variables.jl:268\n [6] top-level scope at none:0\n\njulia> var = @variable(model, base_name=\"y\")\ny\n\njulia> variable_by_name(model, \"y\")\ny\n\njulia> set_name(var, \"z\")\n\njulia> variable_by_name(model, \"y\")\n\njulia> variable_by_name(model, \"z\")\nz\n\njulia> @variable(model, u[1:2])\n2-element Array{VariableRef,1}:\n u[1]\n u[2]\n\njulia> variable_by_name(model, \"u[2]\")\nu[2]\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.all_variables-Tuple{Model}","page":"JuMP Docs","title":"JuMP.all_variables","text":"all_variables(model::Model)::Vector{VariableRef}\n\nReturns a list of all variables currently in the model. The variables are ordered by creation time.\n\nExample\n\nmodel = Model()\n@variable(model, x)\n@variable(model, y)\nall_variables(model)\n\n# output\n\n2-element Array{VariableRef,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.has_lower_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.has_lower_bound","text":"has_lower_bound(v::VariableRef)\n\nReturn true if v has a lower bound. If true, the lower bound can be queried with lower_bound. See also LowerBoundRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.lower_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.lower_bound","text":"lower_bound(v::VariableRef)\n\nReturn the lower bound of a variable. Error if one does not exist. See also has_lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_lower_bound-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.set_lower_bound","text":"set_lower_bound(v::VariableRef, lower::Number)\n\nSet the lower bound of a variable. If one does not exist, create a new lower bound constraint. See also delete_lower_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.LowerBoundRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(v::VariableRef)\n\nReturn a constraint reference to the lower bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.delete_lower_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(v::VariableRef)\n\nDelete the lower bound constraint of a variable.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.has_upper_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.has_upper_bound","text":"has_upper_bound(v::VariableRef)\n\nReturn true if v has a upper bound. If true, the upper bound can be queried with upper_bound. See also UpperBoundRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.upper_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.upper_bound","text":"upper_bound(v::VariableRef)\n\nReturn the upper bound of a variable. Error if one does not exist. See also has_upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_upper_bound-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.set_upper_bound","text":"set_upper_bound(v::VariableRef,upper::Number)\n\nSet the upper bound of a variable. If one does not exist, create an upper bound constraint. See also delete_upper_bound.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.UpperBoundRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.UpperBoundRef","text":"UpperBoundRef(v::VariableRef)\n\nReturn a constraint reference to the upper bound constraint of v. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.delete_upper_bound-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(v::VariableRef)\n\nDelete the upper bound constraint of a variable.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_fixed-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.is_fixed","text":"is_fixed(v::VariableRef)\n\nReturn true if v is a fixed variable. If true, the fixed value can be queried with fix_value. See also FixRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.fix_value-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.fix_value","text":"fix_value(v::VariableRef)\n\nReturn the value to which a variable is fixed. Error if one does not exist. See also is_fixed.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.fix-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.fix","text":"fix(v::VariableRef, value::Number; force::Bool = false)\n\nFix a variable to a value. Update the fixing constraint if one exists, otherwise create a new one. See also unfix.\n\nIf the variable already has variable bounds and force=false, calling fix will throw an error. If force=true, existing variable bounds will be deleted, and the fixing constraint will be added. Note a variable will have no bounds after a call to unfix.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.FixRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.FixRef","text":"FixRef(v::VariableRef)\n\nReturn a constraint reference to the constraint fixing the value of v. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unfix-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.unfix","text":"unfix(v::VariableRef)\n\nDelete the fixing constraint of a variable.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.start_value-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.start_value","text":"start_value(v::VariableRef)\n\nReturn the start value (MOI attribute VariablePrimalStart) of the variable v. See also set_start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_start_value-Tuple{VariableRef,Number}","page":"JuMP Docs","title":"JuMP.set_start_value","text":"set_start_value(variable::VariableRef, value::Number)\n\nSet the start value (MOI attribute VariablePrimalStart) of the variable v to value. See also start_value.\n\nNote: VariablePrimalStarts are sometimes called \"MIP-starts\" or \"warmstarts\".\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_binary-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.is_binary","text":"is_binary(v::VariableRef)\n\nReturn true if v is constrained to be binary. See also BinaryRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_binary-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.set_binary","text":"set_binary(v::VariableRef)\n\nAdd a constraint on the variable v that it must take values in the set 01. See also unset_binary.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.BinaryRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.BinaryRef","text":"BinaryRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be binary. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unset_binary-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.unset_binary","text":"unset_binary(variable_ref::VariableRef)\n\nRemove the binary constraint on the variable variable_ref.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.is_integer-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.is_integer","text":"is_integer(v::VariableRef)\n\nReturn true if v is constrained to be integer. See also IntegerRef.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.set_integer-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.set_integer","text":"set_integer(variable_ref::VariableRef)\n\nAdd an integrality constraint on the variable variable_ref. See also unset_integer.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.IntegerRef-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.IntegerRef","text":"IntegerRef(v::VariableRef)\n\nReturn a constraint reference to the constraint constrainting v to be integer. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"JuMP/#JuMP.unset_integer-Tuple{VariableRef}","page":"JuMP Docs","title":"JuMP.unset_integer","text":"unset_integer(variable_ref::VariableRef)\n\nRemove the integrality constraint on the variable variable_ref.\n\n\n\n\n\n","category":"method"}]
}
